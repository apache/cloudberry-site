"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[61606],{82163:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>r,toc:()=>a});var d=n(85893),s=n(11151);const o={title:"pg_depend"},i="pg_depend",r={id:"sys-catalogs/sys-tables/pg-depend",title:"pg_depend",description:"The pgdepend system catalog table records the dependency relationships between database objects. This information allows DROP commands to find which other objects must be dropped by DROP CASCADE or prevent dropping in the DROP RESTRICT case. See also pgshdepend, which performs a similar function for dependencies involving objects that are shared across a Cloudberry system.",source:"@site/docs/sys-catalogs/sys-tables/pg-depend.md",sourceDirName:"sys-catalogs/sys-tables",slug:"/sys-catalogs/sys-tables/pg-depend",permalink:"/docs/next/sys-catalogs/sys-tables/pg-depend",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sys-catalogs/sys-tables/pg-depend.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1757492265,formattedLastUpdatedAt:"Sep 10, 2025",frontMatter:{title:"pg_depend"},sidebar:"docsbars",previous:{title:"pg_authid",permalink:"/docs/next/sys-catalogs/sys-tables/pg-authid"},next:{title:"pg_description",permalink:"/docs/next/sys-catalogs/sys-tables/pg-description"}},c={},a=[];function h(e){const t={a:"a",code:"code",h1:"h1",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(t.h1,{id:"pg_depend",children:"pg_depend"}),"\n",(0,d.jsxs)(t.p,{children:["The ",(0,d.jsx)(t.code,{children:"pg_depend"})," system catalog table records the dependency relationships between database objects. This information allows ",(0,d.jsx)(t.code,{children:"DROP"})," commands to find which other objects must be dropped by ",(0,d.jsx)(t.code,{children:"DROP CASCADE"})," or prevent dropping in the ",(0,d.jsx)(t.code,{children:"DROP RESTRICT"})," case. See also ",(0,d.jsx)(t.a,{href:"/docs/next/sys-catalogs/sys-tables/pg-shdepend",children:"pg_shdepend"}),", which performs a similar function for dependencies involving objects that are shared across a Cloudberry system."]}),"\n",(0,d.jsxs)(t.p,{children:["In all cases, a ",(0,d.jsx)(t.code,{children:"pg_depend"})," entry indicates that the referenced object may not be dropped without also dropping the dependent object. However, there are several subtypes identified by ",(0,d.jsx)(t.code,{children:"deptype"}),":"]}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"DEPENDENCY_NORMAL (n)"})," \u2014 A normal relationship between separately-created objects. The dependent object may be dropped without affecting the referenced object. The referenced object may only be dropped by specifying ",(0,d.jsx)(t.code,{children:"CASCADE"}),", in which case the dependent object is dropped, too. Example: a table column has a normal dependency on its data type."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"DEPENDENCY_AUTO (a)"})," \u2014 The dependent object can be dropped separately from the referenced object, and should be automatically dropped (regardless of ",(0,d.jsx)(t.code,{children:"RESTRICT"})," or ",(0,d.jsx)(t.code,{children:"CASCADE"})," mode) if the referenced object is dropped. Example: a named constraint on a table is made auto-dependent on the table, so that it will go away if the table is dropped."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"DEPENDENCY_INTERNAL (i)"})," \u2014 The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation. A direct ",(0,d.jsx)(t.code,{children:"DROP"})," of the dependent object will be disallowed outright (issue a ",(0,d.jsx)(t.code,{children:"DROP"})," against the referenced object instead). A ",(0,d.jsx)(t.code,{children:"DROP"})," of the referenced object will be propagated through to drop the dependent object whether ",(0,d.jsx)(t.code,{children:"CASCADE"})," is specified or not. If the dependent object has to be dropped due to a dependency on some other object being removed, its drop is converted to a drop of the referenced object, so that ",(0,d.jsx)(t.code,{children:"NORMAL"})," and ",(0,d.jsx)(t.code,{children:"AUTO"})," dependencies of the dependent object behave much like they were dependencies of the referenced object. Example: a view's ",(0,d.jsx)(t.code,{children:"ON SELECT"})," rule is made internally dependent on the view, preventing it from being dropped while the view remains. Dependencies of the rule (such as tables it refers to) act as if they were dependencies of the view."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"DEPENDENCY_PARTITION_PRI (P)"}),", ",(0,d.jsx)(t.strong,{children:"DEPENDENCY_PARTITION_SEC (S)"})," - The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation; however, unlike ",(0,d.jsx)(t.code,{children:"INTERNAL"}),", there is more than one such referenced object. The dependent object must not be dropped unless at least one of these referenced objects is dropped; if any one is, the dependent object should be dropped whether or not ",(0,d.jsx)(t.code,{children:"CASCADE"})," is specified. Also unlike ",(0,d.jsx)(t.code,{children:"INTERNAL"}),", a drop of some other object that the dependent object depends on does not result in automatic deletion of any partition-referenced object. Hence, if the drop does not cascade to at least one of these objects via some other path, it will be refused. (In most cases, the dependent object shares all its non-partition dependencies with at least one partition-referenced object, so that this restriction does not result in blocking any cascaded delete.) Primary and secondary partition dependencies behave identically except that the primary dependency is preferred for use in error messages; hence, a partition-dependent object should have one primary partition dependency and one or more secondary partition dependencies. Note that partition dependencies are made in addition to, not instead of, any dependencies the object would normally have. This simplifies ",(0,d.jsx)(t.code,{children:"ATTACH/DETACH PARTITION"})," operations: the partition dependencies need only be added or removed. Example: a child partitioned index is made partition-dependent on both the partition table it is on and the parent partitioned index, so that it goes away if either of those is dropped, but not otherwise. The dependency on the parent index is primary, so that if the user tries to drop the child partitioned index, the error message will suggest dropping the parent index instead (not the table)."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"DEPENDENCY_EXTENSION (e)"})," - The dependent object is a member of the extension that is the referenced object (see ",(0,d.jsx)(t.code,{children:"pg_extension"}),"). The dependent object can be dropped only via ",(0,d.jsx)(t.code,{children:"DROP EXTENSION"})," on the referenced object. Functionally, this dependency type acts the same as an ",(0,d.jsx)(t.code,{children:"INTERNAL"})," dependency, but it's kept separate for clarity and to simplify pg_dump."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"DEPENDENCY_AUTO_EXTENSION (x)"})," - The dependent object is not a member of the extension that is the referenced object (and so it should not be ignored by pg_dump), but it cannot function without the extension and should be auto-dropped if the extension is. The dependent object may be dropped on its own as well. Functionally this dependency type acts the same as an ",(0,d.jsx)(t.code,{children:"AUTO"})," dependency, but it's kept separate for clarity and to simplify pg_dump."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"DEPENDENCY_PIN (p)"})," \u2014 There is no dependent object; this type of entry is a signal that the system itself depends on the referenced object, and so that object must never be deleted. Entries of this type are created only by system initialization. The columns for the dependent object contain zeroes."]}),"\n"]}),"\n",(0,d.jsxs)(t.p,{children:["Note that it's quite possible for two objects to be linked by more than one ",(0,d.jsx)(t.code,{children:"pg_depend"})," entry. For example, a child partitioned index would have both a partition-type dependency on its associated partition table, and an auto dependency on each column of that table that it indexes. This sort of situation expresses the union of multiple dependency semantics. A dependent object can be dropped without ",(0,d.jsx)(t.code,{children:"CASCADE"})," if any of its dependencies satisfies its condition for automatic dropping. Conversely, all the dependencies' restrictions about which objects must be dropped together must be satisfied."]}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"column"}),(0,d.jsx)(t.th,{children:"type"}),(0,d.jsx)(t.th,{children:"references"}),(0,d.jsx)(t.th,{children:"description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"classid"})}),(0,d.jsx)(t.td,{children:"oid"}),(0,d.jsxs)(t.td,{children:[(0,d.jsx)(t.a,{href:"/docs/next/sys-catalogs/sys-tables/pg-class",children:"pg_class"}),".oid"]}),(0,d.jsx)(t.td,{children:"The object identifier of the system catalog the dependent object is in."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"objid"})}),(0,d.jsx)(t.td,{children:"oid"}),(0,d.jsx)(t.td,{children:"any OID column"}),(0,d.jsx)(t.td,{children:"The object identifier of the specific dependent object."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"objsubid"})}),(0,d.jsx)(t.td,{children:"integer"}),(0,d.jsx)(t.td,{children:"\xa0"}),(0,d.jsxs)(t.td,{children:["For a table column, this is the column number (the ",(0,d.jsx)(t.code,{children:"objid"})," and ",(0,d.jsx)(t.code,{children:"classid"})," refer to the table itself). For all other object types, this column is zero."]})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"refclassid"})}),(0,d.jsx)(t.td,{children:"oid"}),(0,d.jsxs)(t.td,{children:[(0,d.jsx)(t.a,{href:"/docs/next/sys-catalogs/sys-tables/pg-class",children:"pg_class"}),".oid"]}),(0,d.jsx)(t.td,{children:"The object identifier of the system catalog the referenced object is in."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"refobjid"})}),(0,d.jsx)(t.td,{children:"oid"}),(0,d.jsx)(t.td,{children:"any OID column"}),(0,d.jsx)(t.td,{children:"The object identifier of the specific referenced object."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"refobjsubid"})}),(0,d.jsx)(t.td,{children:"integer"}),(0,d.jsx)(t.td,{children:"\xa0"}),(0,d.jsxs)(t.td,{children:["For a table column, this is the referenced column number (the ",(0,d.jsx)(t.code,{children:"refobjid"})," and ",(0,d.jsx)(t.code,{children:"refclassid"})," refer to the table itself). For all other object types, this column is zero."]})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"deptype"})}),(0,d.jsx)(t.td,{children:"char"}),(0,d.jsx)(t.td,{children:"\xa0"}),(0,d.jsx)(t.td,{children:"The code defining the specific semantics of this dependency relationship."})]})]})]})]})}function l(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,d.jsx)(t,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>i});var d=n(67294);const s={},o=d.createContext(s);function i(e){const t=d.useContext(o);return d.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),d.createElement(o.Provider,{value:t},e.children)}}}]);