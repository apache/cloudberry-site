"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[54409],{98725:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>g,frontMatter:()=>i,metadata:()=>a,toc:()=>o});var r=n(85893),s=n(11151);const i={title:"pg_aggregate"},d="pg_aggregate",a={id:"sys-catalogs/sys-tables/pg-aggregate",title:"pg_aggregate",description:"The pgaggregate table in the pgcatalog schema stores information about aggregate functions. An aggregate function is a function that operates on a set of values (typically one column from each row that matches a query condition) and returns a single value computed from all these values. Typical aggregate functions are sum, count, and max. Each entry in pgaggregate is an extension of an entry in pgproc. The pg_proc entry carries the aggregate's name, input and output data types, and other information that is similar to ordinary functions.",source:"@site/docs/sys-catalogs/sys-tables/pg-aggregate.md",sourceDirName:"sys-catalogs/sys-tables",slug:"/sys-catalogs/sys-tables/pg-aggregate",permalink:"/docs/next/sys-catalogs/sys-tables/pg-aggregate",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sys-catalogs/sys-tables/pg-aggregate.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1754561742,formattedLastUpdatedAt:"Aug 7, 2025",frontMatter:{title:"pg_aggregate"},sidebar:"docsbars",previous:{title:"gp_version_at_initdb",permalink:"/docs/next/sys-catalogs/sys-tables/gp-version-at-initdb"},next:{title:"pg_am",permalink:"/docs/next/sys-catalogs/sys-tables/pg-am"}},c={},o=[];function l(e){const t={code:"code",em:"em",h1:"h1",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"pg_aggregate",children:"pg_aggregate"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"pg_aggregate"})," table in the ",(0,r.jsx)(t.code,{children:"pg_catalog"})," schema stores information about aggregate functions. An aggregate function is a function that operates on a set of values (typically one column from each row that matches a query condition) and returns a single value computed from all these values. Typical aggregate functions are ",(0,r.jsx)(t.code,{children:"sum"}),", ",(0,r.jsx)(t.code,{children:"count"}),", and ",(0,r.jsx)(t.code,{children:"max"}),". Each entry in ",(0,r.jsx)(t.code,{children:"pg_aggregate"})," is an extension of an entry in ",(0,r.jsx)(t.code,{children:"pg_proc"}),". The ",(0,r.jsx)(t.code,{children:"pg_proc"})," entry carries the aggregate's name, input and output data types, and other information that is similar to ordinary functions."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"column"}),(0,r.jsx)(t.th,{children:"type"}),(0,r.jsx)(t.th,{children:"references"}),(0,r.jsx)(t.th,{children:"description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggfnoid"})}),(0,r.jsx)(t.td,{children:"regproc"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_proc.oid"})}),(0,r.jsx)(t.td,{children:"OID of the aggregate function"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggkind"})}),(0,r.jsx)(t.td,{children:"char"}),(0,r.jsx)(t.td,{children:"\xa0"}),(0,r.jsxs)(t.td,{children:["Aggregate kind: ",(0,r.jsx)(t.code,{children:"n"})," for ",(0,r.jsx)(t.em,{children:"normal"})," aggregates, ",(0,r.jsx)(t.code,{children:"o"})," for ",(0,r.jsx)(t.em,{children:"ordered-set"})," aggregates, or ",(0,r.jsx)(t.code,{children:"h"})," for ",(0,r.jsx)(t.em,{children:"hypothetical-set"})," aggregates"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggnumdirectargs"})}),(0,r.jsx)(t.td,{children:"smallint"}),(0,r.jsx)(t.td,{children:"\xa0"}),(0,r.jsxs)(t.td,{children:["Number of direct (non-aggregated) arguments of an ordered-set or hypothetical-set aggregate, counting a variadic array as one argument. If equal to ",(0,r.jsx)(t.code,{children:"pronargs"}),", the aggregate must be variadic and the variadic array describes the aggregated arguments as well as the final direct arguments. Always zero for normal aggregates."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggtransfn"})}),(0,r.jsx)(t.td,{children:"regproc"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_proc.oid"})}),(0,r.jsx)(t.td,{children:"Transition function OID"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggfinalfn"})}),(0,r.jsx)(t.td,{children:"regproc"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_proc.oid"})}),(0,r.jsx)(t.td,{children:"Final function OID (zero if none)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggcombinefn"})}),(0,r.jsx)(t.td,{children:"regproc"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_proc.oid"})}),(0,r.jsx)(t.td,{children:"Combine function OID (zero if none)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggserialfn"})}),(0,r.jsx)(t.td,{children:"regproc"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_proc.oid"})}),(0,r.jsxs)(t.td,{children:["OID of the serialization function to convert transtype to ",(0,r.jsx)(t.code,{children:"bytea"})," (zero if none)"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggdeserialfn"})}),(0,r.jsx)(t.td,{children:"regproc"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_proc.oid"})}),(0,r.jsxs)(t.td,{children:["OID of the deserialization function to convert ",(0,r.jsx)(t.code,{children:"bytea"})," to transtype (zero if none)"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggmtransfn"})}),(0,r.jsx)(t.td,{children:"regproc"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_proc.oid"})}),(0,r.jsx)(t.td,{children:"Forward transition function OID for moving-aggregate mode (zero if none)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggminvtransfn"})}),(0,r.jsx)(t.td,{children:"regproc"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_proc.oid"})}),(0,r.jsx)(t.td,{children:"Inverse transition function OID for moving-aggregate mode (zero if none)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggmfinalfn"})}),(0,r.jsx)(t.td,{children:"regproc"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_proc.oid"})}),(0,r.jsx)(t.td,{children:"Final function OID for moving-aggregate mode (zero if none)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggfinalextra"})}),(0,r.jsx)(t.td,{children:"bool"}),(0,r.jsx)(t.td,{children:"\xa0"}),(0,r.jsxs)(t.td,{children:["True to pass extra dummy arguments to ",(0,r.jsx)(t.code,{children:"aggfinalfn"})]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggmfinalextra"})}),(0,r.jsx)(t.td,{children:"bool"}),(0,r.jsx)(t.td,{children:"\xa0"}),(0,r.jsxs)(t.td,{children:["True to pass extra dummy arguments to ",(0,r.jsx)(t.code,{children:"aggmfinalfn"})]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggfinalmodify"})}),(0,r.jsx)(t.td,{children:"char"}),(0,r.jsx)(t.td,{}),(0,r.jsxs)(t.td,{children:["Indicates whether ",(0,r.jsx)(t.code,{children:"aggfinalfn"})," modifies the transition state"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggmfinalmodify"})}),(0,r.jsx)(t.td,{children:"char"}),(0,r.jsx)(t.td,{}),(0,r.jsxs)(t.td,{children:["Indicates whether ",(0,r.jsx)(t.code,{children:"aggmfinalfn"})," modifies the transition state"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggsortop"})}),(0,r.jsx)(t.td,{children:"oid"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_operator.oid"})}),(0,r.jsx)(t.td,{children:"Associated sort operator OID (zero if none)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggtranstype"})}),(0,r.jsx)(t.td,{children:"oid"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_type.oid"})}),(0,r.jsx)(t.td,{children:"Data type of the aggregate function's internal transition (state) data"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggtransspace"})}),(0,r.jsx)(t.td,{children:"integer"}),(0,r.jsx)(t.td,{children:"\xa0"}),(0,r.jsx)(t.td,{children:"Approximate average size (in bytes) of the transition state data, or zero to use a default estimate"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggmtranstype"})}),(0,r.jsx)(t.td,{children:"oid"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pg_type.oid"})}),(0,r.jsx)(t.td,{children:"Data type of the aggregate function's internal transition (state) data for moving-aggregate mode (zero if none)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggmtransspace"})}),(0,r.jsx)(t.td,{children:"integer"}),(0,r.jsx)(t.td,{children:"\xa0"}),(0,r.jsx)(t.td,{children:"Approximate average size (in bytes) of the transition state data for moving-aggregate mode, or zero to use a default estimate"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"agginitval"})}),(0,r.jsx)(t.td,{children:"text"}),(0,r.jsx)(t.td,{children:"\xa0"}),(0,r.jsx)(t.td,{children:"The initial value of the transition state. This is a text field containing the initial value in its external string representation. If this field is NULL, the transition state value starts out NULL."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggminitval"})}),(0,r.jsx)(t.td,{children:"text"}),(0,r.jsx)(t.td,{children:"\xa0"}),(0,r.jsx)(t.td,{children:"The initial value of the transition state for moving- aggregate mode. This is a text field containing the initial value in its external string representation. If this field is NULL, the transition state value starts out NULL."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"aggrepsafeexec"})}),(0,r.jsx)(t.td,{children:"bool"}),(0,r.jsx)(t.td,{}),(0,r.jsx)(t.td,{children:"True if the aggregate is safe to execute in parallel."})]})]})]})]})}function g(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>d});var r=n(67294);const s={},i=r.createContext(s);function d(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);