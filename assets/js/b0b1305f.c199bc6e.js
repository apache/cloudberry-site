"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[33834],{10109:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var i=s(85893),t=s(11151);const r={title:"PAX Storage Format"},l="PAX Storage Format",a={id:"operate-with-data/pax-table-format",title:"PAX Storage Format",description:"Apache Cloudberry supports the PAX (Partition Attributes Across) storage format.",source:"@site/versioned_docs/version-2.x/operate-with-data/pax-table-format.md",sourceDirName:"operate-with-data",slug:"/operate-with-data/pax-table-format",permalink:"/docs/operate-with-data/pax-table-format",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/operate-with-data/pax-table-format.md",tags:[],version:"2.x",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1756369829,formattedLastUpdatedAt:"Aug 28, 2025",frontMatter:{title:"PAX Storage Format"},sidebar:"docsbars",previous:{title:"Heap and AO Table Formats",permalink:"/docs/operate-with-data/heap-and-ao-table-formats"},next:{title:"Work with Transactions",permalink:"/docs/operate-with-data/work-with-transactions"}},o={},d=[{value:"Applicable scenarios",id:"applicable-scenarios",level:2},{value:"Enable PAX when building Cloudberry from source code",id:"enable-pax-when-building-cloudberry-from-source-code",level:2},{value:"Usage",id:"usage",level:2},{value:"Create a PAX table",id:"create-a-pax-table",level:3},{value:"View the format of an existing table",id:"view-the-format-of-an-existing-table",level:3},{value:"Support for TOAST",id:"support-for-toast",level:2},{value:"Support for clustering",id:"support-for-clustering",level:2},{value:"Clustering strategies",id:"clustering-strategies",level:3},{value:"Conflicts between clustering types",id:"conflicts-between-clustering-types",level:3},{value:"Bloom filter support",id:"bloom-filter-support",level:2},{value:"Bloom filter options",id:"bloom-filter-options",level:3},{value:"Sparse filtering",id:"sparse-filtering",level:2},{value:"Expression support examples",id:"expression-support-examples",level:3},{value:"Supported expression types",id:"supported-expression-types",level:3},{value:"Partial condition support",id:"partial-condition-support",level:3},{value:"View data change records on PAX tables in WAL logs",id:"view-data-change-records-on-pax-tables-in-wal-logs",level:2},{value:"Example: operate PAX tables and view WAL logs",id:"example-operate-pax-tables-and-view-wal-logs",level:3},{value:"Limitations for PAX tables",id:"limitations-for-pax-tables",level:2},{value:"PAX-related SQL options",id:"pax-related-sql-options",level:2},{value:"PAX-related system parameters",id:"pax-related-system-parameters",level:2},{value:"Best practices",id:"best-practices",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"pax-storage-format",children:"PAX Storage Format"}),"\n",(0,i.jsx)(n.p,{children:"Apache Cloudberry supports the PAX (Partition Attributes Across) storage format."}),"\n",(0,i.jsx)(n.p,{children:"PAX is a database storage format that combines the benefits of row-based storage (NSM, N-ary Storage Model) and column-based storage (DSM, Decomposition Storage Model). It is designed to improve query performance, particularly in terms of cache efficiency. In OLAP scenarios, PAX offers batch write performance similar to row-based storage and read performance like column-based storage. PAX can adapt to both cloud environments with object storage models and traditional offline physical file-based storage methods."}),"\n",(0,i.jsx)(n.p,{children:"Compared to traditional storage formats, PAX has the following features:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Data updates and deletions: PAX uses a mark-and-delete approach for data updates and deletions. This effectively manages changes in physical files without immediately rewriting the entire data file."}),"\n",(0,i.jsx)(n.li,{children:"Concurrency control and read-write isolation: PAX uses Multi-Version Concurrency Control (MVCC) to achieve efficient concurrency control and read-write isolation. The control granularity reaches the level of individual data files, enhancing operation safety and efficiency."}),"\n",(0,i.jsx)(n.li,{children:"Index support: PAX supports B-tree indexes, which help speed up query operations. This is particularly useful for improving data retrieval speed when dealing with large amounts of data."}),"\n",(0,i.jsx)(n.li,{children:"Data encoding and compression: PAX offers multiple data encoding methods (such as run-length encoding and delta encoding) and compression options (such as zstd and zlib), with various compression levels. These features help reduce storage space requirements while optimizing read performance."}),"\n",(0,i.jsx)(n.li,{children:"Statistics: Data files contain detailed statistics that are used for quick filtering and query optimization, reducing unnecessary data scanning and speeding up query processing."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"applicable-scenarios",children:"Applicable scenarios"}),"\n",(0,i.jsx)(n.p,{children:"The hybrid storage capability of PAX makes it suitable for complex OLAP applications that need to handle large amounts of data writes and frequent queries. Whether you are looking for a high-performance data analysis solution in a cloud infrastructure or dealing with large datasets in a traditional data center environment, PAX can provide strong support."}),"\n",(0,i.jsx)(n.h2,{id:"enable-pax-when-building-cloudberry-from-source-code",children:"Enable PAX when building Cloudberry from source code"}),"\n",(0,i.jsx)(n.p,{children:"To enable PAX when building Apache Cloudberry from source code, you need to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Make sure that these dependency requirements are met:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"C/C++ Compiler: GCC/GCC-C++ 11 or later"}),"\n",(0,i.jsx)(n.li,{children:"CMake: 3.11 or later"}),"\n",(0,i.jsx)(n.li,{children:"Protobuf: 3.5.0 or later"}),"\n",(0,i.jsx)(n.li,{children:"ZSTD (libzstd): 1.4.0 or later"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Run the following command at the top level of the Cloudberry source code directory to download the submodules:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"git submodule update --init --recursive\n"})}),"\n",(0,i.jsx)(n.p,{children:"The following submodules will be downloaded for building and tesing PAX:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["yyjson (",(0,i.jsx)(n.code,{children:"dependency/yyjson"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["cpp-stub (",(0,i.jsx)(n.code,{children:"contrib/pax_storage/src/cpp/contrib"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["googlebench (",(0,i.jsx)(n.code,{children:"contrib/pax_storage/src/cpp/contrib"}),") (Now it's an optional dependency, it will be downloaded but not built by default. If needed, you can build it manually.)"]}),"\n",(0,i.jsxs)(n.li,{children:["googletest (",(0,i.jsx)(n.code,{children:"contrib/pax_storage/src/cpp/contrib"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["tabulate (",(0,i.jsx)(n.code,{children:"contrib/pax_storage/src/cpp/contrib"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"The submodules above are already included in the latest release source code archive, so you do not need to download the submodules manually after extracting the archive."})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["When running the ",(0,i.jsx)(n.code,{children:"configure"})," command, add the ",(0,i.jsx)(n.code,{children:"--enable-pax"})," option. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"./configure --enable-pax --with-perl --with-python --with-libxml --with-gssapi --prefix=/usr/local/cloudberrydb\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In addition, to enable PAX in ",(0,i.jsx)(n.code,{children:"DEBUG"})," mode, add the ",(0,i.jsx)(n.code,{children:"--enable-cassert"})," option (along with ",(0,i.jsx)(n.code,{children:"--enable-pax"}),") in the ",(0,i.jsx)(n.code,{children:"configure"})," command, and the ",(0,i.jsx)(n.code,{children:"GTEST"})," in PAX will be built. Run ",(0,i.jsx)(n.code,{children:"GTEST"})," as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd contrib/pax_storage/build\n./src/cpp/test_main\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["If you are interested in the implementation details of PAX, you can refer to the ",(0,i.jsx)(n.a,{href:"https://github.com/apache/cloudberry/tree/main/contrib/pax_storage/doc",children:"design documents in GitHub repo"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.h3,{id:"create-a-pax-table",children:"Create a PAX table"}),"\n",(0,i.jsx)(n.p,{children:"To create a table in PAX format, you need to set the table access method to PAX. You can do this in one of the following ways:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"USING PAX"})," clause explicitly when creating the table, for example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t1(a int, b int, c text) USING PAX;\n-- t1 is a PAX table and can be used like a normal heap table.\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Set the default table access method to PAX and then create the table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Set the default table access method. From now on, newly created tables will use PAX format.\nSET default_table_access_method = pax;\n\n-- Implicitly use the default access method, which is PAX.\nCREATE TABLE t1(a int, b int, c text);\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When creating a table, you can also specify minimum and maximum value information for certain columns to speed up queries:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Use WITH(minmax_columns='b,c') to specify that columns b and c\n-- should record min and max statistics.\n-- This helps optimize queries involving these two columns,\n-- because the system can quickly determine which data blocks might contain matching data.\nCREATE TABLE p2(a INT, b INT, c INT) USING pax WITH(minmax_columns='b,c');\n\nINSERT INTO p2 SELECT i, i * 2, i * 3 FROM generate_series(1,10)i;\n\n-- because column b has minmax statistics,\n-- the system can quickly locate the data blocks that might contain the value, speeding up the query.\nSELECT * FROM p2 WHERE b = 4;\n\n-- Similarly, because of the minmax information on column b, the system can quickly determine that no data blocks can meet this condition\n-- (if all generated values are positive), possibly returning no data immediately and avoiding unnecessary data scans.\nSELECT * FROM p2 WHERE b < 0;\n\n-- Modify the minmax statistics settings for table p2 to apply only to column b. For data inserted later,\n-- only column b will maintain this statistical information, and it won't affect existing data or trigger any rewrites or adjustments.\nALTER TABLE p2 SET(minmax_columns='b');\n"})}),"\n",(0,i.jsx)(n.h3,{id:"view-the-format-of-an-existing-table",children:"View the format of an existing table"}),"\n",(0,i.jsx)(n.p,{children:"To check whether a table is in PAX format, you can use one of the following methods:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"psql"})," command ",(0,i.jsx)(n.code,{children:"\\d+"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'gpadmin=# \\d+ t1\n                                            Table "public.t1"\nColumn |  Type   | Collation | Nullable | Default | Storage  | Compression | Stats target | Description\n--------+---------+-----------+----------+---------+----------+-------------+--------------+-------------\na      | integer |           |          |         | plain    |             |              |\nb      | integer |           |          |         | plain    |             |              |\nc      | text    |           |          |         | extended |             |              |\nDistributed by: (a)\nAccess method: pax\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Query the system catalog tables ",(0,i.jsx)(n.code,{children:"pg_class"})," and ",(0,i.jsx)(n.code,{children:"pg_am"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT relname, amname FROM pg_class, pg_am WHERE relam = pg_am.oid AND relname = 't1';\n\nrelname | amname\n---------+--------\nt1      | pax\n(1 row)\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"support-for-toast",children:"Support for TOAST"}),"\n",(0,i.jsx)(n.p,{children:"If some columns in a PAX table contain large values, you can enable TOAST storage to store these large values in a separate TOAST file. This helps to make the data in the main data file more compact, allowing you to scan more tuples within the same data size."}),"\n",(0,i.jsx)(n.p,{children:"By default, the TOAST storage is enabled for PAX tables. Unlike PostgreSQL, the TOAST storage supported by PAX does not rely on Page management, which allows PAX to store data larger than 2 MiB."}),"\n",(0,i.jsxs)(n.p,{children:["You can configure TOAST-related thresholds using the following parameters. For more details, refer to ",(0,i.jsx)(n.a,{href:"#pax-related-system-parameters",children:"PAX-related system parameters"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pax_enable_toast"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pax_min_size_of_compress_toast"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pax_min_size_of_external_toast"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"support-for-clustering",children:"Support for clustering"}),"\n",(0,i.jsxs)(n.p,{children:["Apache Cloudberry supports z-ordering for PAX tables, which greatly improves performance when managing and querying multi-dimensional data. Using the clustering feature, you can organize data in PAX tables using two different sorting strategies: index-based clustering and ",(0,i.jsx)(n.code,{children:"reloptions"}),"-based clustering. Note that the two strategies are mutually exclusive, and you can only choose one."]}),"\n",(0,i.jsx)(n.h3,{id:"clustering-strategies",children:"Clustering strategies"}),"\n",(0,i.jsx)(n.p,{children:"You can use the clustering feature of Apache Cloudberry to physically sort and optimize table data. The goal is to improve query performance by reorganizing the physical storage order of the data. In PAX tables, the clustering feature provides two different strategies for sorting data:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Index-based clustering. This strategy is based on B-tree indexes and works similarly to the native clustering method in PostgreSQL. It is suitable when an index has already been created for the table."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t2(c1 int, c2 int) USING PAX;\nCREATE INDEX c1_idx ON t2(c1);\nCLUSTER t2 USING c1_idx;\nDROP TABLE t2;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"reloptions"}),"-based clustering. PAX tables support clustering operations based on ",(0,i.jsx)(n.code,{children:"reloptions"})," where ",(0,i.jsx)(n.code,{children:"cluster_columns"})," are specified, and it provides the following sorting methods:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Z-order clustering: This method encodes the values of multiple columns into a byte array and sorts by this byte array. It is ideal for cases where multiple columns are used as query conditions (with no fixed order for the columns in the query). This method greatly enhances performance for multi-dimensional data queries. However, it is not suitable for string columns with the same prefix. When ",(0,i.jsx)(n.code,{children:"cluster_type"})," is not specified, PAX uses z-order sorting as the default clustering strategy:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t2(c1 int, c2 float, c3 text) USING PAX WITH (cluster_columns='c1,c2');\nINSERT INTO t2 SELECT i, i, i::text FROM generate_series(1, 100000) i;\nCLUSTER t2;\nDROP TABLE t2;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, the data in table ",(0,i.jsx)(n.code,{children:"t2"})," is sorted using z-order by the ",(0,i.jsx)(n.code,{children:"c1"})," and ",(0,i.jsx)(n.code,{children:"c2"})," columns. This sorting method provides great performance improvement in multi-dimensional query scenarios."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Lexical clustering: This method sorts by the values and order of the columns, and it is primarily used for sorting and optimizing queries on string columns with the same prefix. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t2(c1 int, c2 float, c3 text) USING PAX WITH (cluster_columns='c1,c2', cluster_type='lexical');\nINSERT INTO t2 SELECT i, i, i::text FROM generate_series(1, 100000) i;\nCLUSTER t2;\nDROP TABLE t2;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, the data in table ",(0,i.jsx)(n.code,{children:"t2"})," is sorted lexically by the ",(0,i.jsx)(n.code,{children:"c1"})," and ",(0,i.jsx)(n.code,{children:"c2"})," columns. This sorting method is well-suited for columns with the same prefix."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"conflicts-between-clustering-types",children:"Conflicts between clustering types"}),"\n",(0,i.jsxs)(n.p,{children:["Note that index-based clustering and ",(0,i.jsx)(n.code,{children:"cluster_columns"}),"-based clustering cannot be used at the same time. If a table has already been clustered based on an index (or ",(0,i.jsx)(n.code,{children:"cluster_columns"}),"), you cannot specify ",(0,i.jsx)(n.code,{children:"cluster_columns"})," (or an index) for clustering."]}),"\n",(0,i.jsx)(n.p,{children:"An example of handling cluster conflicts:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Creates a table and uses index-based clustering\nCREATE TABLE t2(c1 int, c2 float, c3 text) USING PAX;\nCREATE INDEX t2_idx ON t2(c1);\nCLUSTER t2 USING t2_idx;\n\n-- Tries to use cluster columns (will fail)\nALTER TABLE t2 SET (cluster_columns='c1,c2', cluster_type='zorder');\n-- Tries to use lexical clustering (will fail)\nALTER TABLE t2 SET (cluster_columns='c1,c2', cluster_type='lexical');\n\n-- Drops the index and successfully use lexical clustering\nDROP INDEX t2_idx;\nALTER TABLE t2 SET (cluster_columns='c1,c2', cluster_type='lexical');\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, after table ",(0,i.jsx)(n.code,{children:"t2"})," is clustered using an index, attempts to set z-order or lexical clustering using ",(0,i.jsx)(n.code,{children:"cluster_columns"})," will fail, until the index is dropped."]}),"\n",(0,i.jsx)(n.h2,{id:"bloom-filter-support",children:"Bloom filter support"}),"\n",(0,i.jsxs)(n.p,{children:["Apache Cloudberry supports bloom filters, allowing you to generate and maintain bloom filter information at the column level. This feature helps quickly filter data blocks and improves query performance, especially when using ",(0,i.jsx)(n.code,{children:"IN"})," conditions with multiple values, greatly reducing unnecessary data scans."]}),"\n",(0,i.jsx)(n.h3,{id:"bloom-filter-options",children:"Bloom filter options"}),"\n",(0,i.jsxs)(n.p,{children:["You can specify the columns for which you want to record bloom filter information by setting the ",(0,i.jsx)(n.code,{children:"bloomfilter_columns"})," option. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE p1 (\n    a int,\n    b int,\n    c text\n) USING PAX WITH (bloomfilter_columns='b,c,a');\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, bloom filters will be generated for columns ",(0,i.jsx)(n.code,{children:"b"}),", ",(0,i.jsx)(n.code,{children:"c"}),", and ",(0,i.jsx)(n.code,{children:"a"})," in the table ",(0,i.jsx)(n.code,{children:"p1"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The size of the bloom filter is controlled by the following GUC (global user configuration) parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pax_max_tuples_per_file"}),": Controls the maximum number of tuples stored in each data file."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pax_bloom_filter_work_memory_bytes"}),": Controls the maximum memory allowed for the bloom filter."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Sets the maximum number of tuples per file.\nSET pax_max_tuples_per_file = 131073;\n\n-- Sets the maximum bloom filter memory.\nSET pax_bloom_filter_work_memory_bytes = 1048576;  -- 1MB\n\n-- Creates a table and specifies bloom filter options for columns.\nCREATE TABLE p1 (\n    a int,\n    b int,\n    c text\n) USING PAX WITH (bloomfilter_columns='b,c,a');\n"})}),"\n",(0,i.jsx)(n.p,{children:"The size of the generated bloom filter is calculated as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"ceil(min(pax_max_tuples_per_file * 2, pax_bloom_filter_work_memory_bytes))\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ceil"})," is a rounding function, which ensures that the size of the bloom filter is always a power of ",(0,i.jsx)(n.code,{children:"2"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"sparse-filtering",children:"Sparse filtering"}),"\n",(0,i.jsx)(n.p,{children:"Sparse filtering is a data scanning optimization provided by the PAX storage format. It improves query performance by skipping file scans that do not meet conditions and reducing the amount of data block to be scanned within files."}),"\n",(0,i.jsx)(n.p,{children:"To use sparse filtering, make sure that the following conditions are\nmet:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The system parameter ",(0,i.jsx)(n.code,{children:"pax_enable_sparse_filter"})," is set to ",(0,i.jsx)(n.code,{children:"ON"})," (default value)."]}),"\n",(0,i.jsxs)(n.li,{children:["Statistics have been configured for the relevant columns (",(0,i.jsx)(n.code,{children:"min"}),"/",(0,i.jsx)(n.code,{children:"max"})," or bloom filter)."]}),"\n",(0,i.jsxs)(n.li,{children:["The query contains filter conditions (",(0,i.jsx)(n.code,{children:"WHERE"})," clause) for these columns"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"expression-support-examples",children:"Expression support examples"}),"\n",(0,i.jsx)(n.p,{children:"PAX supports basic conditional expressions. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Creates test table\nCREATE TABLE a(v1 int, v2 int, v3 int) USING PAX WITH(minmax_columns='v1, v2, v3');\n\n-- Basic conditions\nSELECT * FROM a WHERE v1 <= 3;                                    -- Full condition support. root is OpExpr.\nSELECT * FROM a WHERE v1 != NULL;                                -- Full condition support. root is NULLTest.\n\n-- Multiple conditions\nSELECT * FROM a WHERE v1 <= 3 AND v2 >= 3;                       -- Full condition support. Tree structure has only one level.\nSELECT * FROM a WHERE v1 <= 3 AND v2 >= 3 AND v3 >= 3;          -- Full condition support.\nSELECT * FROM a WHERE v1 <= 3 AND v2 >= 3 AND v3 != NULL;       -- Full condition support.\n"})}),"\n",(0,i.jsx)(n.p,{children:"PAX also supports nested expression structures and certain operators. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Creates test table.\nCREATE TABLE a(v1 int, v2 int, v3 int) USING PAX WITH(minmax_columns='v1, v2, v3');\n\n-- Nested expressions.\nSELECT * FROM a WHERE (v1 <= 3 OR v2 > 3) AND v3 >= 10;         -- Full support for all conditions.\nSELECT * FROM a WHERE (v1 <= 3 AND v2 > 3) OR v3 >= 10;         -- Supports complete nested expressions.\n\n-- Operators.\nSELECT * FROM a WHERE v1 + v2 <= 3;\nSELECT * FROM a WHERE v1 + 10 <= 3;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["PAX can handle complete expression trees, including nested ",(0,i.jsx)(n.code,{children:"AND"}),"/",(0,i.jsx)(n.code,{children:"OR"})," conditions. This means that all the above queries can be optimized, and Apache Cloudberry will use all available filter conditions to improve query efficiency."]}),"\n",(0,i.jsx)(n.h3,{id:"supported-expression-types",children:"Supported expression types"}),"\n",(0,i.jsx)(n.p,{children:"PAX sparse filtering supports the following expression types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Arithmetic operators (",(0,i.jsx)(n.code,{children:"OpExpr"}),")"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Supports addition (",(0,i.jsx)(n.code,{children:"+"}),"), subtraction (",(0,i.jsx)(n.code,{children:"-"}),"), and multiplication (",(0,i.jsx)(n.code,{children:"*"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Division operations are not supported (due to difficulty in estimating negative number ranges)"}),"\n",(0,i.jsxs)(n.li,{children:["Examples: ",(0,i.jsx)(n.code,{children:"a + 1"}),", ",(0,i.jsx)(n.code,{children:"1 - a"}),", ",(0,i.jsx)(n.code,{children:"a * b"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Comparison operators (",(0,i.jsx)(n.code,{children:"OpExpr"}),")"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Supports ",(0,i.jsx)(n.code,{children:"<"}),", ",(0,i.jsx)(n.code,{children:"<="}),", ",(0,i.jsx)(n.code,{children:"="}),", ",(0,i.jsx)(n.code,{children:">="}),", ",(0,i.jsx)(n.code,{children:">"})]}),"\n",(0,i.jsxs)(n.li,{children:["Examples: ",(0,i.jsx)(n.code,{children:"a < 1"}),", ",(0,i.jsx)(n.code,{children:"a + 1 < 10"}),", ",(0,i.jsx)(n.code,{children:"a = b"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Logical operators (",(0,i.jsx)(n.code,{children:"BoolExpr"}),")"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Supports ",(0,i.jsx)(n.code,{children:"AND"}),", ",(0,i.jsx)(n.code,{children:"OR"}),", ",(0,i.jsx)(n.code,{children:"NOT"})]}),"\n",(0,i.jsxs)(n.li,{children:["Example: ",(0,i.jsx)(n.code,{children:"a < 10 AND b > 10"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["NULL value tests (",(0,i.jsx)(n.code,{children:"NullTest"}),")"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Supports ",(0,i.jsx)(n.code,{children:"IS NULL"}),", ",(0,i.jsx)(n.code,{children:"IS NOT NULL"})]}),"\n",(0,i.jsxs)(n.li,{children:["Examples: ",(0,i.jsx)(n.code,{children:"a IS NULL"}),", ",(0,i.jsx)(n.code,{children:"a IS NOT NULL"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Type casting (",(0,i.jsx)(n.code,{children:"FuncExpr"}),")"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Only supports basic type casting"}),"\n",(0,i.jsxs)(n.li,{children:["Example: ",(0,i.jsx)(n.code,{children:"a::float8 < 1.1"})]}),"\n",(0,i.jsxs)(n.li,{children:["Custom functions are not supported, such as ",(0,i.jsx)(n.code,{children:"func(a) < 10"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"IN"})," operator (",(0,i.jsx)(n.code,{children:"ScalarArrayOpExpr"}),")"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Supports ",(0,i.jsx)(n.code,{children:"IN"})," expressions"]}),"\n",(0,i.jsxs)(n.li,{children:["Example: ",(0,i.jsx)(n.code,{children:"a IN (1, 2, 3)"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"partial-condition-support",children:"Partial condition support"}),"\n",(0,i.jsx)(n.p,{children:"When a query contains unsupported expressions (such as custom functions), PAX adopts a partial condition support strategy:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Identifies and extracts supported conditions."}),"\n",(0,i.jsx)(n.li,{children:"Uses supported conditions for sparse filtering."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Creates custom function v2\nCREATE OR REPLACE FUNCTION func(v2 double precision)\nRETURNS double precision AS $$\nBEGIN\n  RETURN v2 * 2;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Uses custom function in query\nSELECT * FROM a WHERE v1 < 3 AND func(v2) < 10;  -- PAX will use v1 < 3 for filtering\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, although ",(0,i.jsx)(n.code,{children:"func(v2) < 10"})," cannot be used for sparse filtering, Apache Cloudberry still uses ",(0,i.jsx)(n.code,{children:"v1 < 3"})," to optimize query performance. This approach ensures that partial performance optimization is achieved even in complex queries."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The effectiveness of sparse filtering depends on data distribution and query conditions."}),"\n",(0,i.jsx)(n.li,{children:"It is recommended to enable statistics on columns that are frequently used as filter conditions."}),"\n",(0,i.jsx)(n.li,{children:"Certain conditions (such as custom functions) are ignored."}),"\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"view-data-change-records-on-pax-tables-in-wal-logs",children:"View data change records on PAX tables in WAL logs"}),"\n",(0,i.jsx)(n.p,{children:"Data operations related to PAX tables are recorded in the Write-Ahead Logging (WAL) system. This ensures reliable backups between primary and mirror nodes, which assists in failover processes."}),"\n",(0,i.jsxs)(n.p,{children:["You can use the ",(0,i.jsx)(n.code,{children:"pg_waldump"})," tool to view the WAL logs for PAX tables. The logs are stored in the ",(0,i.jsx)(n.code,{children:"$COORDINATOR_DATA_DIRECTORY/pg_wal"})," directory or the ",(0,i.jsx)(n.code,{children:"pg_wal"})," directory within the Segment node's data directory."]}),"\n",(0,i.jsx)(n.p,{children:"The PAX table WAL logs can be used for these purposes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data recovery"}),": Helps restore data during system failures or data inconsistencies."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Failover support"}),": Ensures data synchronization between primary and mirror nodes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Debugging and analysis"}),": Identifies and analyzes specific operations on PAX tables."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-operate-pax-tables-and-view-wal-logs",children:"Example: operate PAX tables and view WAL logs"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Create a PAX table."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE a (\n   v1 int,\n   v2 int,\n   v3 int\n) USING PAX;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This creates a PAX table ",(0,i.jsx)(n.code,{children:"a"})," with columns ",(0,i.jsx)(n.code,{children:"v1"}),", ",(0,i.jsx)(n.code,{children:"v2"}),", and ",(0,i.jsx)(n.code,{children:"v3"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Insert data into the table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"INSERT INTO a VALUES (1, 2, 3);\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Locate the node where the PAX table resides:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Views the IDs and data directory locations of all nodes in the cluster\nSELECT * FROM gp_segment_configuration;\n\n-- Identifies the Segment ID of table a based on the results of the above query\n-- This helps determine the segment and data directory location of table a\nSELECT gp_segment_id FROM gp_distribution_policy WHERE localoid = 'a'::regclass;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Find the corresponding WAL log in the ",(0,i.jsx)(n.code,{children:"pg_wal"})," directory of the identified node. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ls $COORDINATOR_DATA_DIRECTORY/pg_wal\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Locate the most recent WAL file to analyze the relevant operations. In this example, assume the WAL log file is named ",(0,i.jsx)(n.code,{children:"00000001000000000000000A"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Query the ",(0,i.jsx)(n.code,{children:"relfilenode"})," of the PAX table to associate the WAL log with the PAX table:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT relfilenode FROM pg_class WHERE relname = 'a';\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"relfilenode"})," is the unique identifier of the table in the WAL log."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"pg_waldump"})," tool to parse the WAL log and identify operations related to the PAX table:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pg_waldump -f $COORDINATOR_DATA_DIRECTORY/pg_wal/00000001000000000000000A\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the output, search for the previously obtained ",(0,i.jsx)(n.code,{children:"relfilenode"})," to find operations associated with the PAX table."]}),"\n",(0,i.jsxs)(n.p,{children:["Example output of ",(0,i.jsx)(n.code,{children:"pg_waldump"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"rmgr: PAX       len (rec/tot):     68/   104, tx:    593, lsn: 0/016E1D98, prev 0/016E1D60, desc: INSERT off 3, blkref #0: rel 1663/16384/19780 blk 0\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rmgr: PAX"})," indicates the record type."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rel 1663/16384/19780"})," corresponds to the ",(0,i.jsx)(n.code,{children:"relfilenode"})," of the PAX table."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"INSERT"})," indicates that an insert operation was recorded."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"By following the steps above, you can track and analyze WAL logs related to PAX tables in Apache Cloudberry for debugging, recovery, or performance optimization purposes."}),"\n",(0,i.jsx)(n.h2,{id:"limitations-for-pax-tables",children:"Limitations for PAX tables"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["For index support, the PAX storage format currently only supports B-tree (",(0,i.jsx)(n.code,{children:"btree"}),") indexes. Bugs might occur when using GiST, SP-GiST (",(0,i.jsx)(n.code,{children:"gist/spgist"}),") or Brin indexes. Supports for other index types are still experimental and might be unavailable."]}),"\n",(0,i.jsx)(n.li,{children:"Currently, if a field is too long, it will be stored in a TOAST file. This TOAST is different from PostgreSQL's TOAST tables, and they only share the same name."}),"\n",(0,i.jsxs)(n.li,{children:["Unlike traditional heap tables, PAX format does not support ",(0,i.jsx)(n.code,{children:"TOAST"})," fields. Currently, all column data is stored in the same data file."]}),"\n",(0,i.jsxs)(n.li,{children:["The PAX format does not support data backup and restore using ",(0,i.jsx)(n.code,{children:"pg_dump"})," or ",(0,i.jsx)(n.code,{children:"pg_restore"}),". PAX tables are ignored during these operations. You can use ",(0,i.jsx)(n.code,{children:"pg_basebackup"})," to backup and restore PAX tables."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"pax-related-sql-options",children:"PAX-related SQL options"}),"\n",(0,i.jsxs)(n.p,{children:["PAX supports SQL options to control its behavior. You can use these options in the ",(0,i.jsx)(n.code,{children:"WITH()"})," clause, for example, ",(0,i.jsx)(n.code,{children:"WITH(minmax_columns='b,c', storage_format=porc)"}),"."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Valid values"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"storage_format"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsxs)(n.td,{children:["\u2022  ",(0,i.jsx)(n.code,{children:"porc"}),(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"porc_vec"})]}),(0,i.jsxs)(n.td,{children:["Controls the internal storage format. ",(0,i.jsx)(n.code,{children:"porc"})," is the default value, which stores data in a regular format and does not preserve null values. ",(0,i.jsx)(n.code,{children:"porc_vec"})," stores data in a vector format and always preserves null values for fixed-length fields, regardless of whether the column value is null or not."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"compresstype"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsxs)(n.td,{children:["\u2022  ",(0,i.jsx)(n.code,{children:"none"}),(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"rle"}),(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"delta"}),(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"zstd"}),(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"zlib"}),(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"dict"})]}),(0,i.jsxs)(n.td,{children:["Specifies the compression method for column values. You can only choose one method. The default value is ",(0,i.jsx)(n.code,{children:"none"}),". ",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"none"})," means no compression is applied.",(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"rle"})," uses run-length encoding to compress repeated consecutive data.",(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"delta"})," is used for numeric columns, storing the difference between adjacent values.",(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"zstd"})," uses the zstd algorithm, which offers high compression ratio and fast compression speed.",(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"zlib"})," is a general-purpose compression algorithm, suitable for compressing general data.",(0,i.jsx)("br",{}),"\u2022  ",(0,i.jsx)(n.code,{children:"dict"})," uses dictionary encoding to speed up the processing of many repeated strings. Currently, it is an experimental feature and is not recommended for production use."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"compresslevel"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsxs)(n.td,{children:["Range ",(0,i.jsx)(n.code,{children:"[0, 19]"})]}),(0,i.jsxs)(n.td,{children:["Indicates the compression level. The default value is ",(0,i.jsx)(n.code,{children:"0"}),". A smaller value means faster compression, while a larger value provides higher compression. This option is only effective when used with ",(0,i.jsx)(n.code,{children:"compresstype"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"partition_by"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{children:"Valid column names in the table"}),(0,i.jsx)(n.td,{children:"When writing batch data, this option attempts to partition the data by the specified column and store it in the same data file, improving data locality. Only integer types are supported. This partition key is independent of table partitioning and serves as a suggestion for organizing data internally in PAX."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"partition_ranges"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"FROM(XX) TO(YY) [every(DD)]"})}),(0,i.jsxs)(n.td,{children:["This option must be used with ",(0,i.jsx)(n.code,{children:"partition_by"})," to set partition ranges. You can define a single range or divide a large range into multiple non-contiguous smaller ranges. It attempts to store data within each range in the same data file. Data outside the range will be stored in the default data file."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"minmax_columns"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{children:"Valid column names in the table, separated by commas"}),(0,i.jsxs)(n.td,{children:["Records ",(0,i.jsx)(n.code,{children:"minmax"})," statistics for the defined columns to speed up data queries. After renaming a column, the statistics will no longer be recorded for that column. If you modify ",(0,i.jsx)(n.code,{children:"minmax_columns"})," using ",(0,i.jsx)(n.code,{children:"ALTER TABLE"}),", the change only applies to data files written afterward and does not affect existing data files."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"cluster_columns"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{children:"A comma-separated list of valid column names in the table."}),(0,i.jsxs)(n.td,{children:["Indicates that the PAX table stores the internal data in a clustered way. When using the ",(0,i.jsx)(n.code,{children:"cluster"})," command, the data can be sorted by these columns, and the sorting method is controlled by the ",(0,i.jsx)(n.code,{children:"cluster_type"})," parameter."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bloomfilter_columns"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{children:"A comma-separated list of valid column names in the table."}),(0,i.jsx)(n.td,{children:"Calculates bloom filters for the data in the specified columns to help data filtering."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"parallel_workers"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[0,64]"})}),(0,i.jsx)(n.td,{children:"A PostgreSQL option that sets the number of parallel processes for concurrent scanning."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"cluster_type"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"lexical"})," and ",(0,i.jsx)(n.code,{children:"zorder"})]}),(0,i.jsxs)(n.td,{children:["Specifies the cluster type when clustering is based on custom columns defined in ",(0,i.jsx)(n.code,{children:"reloptions"})," rather than an index. Valid values are ",(0,i.jsx)(n.code,{children:"lexical"})," and ",(0,i.jsx)(n.code,{children:"zorder"}),". ",(0,i.jsx)(n.code,{children:"lexical"})," sorts by the values and order of the columns, while ",(0,i.jsx)(n.code,{children:"zorder"})," encodes the values of multiple columns into a byte array and sorts by that array."]})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"The values of these options only affect newly inserted and updated data and do not change the existing data."}),"\n",(0,i.jsx)(n.h2,{id:"pax-related-system-parameters",children:"PAX-related system parameters"}),"\n",(0,i.jsxs)(n.p,{children:["The following system parameters (GUC) are used to set the behavior of PAX tables in the current session. Use the command ",(0,i.jsx)(n.code,{children:"SET <parameter>=<value>"})," to configure them, for example, ",(0,i.jsx)(n.code,{children:"SET pax_enable_sparse_filter=on"}),"."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter name"}),(0,i.jsx)(n.th,{children:"Value type"}),(0,i.jsx)(n.th,{children:"Valid values"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pax_enable_sparse_filter"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"on"})," and ",(0,i.jsx)(n.code,{children:"off"})]}),(0,i.jsxs)(n.td,{children:["Specifies whether to enable sparse filtering based on statistics. The default value is ",(0,i.jsx)(n.code,{children:"on"}),", which means that sparse filtering is enabled by default."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pax_enable_row_filter"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"on"})," and ",(0,i.jsx)(n.code,{children:"off"})]}),(0,i.jsxs)(n.td,{children:["Specifies whether to enable row filtering. The default value is ",(0,i.jsx)(n.code,{children:"off"}),", which means that row filtering is disabled. It is not recommended to enable this parameter."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pax_scan_reuse_buffer_size"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsxs)(n.td,{children:["Range ",(0,i.jsx)(n.code,{children:"[1048576, 33554432]"})," (1MiB to 32MiB)"]}),(0,i.jsxs)(n.td,{children:["The buffer block size used during scanning. The default value is ",(0,i.jsx)(n.code,{children:"8388608"})," (8MiB)."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pax_max_tuples_per_group"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsxs)(n.td,{children:["Range ",(0,i.jsx)(n.code,{children:"[5, 524288]"})]}),(0,i.jsxs)(n.td,{children:["Specifies the maximum number of tuples allowed in each group. The default value is ",(0,i.jsx)(n.code,{children:"131072"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pax_max_tuples_per_file"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsxs)(n.td,{children:["Range ",(0,i.jsx)(n.code,{children:"[131072, 8388608]"})]}),(0,i.jsxs)(n.td,{children:["Specifies the maximum number of tuples allowed in each data file. The maximum value is ",(0,i.jsx)(n.code,{children:"8388608"}),". The default value is ",(0,i.jsx)(n.code,{children:"1310720"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pax_max_size_per_file"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsxs)(n.td,{children:["Range ",(0,i.jsx)(n.code,{children:"[8388608, 335544320]"})," (8MiB to 320MiB)"]}),(0,i.jsxs)(n.td,{children:["The maximum physical size allowed for each data file. The default value is ",(0,i.jsx)(n.code,{children:"67108864"})," (64MiB). The actual file size might be slightly larger than the set size. Very large or small values might negatively impact performance."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pax_enable_toast"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"on"})," and ",(0,i.jsx)(n.code,{children:"off"}),". The default value is ",(0,i.jsx)(n.code,{children:"on"}),"."]}),(0,i.jsx)(n.td,{children:"Specifies whether to enable TOAST support."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pax_min_size_of_compress_toast"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsxs)(n.td,{children:["Range ",(0,i.jsx)(n.code,{children:"[524288, 1073741824]"})," (512KiB to 1GiB). The default value is ",(0,i.jsx)(n.code,{children:"524288"})," (512KiB)."]}),(0,i.jsx)(n.td,{children:"Specifies the threshold for creating compressed TOAST tables. If the character length exceeds this threshold, Apache Cloudberry creates compressed TOAST tables for storage."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pax_min_size_of_external_toast"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsxs)(n.td,{children:["Range ",(0,i.jsx)(n.code,{children:"[10485760, 2147483647]"})," (10MiB to 2GiB). The default value is ",(0,i.jsx)(n.code,{children:"10485760"})," (10MiB)."]}),(0,i.jsx)(n.td,{children:"Specifies the threshold for creating external TOAST tables. If the character length exceeds this threshold, Apache Cloudberry creates external TOAST tables for storage."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pax_default_storage_format"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"porc"})," (the default value)"]}),(0,i.jsx)(n.td,{children:"Controls the default storage format."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pax_bloom_filter_work_memory_bytes"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsxs)(n.td,{children:["Range ",(0,i.jsx)(n.code,{children:"[1024, 2147483647]"})," (1KiB to 2GiB). The default value is ",(0,i.jsx)(n.code,{children:"10240"})," (10KiB)."]}),(0,i.jsx)(n.td,{children:"Controls the maximum memory allowed for bloom filter usage."})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Use partitioning options:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"It is recommended to use partitioning options when data needs to be imported based on an integer column and meets the following conditions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The data is evenly distributed across this column, with a wide range and no extreme concentration."}),"\n",(0,i.jsx)(n.li,{children:"This column is often used as a filter condition in queries or as a key for joins."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Keep in mind that the PAX partition key is only effective during a single batch data import. It cannot be adjusted between multiple data writes. The partition key settings only apply to future inserts or updates, so after changing the partition key, newly imported data will follow the new partition key."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"minmax"})," statistics:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["For columns with a wide data range that are often used in query filters, setting ",(0,i.jsx)(n.code,{children:"minmax"})," values for these columns can greatly speed up the query process."]}),"\n",(0,i.jsxs)(n.li,{children:["By using ",(0,i.jsx)(n.code,{children:"minmax"})," statistics, if a column in a data file does not match the ",(0,i.jsx)(n.code,{children:"minmax"})," values or null tests, the entire file can be skipped quickly, avoiding unnecessary data scans."]}),"\n",(0,i.jsxs)(n.li,{children:["Important note: The effectiveness of ",(0,i.jsx)(n.code,{children:"minmax"})," depends on how data is inserted. If the data in a PAX table is inserted in batches (such as with ",(0,i.jsx)(n.code,{children:"batch insert"})," or ",(0,i.jsx)(n.code,{children:"copy"}),") and the data range within each batch is continuous, then ",(0,i.jsx)(n.code,{children:"minmax"})," will be very effective. However, if the data is inserted randomly, the effectiveness of ",(0,i.jsx)(n.code,{children:"minmax"})," filtering may be reduced."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["If a PAX table has multiple columns used in query filters, you can use ",(0,i.jsx)(n.code,{children:"with(cluster_columns='b,c,d', cluster_type='zorder')"}),". After sorting the data with ",(0,i.jsx)(n.code,{children:"zorder"})," encoding, any of the ",(0,i.jsx)(n.code,{children:"cluster_columns"})," can benefit from filtering. In comparison, for single-column-based cluster sorting, filtering is only effective on the sorted key, with minimal impact on other columns. Clustering sorting influences ",(0,i.jsx)(n.code,{children:"minmax"}),"-based filtering but does not affect ",(0,i.jsx)(n.code,{children:"bloom filter"}),"-based filtering."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["If your query uses filters like ",(0,i.jsx)(n.code,{children:"column1 in (12, 11, 13)"})," or ",(0,i.jsx)(n.code,{children:"column1 = 'X'"}),", you might consider using a ",(0,i.jsx)(n.code,{children:"bloom filter (with(bloomfilter_columns='b,c'))"}),". In internal implementation, PAX calculates bloom filters for certain data. If the bloom filter can confirm that the data is not in the block, PAX can skip the current block. Note that the effectiveness of bloom filter depends on several factors:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The amount of data within a ",(0,i.jsx)(n.code,{children:"group"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The space used by the ",(0,i.jsx)(n.code,{children:"bloom filter"}),"."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>a,a:()=>l});var i=s(67294);const t={},r=i.createContext(t);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);