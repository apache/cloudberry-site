"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[74108],{56020:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var s=n(85893),t=n(11151);const i={title:"Understand Segment Recovery"},o="Understand Segment Recovery",c={id:"sys-admin/high-availability/understand-segment-recovery",title:"Understand Segment Recovery",description:"This topic provides background information about concepts and principles of segment recovery. If you have down segments and need immediate help recovering them, see the instructions in Recovering from Segment Failures. For information on how Apache Cloudberry detects that segments are down and an explanation of the Fault Tolerance Server (FTS) that manages down segment tracking, see How Apache Cloudberry Detects a Failed Segment.",source:"@site/docs/sys-admin/high-availability/understand-segment-recovery.md",sourceDirName:"sys-admin/high-availability",slug:"/sys-admin/high-availability/understand-segment-recovery",permalink:"/docs/next/sys-admin/high-availability/understand-segment-recovery",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sys-admin/high-availability/understand-segment-recovery.md",tags:[],version:"current",lastUpdatedBy:"Bhargav",lastUpdatedAt:1765766034,formattedLastUpdatedAt:"Dec 15, 2025",frontMatter:{title:"Understand Segment Recovery"},sidebar:"docsbars",previous:{title:"How a Failed Segment is Detected",permalink:"/docs/next/sys-admin/high-availability/detect-a-failed-segment"},next:{title:"Check for Failed Segments",permalink:"/docs/next/sys-admin/high-availability/check-for-failed-segments"}},d={},l=[{value:"Segment recovery basics",id:"segment-recovery-basics",level:2},{value:"Segment recovery: flow of events",id:"segment-recovery-flow-of-events",level:2},{value:"Rebalance after recovery",id:"rebalance-after-recovery",level:2},{value:"Simple failover and recovery example",id:"simple-failover-and-recovery-example",level:2},{value:"The three types of segment recovery",id:"the-three-types-of-segment-recovery",level:2}];function a(e){const r={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h1,{id:"understand-segment-recovery",children:"Understand Segment Recovery"}),"\n",(0,s.jsxs)(r.p,{children:["This topic provides background information about concepts and principles of segment recovery. If you have down segments and need immediate help recovering them, see the instructions in ",(0,s.jsx)(r.a,{href:"/docs/next/sys-admin/high-availability/recover-from-segment-failures",children:"Recovering from Segment Failures"}),". For information on how Apache Cloudberry detects that segments are down and an explanation of the Fault Tolerance Server (FTS) that manages down segment tracking, see ",(0,s.jsx)(r.a,{href:"/docs/next/sys-admin/high-availability/detect-a-failed-segment",children:"How Apache Cloudberry Detects a Failed Segment"}),"."]}),"\n",(0,s.jsx)(r.p,{children:"This topic is divided into the following sections:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#segment-recovery-basics",children:"Segment Recovery Basics"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#segment-recovery-flow-of-events",children:"Segment Recovery: Flow of Events"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#simple-failover-and-recovery-example",children:"Simple Failover and Recovery Example"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#the-three-types-of-segment-recovery",children:"The Three Types of Segment Recovery"})}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"segment-recovery-basics",children:"Segment recovery basics"}),"\n",(0,s.jsxs)(r.p,{children:["If the coordinator cannot connect to a segment instance, it marks that segment as down in the Apache Cloudberry ",(0,s.jsx)(r.code,{children:"gp_segment_configuration"})," table. The segment instance remains offline until an administrator takes steps to bring the segment back online. The process for recovering a down segment instance or host depends on the cause of the failure and on whether or not mirroring is enabled. A segment instance can be marked as down for a number of reasons:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"A segment host is unavailable; for example, due to network or hardware failures."}),"\n",(0,s.jsxs)(r.li,{children:["A segment instance is not running; for example, there is no ",(0,s.jsx)(r.code,{children:"postgres"})," database listener process."]}),"\n",(0,s.jsx)(r.li,{children:"The data directory of the segment instance is corrupt or missing; for example, data is not accessible, the file system is corrupt, or there is a disk failure."}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["In order to bring the down segment instance back into operation again, you must correct the problem that made it fail in the first place, and then \u2013 if you have mirroring enabled \u2013 you can attempt to recover the segment instance from its mirror using the ",(0,s.jsx)(r.code,{children:"gprecoverseg"})," utility. See ",(0,s.jsx)(r.a,{href:"#the-three-types-of-segment-recovery",children:"The Three Types of Segment Recovery"}),", below, for details on the three possible ways to recover a downed segment's data."]}),"\n",(0,s.jsx)(r.h2,{id:"segment-recovery-flow-of-events",children:"Segment recovery: flow of events"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"When a Primary Segment Goes Down"})}),"\n",(0,s.jsxs)(r.p,{children:["The following summarizes the flow of events that follow a ",(0,s.jsx)(r.strong,{children:"primary"})," segment going down:"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"A primary segment goes down."}),"\n",(0,s.jsxs)(r.li,{children:["The Fault Tolerance Server (FTS) detects this and marks the segment as down in the ",(0,s.jsx)(r.code,{children:"gp_segment_configuration"})," table."]}),"\n",(0,s.jsx)(r.li,{children:"The mirror segment is promoted to primary and starts functioning as primary. The previous primary is demoted to mirror."}),"\n",(0,s.jsx)(r.li,{children:"The user fixes the underlying problem."}),"\n",(0,s.jsxs)(r.li,{children:["The user runs ",(0,s.jsx)(r.code,{children:"gprecoverseg"})," to bring back the (formerly primary) mirror segment."]}),"\n",(0,s.jsxs)(r.li,{children:["The WAL synchronization process ensures that the mirror segment data is synchronized with the primary segment data. Users can check the state of this synching with ",(0,s.jsx)(r.code,{children:"gpstate -e"}),"."]}),"\n",(0,s.jsxs)(r.li,{children:["Apache Cloudberry marks the segments as up (",(0,s.jsx)(r.code,{children:"u"}),") in the ",(0,s.jsx)(r.code,{children:"gp_segment_configuration"})," table."]}),"\n",(0,s.jsxs)(r.li,{children:["If segments are not in their preferred roles, user runs ",(0,s.jsx)(r.code,{children:"gprecoverseg -r"})," to restore them to their preferred roles."]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"When a Mirror Segment Goes Down"})}),"\n",(0,s.jsxs)(r.p,{children:["The following summarizes the flow of events that follow a ",(0,s.jsx)(r.strong,{children:"mirror"})," segment going down:"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"A mirror segment goes down."}),"\n",(0,s.jsxs)(r.li,{children:["The Fault Tolerance Server (FTS) detects this and marks the segment as down in the ",(0,s.jsx)(r.code,{children:"gp_segment_configuration"})," table."]}),"\n",(0,s.jsx)(r.li,{children:"The user fixes the underlying problem."}),"\n",(0,s.jsxs)(r.li,{children:["The user runs ",(0,s.jsx)(r.code,{children:"gprecoverseg"})," to bring back the (formerly mirror) mirror segment."]}),"\n",(0,s.jsxs)(r.li,{children:["The synching process occurs: the mirror comes into sync with its primary via WAL synching. You can check the state of this synching with ",(0,s.jsx)(r.code,{children:"gpstate -e"}),"."]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"rebalance-after-recovery",children:"Rebalance after recovery"}),"\n",(0,s.jsxs)(r.p,{children:["After a segment instance has been recovered, the segments may not be in their preferred roles, which can cause processing to be skewed. The ",(0,s.jsx)(r.code,{children:"gp_segment_configuration"})," table has the columns ",(0,s.jsx)(r.code,{children:"role"})," (current role) and ",(0,s.jsx)(r.code,{children:"preferred_role"})," (original role at the beginning). When a segment's ",(0,s.jsx)(r.code,{children:"role"})," and ",(0,s.jsx)(r.code,{children:"preferred_role"})," do not match the system may not be balanced. To rebalance the cluster and bring all the segments into their preferred roles, run the ",(0,s.jsx)(r.code,{children:"gprecoverseg -r"}),"command."]}),"\n",(0,s.jsx)(r.h2,{id:"simple-failover-and-recovery-example",children:"Simple failover and recovery example"}),"\n",(0,s.jsxs)(r.p,{children:["Consider a single primary-mirror segment instance pair where the primary segment has failed over to the mirror. The following table shows the segment instance preferred role, role, mode, and status from the ",(0,s.jsx)(r.code,{children:"gp_segment_configuration"})," table before beginning recovery of the failed primary segment."]}),"\n",(0,s.jsxs)(r.p,{children:["You can also run ",(0,s.jsx)(r.code,{children:"gpstate -e"})," to display any issues with a primary or mirror segment instances."]}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Segment Type\xa0"}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"preferred_role"})}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"role"})}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"mode"})}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"status"})})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Primary"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"p"}),"(primary)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"m"}),"(mirror)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"n"}),"(Not In Sync)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"d"}),"(down)"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Mirror"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"m"}),"(mirror)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"p"}),"(primary)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"n"}),"(Not In Sync)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"u"}),"(up)"]})]})]})]}),"\n",(0,s.jsxs)(r.p,{children:["The primary segment is down and segment instances are not in their preferred roles. The mirror segment is up and its role is now primary. However, it is not synchronized with its mirror (the former primary segment) because that segment is down. You must potentially fix either issues with the host the down segment is running on, issues with the segment instance itself, or both. You then use ",(0,s.jsx)(r.code,{children:"gprecoverseg"})," to prepare failed segment instances for recovery and initiate synchronization between the primary and mirror instances."]}),"\n",(0,s.jsxs)(r.p,{children:["After ",(0,s.jsx)(r.code,{children:"gprecoverseg"})," has completed, the segments are in the states shown in the following table where the primary-mirror segment pair is up with the primary and mirror roles reversed from their preferred roles."]}),"\n",(0,s.jsx)(r.admonition,{type:"note",children:(0,s.jsxs)(r.p,{children:["There might be a lag between when ",(0,s.jsx)(r.code,{children:"gprecoverseg"})," completes and when the segment status is set to ",(0,s.jsx)(r.code,{children:"u"})," (up)."]})}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Segment Type\xa0"}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"preferred_role"})}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"role"})}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"mode"})}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"status"})})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Primary"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"p"}),"(primary)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"m"}),"(mirror)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"s"}),"(Synchronized)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"u"}),"(up)"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Mirror"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"m"}),"(mirror)",(0,s.jsx)(r.code,{children:"p"}),"(primary)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"s"}),"(Synchronized)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"u"}),"(up)"]}),(0,s.jsx)(r.td,{})]})]})]}),"\n",(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.code,{children:"gprecoverseg -r"})," command rebalances the system by returning the segment roles to their preferred roles."]}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"\xa0Segment Type"}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"preferred_role"})}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"role"})}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"mode"})}),(0,s.jsx)(r.th,{children:(0,s.jsx)(r.code,{children:"status"})})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Primary"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"p"}),"(primary)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"p"}),"(primary)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"s"}),"(Synchronized)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"u"}),"(up)"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Mirror"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"m"}),"(mirror)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"m"}),"(mirror)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"s"}),"(Synchronized)"]}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"u"}),"(up)"]})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"the-three-types-of-segment-recovery",children:"The three types of segment recovery"}),"\n",(0,s.jsx)(r.p,{children:"Apache Cloudberry can perform three types of segment recovery: full, differential, and incremental (the default)."}),"\n",(0,s.jsxs)(r.p,{children:["Full recovery\n:  Full recovery recovers all segments. Specifically, it erases all data files and directories on the current mirror segment and copies to the mirror segment the exact contents of the current primary segment. Full recovery uses the ",(0,s.jsx)(r.code,{children:"pg_basebackup"})," utility to copy files."]}),"\n",(0,s.jsx)(r.p,{children:"With full recovery, you may recover:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:'to the current host -- known as "in-place recovery"'}),"\n",(0,s.jsx)(r.li,{children:"to a different host within the current cluster"}),"\n",(0,s.jsx)(r.li,{children:"to a new host outside of the current cluster"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["Differential recovery\n:   Differential recovery performs a filesystem-level diff between the primary and mirror segments, and copies from the primary to the mirror only those files that have changed on the primary. With differential recovery, you may only do in-place recovery. Differential recovery uses the ",(0,s.jsx)(r.code,{children:"rsync"})," command to copy files."]}),"\n",(0,s.jsxs)(r.p,{children:["Incremental recovery (default)\n:   Incremental recovery brings the mirror segment contents into sync with the primary segment contents with the aid of write-ahead log files (WAL files). With incremental recovery, you may only do in-place recovery. Incremental recovery uses the ",(0,s.jsx)(r.code,{children:"pg_rewind"})," utility to copy files."]}),"\n",(0,s.jsxs)(r.p,{children:["By default, ",(0,s.jsx)(r.code,{children:"gprecoverseg"})," performs an incremental recovery, placing the mirror into ",(0,s.jsx)(r.em,{children:"Synchronizing"})," mode, which starts to replay the recorded changes from the primary onto the mirror. If the incremental recovery cannot be completed, the recovery fails and you should run ",(0,s.jsx)(r.code,{children:"gprecoverseg"})," again with the ",(0,s.jsx)(r.code,{children:"-F"})," option, to perform full recovery. This causes the primary to copy all of its data to the mirror."]}),"\n",(0,s.jsxs)(r.admonition,{type:"note",children:[(0,s.jsx)(r.p,{children:"After a failed incremental recovery attempt you must perform a full recovery.\n:::"}),(0,s.jsxs)(r.p,{children:["Whenever possible, you should perform an incremental recovery rather than a full recovery, as incremental recovery is substantially faster. If you ",(0,s.jsx)(r.strong,{children:"do"})," need to perform an in-place full recovery, you can speed up in-place full recovery with ",(0,s.jsx)(r.code,{children:"gprecoverseg"}),"'s ",(0,s.jsx)(r.code,{children:"--differential"})," option, which causes ",(0,s.jsx)(r.code,{children:"gprecoverseg"})," to skip recovery of any files and directories that are unchanged."]})]})]})}function h(e={}){const{wrapper:r}={...(0,t.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},11151:(e,r,n)=>{n.d(r,{Z:()=>c,a:()=>o});var s=n(67294);const t={},i=s.createContext(t);function o(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);