"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[37563],{12323:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var t=r(85893),n=r(11151);const o={title:"Resource Queues"},i="Resource Queues",a={id:"performance/manage-resources-using-resource-queues",title:"Resource Queues",description:"Use Apache Cloudberry resource queues to prioritize and allocate resources to queries according to business requirements and to prevent queries from starting when resources are unavailable.",source:"@site/docs/performance/manage-resources-using-resource-queues.md",sourceDirName:"performance",slug:"/performance/manage-resources-using-resource-queues",permalink:"/docs/next/performance/manage-resources-using-resource-queues",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/performance/manage-resources-using-resource-queues.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1758251752,formattedLastUpdatedAt:"Sep 19, 2025",frontMatter:{title:"Resource Queues"},sidebar:"docsbars",previous:{title:"Manage Resources",permalink:"/docs/next/performance/manage-resources"},next:{title:"Resource Groups",permalink:"/docs/next/performance/manage-resources-using-resource-groups"}},u={},c=[{value:"Resource queue example",id:"resource-queue-example",level:2},{value:"How memory limits work",id:"how-memory-limits-work",level:2},{value:"<code>statement_mem</code> and low memory queries",id:"statement_mem-and-low-memory-queries",level:3},{value:"How priorities work",id:"how-priorities-work",level:2},{value:"Enable resource queues",id:"enable-resource-queues",level:2},{value:"Configure resource queues",id:"configure-resource-queues",level:2},{value:"Create resource queues",id:"create-resource-queues",level:2},{value:"Create queues with an active query limit",id:"create-queues-with-an-active-query-limit",level:3},{value:"Create queues with memory limits",id:"create-queues-with-memory-limits",level:3},{value:"Set priority levels",id:"set-priority-levels",level:3},{value:"Assign roles to a resource queue",id:"assign-roles-to-a-resource-queue",level:2},{value:"Remove a role from a resource queue",id:"remove-a-role-from-a-resource-queue",level:3},{value:"Modify resource queues",id:"modify-resource-queues",level:2},{value:"Alter a resource queue",id:"alter-a-resource-queue",level:3},{value:"Drop a resource queue",id:"drop-a-resource-queue",level:3},{value:"Monitor resource queue status",id:"monitor-resource-queue-status",level:2},{value:"View queued statements and resource queue status",id:"view-queued-statements-and-resource-queue-status",level:3},{value:"View resource queue statistics",id:"view-resource-queue-statistics",level:3},{value:"View the roles assigned to a resource queue",id:"view-the-roles-assigned-to-a-resource-queue",level:3},{value:"View the waiting queries for a resource queue",id:"view-the-waiting-queries-for-a-resource-queue",level:3},{value:"Clear a waiting statement from a resource queue",id:"clear-a-waiting-statement-from-a-resource-queue",level:3},{value:"View the priority of active statements",id:"view-the-priority-of-active-statements",level:3},{value:"Reset the priority of an active statement",id:"reset-the-priority-of-an-active-statement",level:3}];function l(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"resource-queues",children:"Resource Queues"}),"\n",(0,t.jsx)(s.p,{children:"Use Apache Cloudberry resource queues to prioritize and allocate resources to queries according to business requirements and to prevent queries from starting when resources are unavailable."}),"\n",(0,t.jsxs)(s.p,{children:["Resource queues are one tool to manage the degree of concurrency in a Apache Cloudberry system. Resource queues are database objects that you create with the ",(0,t.jsx)(s.code,{children:"CREATE RESOURCE QUEUE"})," SQL statement. You can use them to manage the number of active queries that may run concurrently, the amount of memory each type of query is allocated, and the relative priority of queries. Resource queues can also guard against queries that would consume too many resources and degrade overall system performance."]}),"\n",(0,t.jsxs)(s.p,{children:["Each database role is associated with a single resource queue; multiple roles can share the same resource queue. Roles are assigned to resource queues using the ",(0,t.jsx)(s.code,{children:"RESOURCE QUEUE"})," phrase of the ",(0,t.jsx)(s.code,{children:"CREATE ROLE"})," or ",(0,t.jsx)(s.code,{children:"ALTER ROLE"})," statements. If a resource queue is not specified, the role is associated with the default resource queue, ",(0,t.jsx)(s.code,{children:"pg_default"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["When the user submits a query for execution, the query is evaluated against the resource queue's limits. If the query does not cause the queue to exceed its resource limits, then that query will run immediately. If the query causes the queue to exceed its limits (for example, if the maximum number of active statement slots are currently in use), then the query must wait until queue resources are free before it can run. Queries are evaluated on a first in, first out basis. If query prioritization is enabled, the active workload on the system is periodically assessed and processing resources are reallocated according to query priority (see ",(0,t.jsx)(s.a,{href:"#how-priorities-work",children:"How Priorities Work"}),"). Roles with the ",(0,t.jsx)(s.code,{children:"SUPERUSER"})," attribute are exempt from resource queue limits. Superuser queries always run immediately regardless of limits imposed by their assigned resource queue."]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Resource Queue Process",src:r(91644).Z+"",width:"584",height:"228"})}),"\n",(0,t.jsx)(s.p,{children:"Resource queues define classes of queries with similar resource requirements. Administrators should create resource queues for the various types of workloads in their organization. For example, you could create resource queues for the following classes of queries, corresponding to different service level agreements:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"ETL queries"}),"\n",(0,t.jsx)(s.li,{children:"Reporting queries"}),"\n",(0,t.jsx)(s.li,{children:"Executive queries"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"A resource queue has the following characteristics:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})}),": The amount of memory used by all the queries in the queue (per segment). For example, setting ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," to 2GB on the ETL queue allows ETL queries to use up to 2GB of memory in each segment."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"})}),": The number of ",(0,t.jsx)(s.em,{children:"slots"})," for a queue; the maximum concurrency level for a queue. When all slots are used, new queries must wait. Each query uses an equal amount of memory by default."]}),"\n",(0,t.jsxs)(s.p,{children:["For example, the ",(0,t.jsx)(s.code,{children:"pg_default"})," resource queue has ",(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"})," = 20."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"PRIORITY"})}),": The relative CPU usage for queries. This may be one of the following levels: ",(0,t.jsx)(s.code,{children:"LOW"}),", ",(0,t.jsx)(s.code,{children:"MEDIUM"}),", ",(0,t.jsx)(s.code,{children:"HIGH"}),", ",(0,t.jsx)(s.code,{children:"MAX"}),". The default level is ",(0,t.jsx)(s.code,{children:"MEDIUM"}),". The query prioritization mechanism monitors the CPU usage of all the queries running in the system, and adjusts the CPU usage for each to conform to its priority level. For example, you could set ",(0,t.jsx)(s.code,{children:"MAX"})," priority to the ",(0,t.jsx)(s.code,{children:"executive"})," resource queue and ",(0,t.jsx)(s.code,{children:"MEDIUM"})," to other queues to ensure that executive queries receive a greater share of CPU."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"MAX_COST"})}),": Query plan cost limit. The Apache Cloudberry optimizer assigns a numeric cost to each query. If the cost exceeds the ",(0,t.jsx)(s.code,{children:"MAX_COST"})," value set for the resource queue, the query is rejected as too expensive."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsx)(s.p,{children:"GPORCA and the Postgres-based planner utilize different query costing models and may compute different costs for the same query. The Apache Cloudberry resource queue resource management scheme neither differentiates nor aligns costs between GPORCA and the Postgres-based planner; it uses the literal cost value returned from the optimizer to throttle queries."})}),"\n",(0,t.jsxs)(s.p,{children:["When resource queue-based resource management is active, use the ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," and ",(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"})," limits for resource queues rather than configuring cost-based limits. Even when using GPORCA, Apache Cloudberry may fall back to using the Postgres-based planner for certain queries, so using cost-based limits can lead to unexpected results."]}),"\n",(0,t.jsxs)(s.p,{children:["The default configuration for a Apache Cloudberry system has a single default resource queue named ",(0,t.jsx)(s.code,{children:"pg_default"}),". The ",(0,t.jsx)(s.code,{children:"pg_default"})," resource queue has an ",(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"})," setting of 20, no ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"}),", medium ",(0,t.jsx)(s.code,{children:"PRIORITY"}),", and no set ",(0,t.jsx)(s.code,{children:"MAX_COST"}),". This means that all queries are accepted and run immediately, at the same priority and with no memory limitations; however, only twenty queries may run concurrently."]}),"\n",(0,t.jsxs)(s.p,{children:["The number of concurrent queries a resource queue allows depends on whether the ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," parameter is set:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["If no ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," is set for a resource queue, the amount of memory allocated per query is the value of the ",(0,t.jsx)(s.code,{children:"statement_mem"})," server configuration parameter. The maximum memory the resource queue can use is the product of ",(0,t.jsx)(s.code,{children:"statement_mem"})," and ",(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["When a ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," is set on a resource queue, the number of queries that the queue can run concurrently is limited by the queue's available memory."]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:'A query admitted to the system is allocated an amount of memory and a query plan tree is generated for it. Each node of the tree is an operator, such as a sort or hash join. Each operator is a separate execution thread and is allocated a fraction of the overall statement memory, at minimum 100KB. If the plan has a large number of operators, the minimum memory required for operators can exceed the available memory and the query will be rejected with an insufficient memory error. Operators determine if they can complete their tasks in the memory allocated, or if they must spill data to disk, in work files. The mechanism that allocates and controls the amount of memory used by each operator is called "memory quota".'}),"\n",(0,t.jsxs)(s.p,{children:["Not all SQL statements submitted through a resource queue are evaluated against the queue limits. By default only ",(0,t.jsx)(s.code,{children:"SELECT"}),", ",(0,t.jsx)(s.code,{children:"SELECT INTO"}),", ",(0,t.jsx)(s.code,{children:"CREATE TABLE AS SELECT"}),", and ",(0,t.jsx)(s.code,{children:"DECLARE CURSOR"})," statements are evaluated. If the server configuration parameter ",(0,t.jsx)(s.code,{children:"resource_select_only"})," is set to ",(0,t.jsx)(s.code,{children:"off"}),", then ",(0,t.jsx)(s.code,{children:"INSERT"}),", ",(0,t.jsx)(s.code,{children:"UPDATE"}),", and ",(0,t.jsx)(s.code,{children:"DELETE"})," statements will be evaluated as well."]}),"\n",(0,t.jsxs)(s.p,{children:["Also, an SQL statement that is run during the execution of an ",(0,t.jsx)(s.code,{children:"EXPLAIN ANALYZE"})," command is excluded from resource queues."]}),"\n",(0,t.jsx)(s.h2,{id:"resource-queue-example",children:"Resource queue example"}),"\n",(0,t.jsxs)(s.p,{children:["The default resource queue, ",(0,t.jsx)(s.code,{children:"pg_default"}),", allows a maximum of 20 active queries and allocates the same amount of memory to each. This is generally not adequate resource control for production systems. To ensure that the system meets performance expectations, you can define classes of queries and assign them to resource queues configured to run them with the concurrency, memory, and CPU resources best suited for that class of query."]}),"\n",(0,t.jsxs)(s.p,{children:["The following illustration shows an example resource queue configuration for a Apache Cloudberry system with ",(0,t.jsx)(s.code,{children:"gp_vmem_protect_limit"})," set to 8GB:"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Resource Queue Configuration Example",src:r(22929).Z+"",width:"613",height:"153"})}),"\n",(0,t.jsx)(s.p,{children:"This example has three classes of queries with different characteristics and service level agreements (SLAs). Three resource queues are configured for them. A portion of the segment memory is reserved as a safety margin."}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Resource queue Name"}),(0,t.jsx)(s.th,{children:"Active statements"}),(0,t.jsx)(s.th,{children:"Memory limit"}),(0,t.jsx)(s.th,{children:"Memory per query"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"ETL"}),(0,t.jsx)(s.td,{children:"3"}),(0,t.jsx)(s.td,{children:"2GB"}),(0,t.jsx)(s.td,{children:"667MB"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Reporting"}),(0,t.jsx)(s.td,{children:"7"}),(0,t.jsx)(s.td,{children:"3GB"}),(0,t.jsx)(s.td,{children:"429MB"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Executive"}),(0,t.jsx)(s.td,{children:"1"}),(0,t.jsx)(s.td,{children:"1.4GB"}),(0,t.jsx)(s.td,{children:"1.4GB"})]})]})]}),"\n",(0,t.jsxs)(s.p,{children:["The total memory allocated to the queues is 6.4GB, or 80% of the total segment memory defined by the ",(0,t.jsx)(s.code,{children:"gp_vmem_protect_limit"})," server configuration parameter. Allowing a safety margin of 20% accommodates some operators and queries that are known to use more memory than they are allocated by the resource queue."]}),"\n",(0,t.jsxs)(s.p,{children:["See the ",(0,t.jsx)(s.a,{href:"/docs/next/sql-stmts/create-resource-queue",children:(0,t.jsx)(s.code,{children:"CREATE RESOURCE QUEUE"})}),", ",(0,t.jsx)(s.a,{href:"/docs/next/sql-stmts/create-role",children:(0,t.jsx)(s.code,{children:"CREATE ROLE"})}),", and ",(0,t.jsx)(s.a,{href:"/docs/next/sql-stmts/alter-role",children:(0,t.jsx)(s.code,{children:"ALTER ROLE"})})," statements for help with command syntax and detailed reference information."]}),"\n",(0,t.jsx)(s.h2,{id:"how-memory-limits-work",children:"How memory limits work"}),"\n",(0,t.jsxs)(s.p,{children:["Setting ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," on a resource queue sets the maximum amount of memory that all active queries submitted through the queue can consume for a segment instance. The amount of memory allotted to a query is the queue memory limit divided by the active statement limit. (Use the memory limits in conjunction with statement-based queues rather than cost-based queues.) For example, if a queue has a memory limit of 2000MB and an active statement limit of 10, each query submitted through the queue is allotted 200MB of memory by default. The default memory allotment can be overridden on a per-query basis using the ",(0,t.jsx)(s.code,{children:"statement_mem"})," server configuration parameter (up to the queue memory limit). Once a query has started running, it holds its allotted memory in the queue until it completes, even if during execution it actually consumes less than its allotted amount of memory."]}),"\n",(0,t.jsxs)(s.p,{children:["You can use the ",(0,t.jsx)(s.code,{children:"statement_mem"})," server configuration parameter to override memory limits set by the current resource queue. At the session level, you can increase ",(0,t.jsx)(s.code,{children:"statement_mem"})," up to the resource queue's ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"}),". This will allow an individual query to use all of the memory allocated for the entire queue without affecting other resource queues."]}),"\n",(0,t.jsxs)(s.p,{children:["The value of ",(0,t.jsx)(s.code,{children:"statement_mem"})," is capped using the ",(0,t.jsx)(s.code,{children:"max_statement_mem"})," configuration parameter (a superuser parameter). For a query in a resource queue with ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," set, the maximum value for ",(0,t.jsx)(s.code,{children:"statement_mem"})," is ",(0,t.jsx)(s.code,{children:"min(MEMORY_LIMIT, max_statement_mem)"}),". When a query is admitted, the memory allocated to it is subtracted from ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"}),". If ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," is exhausted, new queries in the same resource queue must wait. This happens even if ",(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"})," has not yet been reached. Note that this can happen only when ",(0,t.jsx)(s.code,{children:"statement_mem"})," is used to override the memory allocated by the resource queue."]}),"\n",(0,t.jsxs)(s.p,{children:["For example, consider a resource queue named ",(0,t.jsx)(s.code,{children:"adhoc"})," with the following settings:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," is 1.5GB"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"})," is 3"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"By default each statement submitted to the queue is allocated 500MB of memory. Now consider the following series of events:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["User ",(0,t.jsx)(s.code,{children:"ADHOC_1"})," submits query ",(0,t.jsx)(s.code,{children:"Q1"}),", overriding ",(0,t.jsx)(s.code,{children:"STATEMENT_MEM"})," to 800MB. The ",(0,t.jsx)(s.code,{children:"Q1"})," statement is admitted into the system."]}),"\n",(0,t.jsxs)(s.li,{children:["User ",(0,t.jsx)(s.code,{children:"ADHOC_2"})," submits query ",(0,t.jsx)(s.code,{children:"Q2"}),", using the default 500MB."]}),"\n",(0,t.jsxs)(s.li,{children:["With ",(0,t.jsx)(s.code,{children:"Q1"})," and ",(0,t.jsx)(s.code,{children:"Q2"})," still running, user ",(0,t.jsx)(s.code,{children:"ADHOC3"})," submits query ",(0,t.jsx)(s.code,{children:"Q3"}),", using the default 500MB."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Queries ",(0,t.jsx)(s.code,{children:"Q1"})," and ",(0,t.jsx)(s.code,{children:"Q2"})," have used 1300MB of the queue's 1500MB. Therefore, ",(0,t.jsx)(s.code,{children:"Q3"})," must wait for ",(0,t.jsx)(s.code,{children:"Q1"})," or ",(0,t.jsx)(s.code,{children:"Q2"})," to complete before it can run."]}),"\n",(0,t.jsxs)(s.p,{children:["If ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," is not set on a queue, queries are admitted until all of the ",(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"})," slots are in use, and each query can set an arbitrarily high ",(0,t.jsx)(s.code,{children:"statement_mem"}),". This could lead to a resource queue using unbounded amounts of memory."]}),"\n",(0,t.jsxs)(s.p,{children:["For more information on configuring memory limits on a resource queue, and other memory utilization controls, see ",(0,t.jsx)(s.a,{href:"#create-queues-with-memory-limits",children:"Create Queues with Memory Limits"}),"."]}),"\n",(0,t.jsxs)(s.h3,{id:"statement_mem-and-low-memory-queries",children:[(0,t.jsx)(s.code,{children:"statement_mem"})," and low memory queries"]}),"\n",(0,t.jsxs)(s.p,{children:["A low ",(0,t.jsx)(s.code,{children:"statement_mem"})," setting (for example, in the 1-3MB range) has been shown to increase the performance of queries with low memory requirements. Use the ",(0,t.jsx)(s.code,{children:"statement_mem"})," server configuration parameter to override the setting on a per-query basis. For example:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SET statement_mem='2MB';\n"})}),"\n",(0,t.jsx)(s.h2,{id:"how-priorities-work",children:"How priorities work"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"PRIORITY"})," setting for a resource queue differs from the ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," and ",(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"})," settings, which determine whether a query will be admitted to the queue and eventually run. The ",(0,t.jsx)(s.code,{children:"PRIORITY"})," setting applies to queries after they become active. Active queries share available CPU resources as determined by the priority settings for its resource queue. When a statement from a high-priority queue enters the group of actively running statements, it may claim a greater share of the available CPU, reducing the share allocated to already-running statements in queues with a lesser priority setting."]}),"\n",(0,t.jsx)(s.p,{children:"The comparative size or complexity of the queries does not affect the allotment of CPU. If a simple, low-cost query is running simultaneously with a large, complex query, and their priority settings are the same, they will be allocated the same share of available CPU resources. When a new query becomes active, the CPU shares will be recalculated, but queries of equal priority will still have equal amounts of CPU."}),"\n",(0,t.jsxs)(s.p,{children:["For example, an administrator creates three resource queues: ",(0,t.jsx)(s.code,{children:"adhoc"})," for ongoing queries submitted by business analysts, ",(0,t.jsx)(s.code,{children:"reporting"})," for scheduled reporting jobs, and ",(0,t.jsx)(s.code,{children:"executive"})," for queries submitted by executive user roles. The administrator wants to ensure that scheduled reporting jobs are not heavily affected by unpredictable resource demands from ad-hoc analyst queries. Also, the administrator wants to make sure that queries submitted by executive roles are allotted a significant share of CPU. Accordingly, the resource queue priorities are set as shown:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"adhoc"})," \u2014 Low priority"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"reporting"})," \u2014 High priority"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"executive"})," \u2014 Maximum priority"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"At runtime, the CPU share of active statements is determined by these priority settings. If queries 1 and 2 from the reporting queue are running simultaneously, they have equal shares of CPU. When an ad-hoc query becomes active, it claims a smaller share of CPU. The exact share used by the reporting queries is adjusted, but remains equal due to their equal priority setting:"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"CPU share readjusted according to priority",src:r(11100).Z+"",width:"830",height:"573"})}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsx)(s.p,{children:"The percentages shown in these illustrations are approximate. CPU usage between high, low and maximum priority queues is not always calculated in precisely these proportions."})}),"\n",(0,t.jsx)(s.p,{children:"When an executive query enters the group of running statements, CPU usage is adjusted to account for its maximum priority setting. It may be a simple query compared to the analyst and reporting queries, but until it is completed, it will claim the largest share of CPU."}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"CPU share readjusted for maximum priority query",src:r(23882).Z+"",width:"304",height:"477"})}),"\n",(0,t.jsxs)(s.p,{children:["For more information about commands to set priorities, see ",(0,t.jsx)(s.a,{href:"#set-priority-levels",children:"Set Priority Levels"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"enable-resource-queues",children:"Enable resource queues"}),"\n",(0,t.jsxs)(s.p,{children:["When you install Apache Cloudberry, no resource management policy is enabled by default. To use resource queues, set the ",(0,t.jsx)(s.code,{children:"gp_resource_manager"})," server configuration parameter:"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Set the ",(0,t.jsx)(s.code,{children:"gp_resource_manager"})," server configuration parameter to the value ",(0,t.jsx)(s.code,{children:'"queue"'}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:'gpconfig -c gp_resource_manager -v "queue"\n'})}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Restart Apache Cloudberry:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"gpstop\ngpstart \n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"configure-resource-queues",children:"Configure resource queues"}),"\n",(0,t.jsx)(s.p,{children:"Before you create any resource groups, learn about the different resouce queue server configuration parameters and their usage."}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"General configuration."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"max_resource_queues"})," - Sets the maximum number of resource queues."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"max_resource_portals_per_transaction"})," - Sets the maximum number of simultaneously open cursors allowed per transaction. Note that an open cursor will hold an active query slot in a resource queue."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"resource_select_only"})," - If set to ",(0,t.jsx)(s.code,{children:"on"}),", then ",(0,t.jsx)(s.code,{children:"SELECT"}),", ",(0,t.jsx)(s.code,{children:"SELECT INTO"}),", ",(0,t.jsx)(s.code,{children:"CREATE TABLE AS``SELECT"}),", and ",(0,t.jsx)(s.code,{children:"DECLARE CURSOR"})," commands are evaluated. If set to ",(0,t.jsx)(s.code,{children:"off"}),", ",(0,t.jsx)(s.code,{children:"INSERT"}),", ",(0,t.jsx)(s.code,{children:"UPDATE"}),", and ",(0,t.jsx)(s.code,{children:"DELETE"})," commands will be evaluated as well."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"resource_cleanup_gangs_on_wait"})," - Cleans up idle segment worker processes before taking a slot in the resource queue."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"stats_queue_level"})," - Enables statistics collection on resource queue usage, which can then be viewed by querying the pg_stat_resqueues system view."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Memory utilization."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"gp_resqueue_memory_policy"})," - Enables Apache Cloudberry memory management features."]}),"\n",(0,t.jsxs)(s.p,{children:["In Apache Cloudberry, the distribution algorithm ",(0,t.jsx)(s.code,{children:"eager_free"})," takes advantage of the fact that not all operators run at the same time. The query plan is divided into stages and Apache Cloudberry eagerly frees memory allocated to a previous stage at the end of that stage's execution, then allocates the eagerly freed memory to the new stage."]}),"\n",(0,t.jsxs)(s.p,{children:["When set to ",(0,t.jsx)(s.code,{children:"auto"}),", query memory usage is controlled by ",(0,t.jsx)(s.code,{children:"statement_mem"})," and resource queue memory limits."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"statement_mem"})," and ",(0,t.jsx)(s.code,{children:"max_statement_mem"})," - Used to allocate memory to a particular query at runtime (override the default allocation assigned by the resource queue). ",(0,t.jsx)(s.code,{children:"max_statement_mem"})," is set by database superusers to prevent regular database users from over-allocation."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"gp_vmem_protect_limit"})," - Sets the upper boundary that all query processes can consume and should not exceed the amount of physical memory of a segment host. When a segment host reaches this limit during query execution, the queries that cause the limit to be exceeded will be cancelled."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"gp_vmem_idle_resource_timeout"})," and ",(0,t.jsx)(s.code,{children:"gp_vmem_protect_segworker_cache_limit"})," - used to free memory on segment hosts held by idle database processes. Administrators may want to adjust these settings on systems with lots of concurrency."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"shared_buffers"})," - Sets the amount of memory a Cloudberry server instance uses for shared memory buffers. This setting must be at least 128 kilobytes and at least 16 kilobytes times ",(0,t.jsx)(s.code,{children:"max_connections"}),". The value must not exceed the operating system shared memory maximum allocation request size, ",(0,t.jsx)(s.code,{children:"shmmax"})," on Linux."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Query prioritization. Note that the following parameters are all local parameters, meaning they must be set in the ",(0,t.jsx)(s.code,{children:"postgresql.conf"})," files of the coordinator and all segments:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"gp_resqueue_priority"})," - The query prioritization feature is enabled by default."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"gp_resqueue_priority_sweeper_interval"})," - Sets the interval at which CPU usage is recalculated for all active statements. The default value for this parameter should be sufficient for typical database operations."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"gp_resqueue_priority_cpucores_per_segment"})," - Specifies the number of CPU cores allocated per segment instance on a segment host. If the segment is configured with primary-mirror segment instance pairs, use the number of primary segment instances on the host in the calculation. The default value is 4 for the coordinator and segment hosts."]}),"\n",(0,t.jsxs)(s.p,{children:["Each Cloudberry host checks its own ",(0,t.jsx)(s.code,{children:"postgresql.conf"})," file for the value of this parameter. This parameter also affects the coordinator host, where it should be set to a value reflecting the higher ratio of CPU cores. For example, on a cluster that has 10 CPU cores per segment host and 4 primary segments per host, you would specify the following values for ",(0,t.jsx)(s.code,{children:"gp_resqueue_priority_cpucores_per_segment"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"10"})," on the coordinator and standby coordinator hosts. Typically, only a single coordinator segment instance runs on the coordinator host."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"2.5"})," on each segment host (10 cores divided by 4 primary segments)."]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"If the parameter value is not set correctly, either the CPU might not be fully utilized, or query prioritization might not work as expected. For example, if the Apache Cloudberry cluster has fewer than one segment instance per CPU core on your segment hosts, make sure that you adjust this value accordingly."}),"\n",(0,t.jsx)(s.p,{children:"Actual CPU core utilization is based on the ability of Apache Cloudberry to parallelize a query and the resources required to run the query."}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsx)(s.p,{children:"Include any CPU core that is available to the operating system in the number of CPU cores, including virtual CPU cores."})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Use the ",(0,t.jsx)(s.code,{children:"gpconfig"})," utility to view or change any of the resource management parameter values. For example, to see the setting of a particular parameter:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"gpconfig --show gp_vmem_protect_limit\n"})}),"\n",(0,t.jsx)(s.p,{children:"To set one value on all segment instances and a different value on the coordinator:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"gpconfig -c gp_resqueue_priority_cpucores_per_segment -v 2 -m 8\n"})}),"\n",(0,t.jsx)(s.p,{children:"Restart Apache Cloudberry to make the configuration changes effective:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"gpstop -r\n"})}),"\n",(0,t.jsx)(s.h2,{id:"create-resource-queues",children:"Create resource queues"}),"\n",(0,t.jsxs)(s.p,{children:["When you create a resource queue for a role, you provide a name, set an active query limit, and optionally a query priority for the resource queue. Use the ",(0,t.jsx)(s.a,{href:"/docs/next/sql-stmts/create-resource-queue",children:(0,t.jsx)(s.code,{children:"CREATE RESOURCE QUEUE"})})," command to create new resource queues."]}),"\n",(0,t.jsx)(s.h3,{id:"create-queues-with-an-active-query-limit",children:"Create queues with an active query limit"}),"\n",(0,t.jsxs)(s.p,{children:["Resource queues with an ",(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"})," setting limit the number of queries that can be run by roles assigned to that queue. For example, to create a resource queue named ",(0,t.jsx)(s.code,{children:"adhoc"})," with an active query limit of three:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"CREATE RESOURCE QUEUE adhoc WITH (ACTIVE_STATEMENTS=3);\n"})}),"\n",(0,t.jsxs)(s.p,{children:["This means that for all roles assigned to the ",(0,t.jsx)(s.code,{children:"adhoc"})," resource queue, only three active queries can be running on the system at any given time. If this queue has three queries running, and a fourth query is submitted by a role in that queue, that query must wait until a slot is free before it can run."]}),"\n",(0,t.jsx)(s.h3,{id:"create-queues-with-memory-limits",children:"Create queues with memory limits"}),"\n",(0,t.jsxs)(s.p,{children:["Resource queues with a ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," setting control the amount of memory for all the queries submitted through the queue. The total memory should not exceed the physical memory available per-segment. Set ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," to 90% of memory available on a per-segment basis. For example, if a host has 48 GB of physical memory and 6 segment instances, then the memory available per segment instance is 8 GB. You can calculate the recommended ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," for a single queue as 0.90*8=7.2 GB. If there are multiple queues created on the system, their total memory limits must also add up to 7.2 GB."]}),"\n",(0,t.jsxs)(s.p,{children:["When used in conjunction with ",(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"}),", the default amount of memory allotted per query is: ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT / ACTIVE_STATEMENTS"}),". When used in conjunction with ",(0,t.jsx)(s.code,{children:"MAX_COST"}),", the default amount of memory allotted per query is: ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT * (query_cost / MAX_COST)"}),". Use ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," in conjunction with ",(0,t.jsx)(s.code,{children:"ACTIVE_STATEMENTS"})," rather than with ",(0,t.jsx)(s.code,{children:"MAX_COST"}),"."]}),"\n",(0,t.jsx)(s.p,{children:"For example, to create a resource queue with an active query limit of 10 and a total memory limit of 2000MB (each query will be allocated 200MB of segment host memory at execution time):"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"CREATE RESOURCE QUEUE myqueue WITH (ACTIVE_STATEMENTS=20, \nMEMORY_LIMIT='2000MB');\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The default memory allotment can be overridden on a per-query basis using the ",(0,t.jsx)(s.code,{children:"statement_mem"})," server configuration parameter, provided that ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," or ",(0,t.jsx)(s.code,{children:"max_statement_mem"})," is not exceeded. For example, to allocate more memory to a particular query:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SET statement_mem='2GB';\nSELECT * FROM my_big_table WHERE column='value' ORDER BY id;\nRESET statement_mem;\n"})}),"\n",(0,t.jsxs)(s.p,{children:["As a general guideline, ",(0,t.jsx)(s.code,{children:"MEMORY_LIMIT"})," for all of your resource queues should not exceed the amount of physical memory of a segment host. If workloads are staggered over multiple queues, it may be OK to oversubscribe memory allocations, keeping in mind that queries may be cancelled during execution if the segment host memory limit (",(0,t.jsx)(s.code,{children:"gp_vmem_protect_limit"}),") is exceeded."]}),"\n",(0,t.jsx)(s.h3,{id:"set-priority-levels",children:"Set priority levels"}),"\n",(0,t.jsx)(s.p,{children:"To control a resource queue's consumption of available CPU resources, an administrator can assign an appropriate priority level. When high concurrency causes contention for CPU resources, queries and statements associated with a high-priority resource queue will claim a larger share of available CPU than lower priority queries and statements."}),"\n",(0,t.jsxs)(s.p,{children:["Priority settings are created or altered using the ",(0,t.jsx)(s.code,{children:"WITH"})," parameter of the commands ",(0,t.jsx)(s.code,{children:"CREATE RESOURCE QUEUE"})," and ",(0,t.jsx)(s.code,{children:"ALTER RESOURCE QUEUE"}),". For example, to specify priority settings for the ",(0,t.jsx)(s.code,{children:"adhoc"})," and ",(0,t.jsx)(s.code,{children:"reporting"})," queues, an administrator would use the following commands:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"ALTER RESOURCE QUEUE adhoc WITH (PRIORITY=LOW);\nALTER RESOURCE QUEUE reporting WITH (PRIORITY=HIGH);\n"})}),"\n",(0,t.jsxs)(s.p,{children:["To create the ",(0,t.jsx)(s.code,{children:"executive"})," queue with maximum priority, an administrator would use the following command:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"CREATE RESOURCE QUEUE executive WITH (ACTIVE_STATEMENTS=3, PRIORITY=MAX);\n"})}),"\n",(0,t.jsxs)(s.p,{children:["When the query prioritization feature is enabled, resource queues are given a ",(0,t.jsx)(s.code,{children:"MEDIUM"})," priority by default if not explicitly assigned. For more information on how priority settings are evaluated at runtime, see ",(0,t.jsx)(s.a,{href:"#how-priorities-work",children:"How Priorities Work"}),"."]}),"\n",(0,t.jsx)(s.admonition,{type:"tip",children:(0,t.jsxs)(s.p,{children:["In order for resource queue priority levels to be enforced on the active query workload, you must enable the query prioritization feature by setting the associated server configuration parameters. See ",(0,t.jsx)(s.a,{href:"#configure-resource-queues",children:"Configure Resource Queues"}),"."]})}),"\n",(0,t.jsx)(s.h2,{id:"assign-roles-to-a-resource-queue",children:"Assign roles to a resource queue"}),"\n",(0,t.jsxs)(s.p,{children:["Once a resource queue is created, you must assign roles (users) to their appropriate resource queue. If roles are not explicitly assigned to a resource queue, they will go to the default resource queue, ",(0,t.jsx)(s.code,{children:"pg_default"}),". The default resource queue has an active statement limit of ",(0,t.jsx)(s.code,{children:"20"}),", no cost limit, and a medium priority setting."]}),"\n",(0,t.jsxs)(s.p,{children:["Use the ",(0,t.jsx)(s.code,{children:"ALTER ROLE"})," or ",(0,t.jsx)(s.code,{children:"CREATE ROLE"})," commands to assign a role to a resource queue. For example:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"ALTER ROLE `name` RESOURCE QUEUE `queue_name`;\nCREATE ROLE `name` WITH LOGIN RESOURCE QUEUE `queue_name`;\n"})}),"\n",(0,t.jsxs)(s.p,{children:["A role can only be assigned to one resource queue at any given time, so you can use the ",(0,t.jsx)(s.code,{children:"ALTER ROLE"})," command to initially assign or change a role's resource queue."]}),"\n",(0,t.jsx)(s.p,{children:"Resource queues must be assigned on a user-by-user basis. If you have a role hierarchy (for example, a group-level role) then assigning a resource queue to the group does not propagate down to the users in that group."}),"\n",(0,t.jsx)(s.p,{children:"Superusers are always exempt from resource queue limits. Superuser queries will always run regardless of the limits set on their assigned queue."}),"\n",(0,t.jsx)(s.h3,{id:"remove-a-role-from-a-resource-queue",children:"Remove a role from a resource queue"}),"\n",(0,t.jsxs)(s.p,{children:["All users need to be assigned to a resource queue. If not explicitly assigned to a particular queue, users will go into the default resource queue, ",(0,t.jsx)(s.code,{children:"pg_default"}),". If you wish to remove a role from a resource queue and put them in the default queue, change the role's queue assignment to ",(0,t.jsx)(s.code,{children:"none"}),". For example:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"ALTER ROLE `role_name` RESOURCE QUEUE none;\n"})}),"\n",(0,t.jsx)(s.h2,{id:"modify-resource-queues",children:"Modify resource queues"}),"\n",(0,t.jsxs)(s.p,{children:["After a resource queue has been created, you can change or reset the queue limits using the ",(0,t.jsx)(s.code,{children:"ALTER RESOURCE QUEUE"})," command. You can remove a resource queue using the ",(0,t.jsx)(s.code,{children:"DROP RESOURCE QUEUE"})," command. To change the roles (users) assigned to a resource queue, ",(0,t.jsx)(s.a,{href:"#assign-roles-to-a-resource-queue",children:"Assign Roles to a Resource Queue"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"alter-a-resource-queue",children:"Alter a resource queue"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"ALTER RESOURCE QUEUE"})," command changes the limits of a resource queue. To change the limits of a resource queue, specify the new values you want for the queue. For example:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"ALTER RESOURCE QUEUE <adhoc> WITH (ACTIVE_STATEMENTS=5);\nALTER RESOURCE QUEUE <exec> WITH (PRIORITY=MAX);\n"})}),"\n",(0,t.jsxs)(s.p,{children:["To reset active statements or memory limit to no limit, enter a value of ",(0,t.jsx)(s.code,{children:"-1"}),". To reset the maximum query cost to no limit, enter a value of ",(0,t.jsx)(s.code,{children:"-1.0"}),". For example:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"ALTER RESOURCE QUEUE <adhoc> WITH (MAX_COST=-1.0, MEMORY_LIMIT='2GB');\n"})}),"\n",(0,t.jsxs)(s.p,{children:["You can use the ",(0,t.jsx)(s.code,{children:"ALTER RESOURCE QUEUE"})," command to change the priority of queries associated with a resource queue. For example, to set a queue to the minimum priority level:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"ALTER RESOURCE QUEUE <webuser> WITH (PRIORITY=MIN);\n"})}),"\n",(0,t.jsx)(s.h3,{id:"drop-a-resource-queue",children:"Drop a resource queue"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"DROP RESOURCE QUEUE"})," command drops a resource queue. To drop a resource queue, the queue cannot have any roles assigned to it, nor can it have any statements waiting in the queue. See ",(0,t.jsx)(s.a,{href:"#remove-a-role-from-a-resource-queue",children:"Remove a Role from a Resource Queue"})," and ",(0,t.jsx)(s.a,{href:"#clear-a-waiting-statement-from-a-resource-queue",children:"Clear a Waiting Statement From a Resource Queue"})," for instructions on emptying a resource queue. To drop a resource queue:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"DROP RESOURCE QUEUE <name>;\n"})}),"\n",(0,t.jsx)(s.h2,{id:"monitor-resource-queue-status",children:"Monitor resource queue status"}),"\n",(0,t.jsx)(s.p,{children:"Monitoring resource queue status involves the following tasks:"}),"\n",(0,t.jsx)(s.h3,{id:"view-queued-statements-and-resource-queue-status",children:"View queued statements and resource queue status"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.a,{href:"/docs/next/sys-catalogs/gp_toolkit#gp_resqueue_status",children:(0,t.jsx)(s.code,{children:"gp_toolkit.gp_resqueue_status"})})," view allows administrators to see status and activity for a resource queue. It shows how many queries are waiting to run and how many queries are currently active in the system from a particular resource queue. To see the resource queues created in the system, their limit attributes, and their current status:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT * FROM gp_toolkit.gp_resqueue_status;\n"})}),"\n",(0,t.jsx)(s.h3,{id:"view-resource-queue-statistics",children:"View resource queue statistics"}),"\n",(0,t.jsxs)(s.p,{children:["If you want to track statistics and performance of resource queues over time, you can enable statistics collecting for resource queues. This is done by setting the following server configuration parameter in your coordinator ",(0,t.jsx)(s.code,{children:"postgresql.conf"})," file:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"stats_queue_level = on\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Once this is enabled, you can use the ",(0,t.jsx)(s.code,{children:"pg_stat_resqueue"})," system view to see the statistics collected on resource queue usage. Note that enabling this feature does incur slight performance overhead, as each query submitted through a resource queue must be tracked. It may be useful to enable statistics collecting on resource queues for initial diagnostics and administrative planning, and then deactivate the feature for continued use."]}),"\n",(0,t.jsx)(s.p,{children:"See the Statistics Collector section in the PostgreSQL documentation for more information about collecting statistics in Apache Cloudberry."}),"\n",(0,t.jsx)(s.h3,{id:"view-the-roles-assigned-to-a-resource-queue",children:"View the roles assigned to a resource queue"}),"\n",(0,t.jsxs)(s.p,{children:["To see the roles assigned to a resource queue, perform the following query of the ",(0,t.jsx)(s.code,{children:"pg_roles"})," and the ",(0,t.jsx)(s.code,{children:"gp_toolkt.gp_resqueue_status"})," system catalog tables:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT rolname, rsqname FROM pg_roles, \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0gp_toolkit.gp_resqueue_status \nWHERE pg_roles.rolresqueue=gp_toolkit.gp_resqueue_status.queueid;\n"})}),"\n",(0,t.jsx)(s.p,{children:"You may want to create a view of this query to simplify future inquiries. For example:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"CREATE VIEW role2queue AS\nSELECT rolname, rsqname FROM pg_roles, pg_resqueue \nWHERE pg_roles.rolresqueue=gp_toolkit.gp_resqueue_status.queueid;\n"})}),"\n",(0,t.jsx)(s.p,{children:"Then you can just query the view:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT * FROM role2queue;\n"})}),"\n",(0,t.jsx)(s.h3,{id:"view-the-waiting-queries-for-a-resource-queue",children:"View the waiting queries for a resource queue"}),"\n",(0,t.jsxs)(s.p,{children:["When a slot is in use for a resource queue, it is recorded in the ",(0,t.jsx)(s.code,{children:"pg_locks"})," system catalog table. This is where you can see all of the currently active and waiting queries for all resource queues. To check that statements are being queued (even statements that are not waiting), you can also use the ",(0,t.jsx)(s.a,{href:"/docs/next/sys-catalogs/gp_toolkit#gp_locks_on_resqueue",children:(0,t.jsx)(s.code,{children:"gp_toolkit.gp_locks_on_resqueue"})})," view. For example:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT * FROM gp_toolkit.gp_locks_on_resqueue WHERE lorwaiting='true';\n"})}),"\n",(0,t.jsx)(s.p,{children:"If this query returns no results, then that means there are currently no statements waiting in a resource queue."}),"\n",(0,t.jsx)(s.h3,{id:"clear-a-waiting-statement-from-a-resource-queue",children:"Clear a waiting statement from a resource queue"}),"\n",(0,t.jsxs)(s.p,{children:["In some cases, you may want to clear a waiting statement from a resource queue. For example, you may want to remove a query that is waiting in the queue but has not been run yet. You may also want to stop a query that has been started if it is taking too long to run, or if it is sitting idle in a transaction and taking up resource queue slots that are needed by other users. To do this, you must first identify the statement you want to clear, determine its process id (pid), and then, use ",(0,t.jsx)(s.code,{children:"pg_cancel_backend"})," with the process id to end that process, as shown below. An optional message to the process can be passed as the second parameter, to indicate to the user why the process was cancelled."]}),"\n",(0,t.jsx)(s.p,{children:"For example, to see process information about all statements currently active or waiting in all resource queues, run the following query:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT rolname, rsqname, pg_locks.pid as pid, granted, state,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0query, datname \nFROM pg_roles, gp_toolkit.gp_resqueue_status, pg_locks,\n\xa0\xa0\xa0\xa0\xa0pg_stat_activity \nWHERE pg_roles.rolresqueue=pg_locks.objid \nAND pg_locks.objid=gp_toolkit.gp_resqueue_status.queueid\nAND pg_stat_activity.pid=pg_locks.pid\nAND pg_stat_activity.usename=pg_roles.rolname;\n"})}),"\n",(0,t.jsx)(s.p,{children:"If this query returns no results, then that means there are currently no statements in a resource queue. A sample of a resource queue with two statements in it looks something like this:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"rolname | rsqname | \xa0pid\xa0 | granted | state  | \xa0\xa0\xa0\xa0    query    \xa0\xa0\xa0\xa0\xa0 | datname \n--------+---------+-------+---------+--------+------------------------+--------- \n\xa0\xa0sammy | webuser | 31861 | t \xa0\xa0\xa0\xa0\xa0\xa0| idle   | SELECT * FROM testtbl; | namesdb\n \xa0daria | webuser | 31905 | f \xa0\xa0\xa0\xa0 \xa0| active | SELECT * FROM topten; \xa0| namesdb\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Use this output to identify the process id (pid) of the statement you want to clear from the resource queue. To clear the statement, you would then open a terminal window (as the ",(0,t.jsx)(s.code,{children:"gpadmin"})," database superuser or as root) on the coordinator host and cancel the corresponding process. For example:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"pg_cancel_backend(31905)\n"})}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["Do not use the operating system ",(0,t.jsx)(s.code,{children:"KILL"})," command."]})}),"\n",(0,t.jsx)(s.h3,{id:"view-the-priority-of-active-statements",children:"View the priority of active statements"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"gp_toolkit"})," administrative schema has a view called ",(0,t.jsx)(s.code,{children:"gp_resq_priority_statement"}),", which lists all statements currently being run and provides the priority, session ID, and other information."]}),"\n",(0,t.jsxs)(s.p,{children:["This view is only available through the ",(0,t.jsx)(s.code,{children:"gp_toolkit"})," administrative schema."]}),"\n",(0,t.jsx)(s.h3,{id:"reset-the-priority-of-an-active-statement",children:"Reset the priority of an active statement"}),"\n",(0,t.jsxs)(s.p,{children:["Superusers can adjust the priority of a statement currently being run using the built-in function ",(0,t.jsx)(s.code,{children:"gp_adjust_priority(session_id, statement_count, priority)"}),". Using this function, superusers can raise or lower the priority of any query. For example:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:"SELECT gp_adjust_priority(752, 24905, 'HIGH')`\n"})}),"\n",(0,t.jsxs)(s.p,{children:["To obtain the session ID and statement count parameters required by this function, superusers can use the ",(0,t.jsx)(s.code,{children:"gp_toolkit"})," administrative schema view ",(0,t.jsx)(s.code,{children:"gp_resq_priority_statement"}),". From the view, use these values for the function parameters."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["The value of the ",(0,t.jsx)(s.code,{children:"rqpsession"})," column for the ",(0,t.jsx)(s.code,{children:"session_id"})," parameter"]}),"\n",(0,t.jsxs)(s.li,{children:["The value of the ",(0,t.jsx)(s.code,{children:"rqpcommand"})," column for the ",(0,t.jsx)(s.code,{children:"statement_count"})," parameter"]}),"\n",(0,t.jsxs)(s.li,{children:["The value of ",(0,t.jsx)(s.code,{children:"rqppriority"})," column is the current priority. You can specify a string value of ",(0,t.jsx)(s.code,{children:"MAX"}),", ",(0,t.jsx)(s.code,{children:"HIGH"}),", ",(0,t.jsx)(s.code,{children:"MEDIUM"}),", or ",(0,t.jsx)(s.code,{children:"LOW"})," as the ",(0,t.jsx)(s.code,{children:"priority"}),"."]}),"\n"]}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"gp_adjust_priority()"})," function affects only the specified statement. Subsequent statements in the same resource queue are run using the queue's normally assigned priority."]})})]})}function d(e={}){const{wrapper:s}={...(0,n.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},91644:(e,s,r)=>{r.d(s,{Z:()=>t});const t=r.p+"assets/images/resource-queues-1-6480c1d7aaa462181f30f8040bea3744.png"},22929:(e,s,r)=>{r.d(s,{Z:()=>t});const t=r.p+"assets/images/resource-queues-2-5864f0ffaae1eb5e2b3c88e97ea7f534.png"},11100:(e,s,r)=>{r.d(s,{Z:()=>t});const t=r.p+"assets/images/resource-queues-3-04782796585ad270f63b451ebef440ce.png"},23882:(e,s,r)=>{r.d(s,{Z:()=>t});const t=r.p+"assets/images/resource-queues-4-0bea0066372157c4fb93e98ac2b7705b.png"},11151:(e,s,r)=>{r.d(s,{Z:()=>a,a:()=>i});var t=r(67294);const n={},o=t.createContext(n);function i(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);