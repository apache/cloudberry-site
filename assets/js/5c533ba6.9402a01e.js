"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[43386],{65367:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var s=i(85893),t=i(11151);const o={title:"Considerations when using GPORCA"},r="Considerations when using GPORCA",a={id:"performance/optimize-queries/use-orca/gporca-usage-considerations",title:"Considerations when using GPORCA",description:"To ensure optimal query performance with GPORCA, it is important to carefully review query conditions.",source:"@site/versioned_docs/version-2.x/performance/optimize-queries/use-orca/gporca-usage-considerations.md",sourceDirName:"performance/optimize-queries/use-orca",slug:"/performance/optimize-queries/use-orca/gporca-usage-considerations",permalink:"/docs/performance/optimize-queries/use-orca/gporca-usage-considerations",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/performance/optimize-queries/use-orca/gporca-usage-considerations.md",tags:[],version:"2.x",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1756779972,formattedLastUpdatedAt:"Sep 2, 2025",frontMatter:{title:"Considerations when using GPORCA"},sidebar:"docsbars",previous:{title:"GPORCA Limitations",permalink:"/docs/performance/optimize-queries/use-orca/gporca-limitations"},next:{title:"Create Unique Index on AO Table",permalink:"/docs/performance/optimize-queries/use-unique-index-on-ao-tables"}},c={},l=[];function d(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"considerations-when-using-gporca",children:"Considerations when using GPORCA"}),"\n",(0,s.jsx)(n.p,{children:"To ensure optimal query performance with GPORCA, it is important to carefully review query conditions."}),"\n",(0,s.jsx)(n.p,{children:"Make sure the following conditions are met:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The table does not use multi-column partitioning keys."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["When querying tables that reside only on the coordinator (such as system tables like ",(0,s.jsx)(n.em,{children:"pg_attribute"}),"), the server parameter ",(0,s.jsx)(n.code,{children:"optimizer_enable_coordinator_only_queries"})," should be set to ",(0,s.jsx)(n.code,{children:"on"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Enabling this parameter may reduce the performance of short-running system table queries. To avoid this, it's recommended to enable it only for the current session or a specific query."})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Statistics for the root partition of partitioned tables have been collected."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If a partitioned table contains more than 20,000 partitions, consider redesigning the table structure."}),"\n",(0,s.jsx)(n.p,{children:"The following server configuration parameters affect GPORCA\u2019s query planning behavior:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"optimizer_cte_inlining_bound"})," controls how aggressively GPORCA inlines Common Table Expressions (CTEs), i.e., queries with ",(0,s.jsx)(n.code,{children:"WITH"})," clauses."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"optimizer_force_comprehensive_join_implementation"})," controls whether GPORCA evaluates both nested loop and hash join plans. The default is ",(0,s.jsx)(n.code,{children:"false"}),", meaning nested loop joins are not considered when hash joins are available."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"optimizer_force_multistage_agg"})," forces GPORCA to choose a multi-stage aggregation plan for scalar aggregates with ",(0,s.jsx)(n.code,{children:"DISTINCT"}),". The default is ",(0,s.jsx)(n.code,{children:"off"}),", meaning it chooses between single-stage and multi-stage plans based on cost."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"optimizer_force_three_stage_scalar_dqa"})," forces GPORCA to select a three-stage plan when such an option is available for distinct qualified aggregates (DQA)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"optimizer_join_order"})," sets the level of join order optimization, controlling which types of join sequences GPORCA will evaluate."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"optimizer_join_order_threshold"})," defines the maximum number of join relations for which GPORCA will use a dynamic programming join order algorithm."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"optimizer_nestloop_factor"})," adjusts the cost multiplier GPORCA uses when estimating nested loop joins."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"optimizer_parallel_union"})," controls the degree of parallelism for queries that use ",(0,s.jsx)(n.code,{children:"UNION"})," or ",(0,s.jsx)(n.code,{children:"UNION ALL"}),". When set to ",(0,s.jsx)(n.code,{children:"on"}),", GPORCA may generate plans that execute union operations in parallel across segments."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"optimizer_sort_factor"})," adjusts the cost estimation factor for sort operations. You can tune this value to better reflect performance under data skew conditions."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"gp_enable_relsize_collection"})," controls how GPORCA (and the Postgres planner) estimates table size in the absence of statistics. By default, GPORCA assumes a default row count when statistics are missing. When this parameter is set to ",(0,s.jsx)(n.code,{children:"on"}),", estimated table size will be used instead."]}),"\n",(0,s.jsx)(n.p,{children:"This parameter does not apply to root partitions. If the root partition lacks statistics, GPORCA will always use default estimates. You can collect statistics on the root partition using:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"ANALYZE ROOTPARTITION;\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The following server parameters control logging and display behavior:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"optimizer_print_missing_stats"})," controls whether the plan output includes information about columns missing statistics (default: ",(0,s.jsx)(n.code,{children:"true"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"optimizer_print_optimization_stats"})," controls whether GPORCA logs internal optimization metrics (default: ",(0,s.jsx)(n.code,{children:"off"}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["When executing a GPORCA-generated plan with ",(0,s.jsx)(n.code,{children:"EXPLAIN ANALYZE"}),", only the number of pruned partitions is shown \u2014 the list of scanned partitions is not included. To log the names of scanned partitions in the segment logs, set the server parameter ",(0,s.jsx)(n.code,{children:"gp_log_dynamic_partition_pruning"})," to ",(0,s.jsx)(n.code,{children:"on"}),". You can enable this with the following command:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SET gp_log_dynamic_partition_pruning = on;\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>r});var s=i(67294);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);