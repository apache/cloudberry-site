"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[97962],{87574:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>l,frontMatter:()=>i,metadata:()=>a,toc:()=>o});var n=s(85893),c=s(11151);const i={title:"pg_cast"},r="pg_cast",a={id:"sys-catalogs/sys-tables/pg-cast",title:"pg_cast",description:"The pgcast table in the pgcatalog schema stores data type conversion paths, both built-in paths and those defined with CREATE CAST.",source:"@site/docs/sys-catalogs/sys-tables/pg-cast.md",sourceDirName:"sys-catalogs/sys-tables",slug:"/sys-catalogs/sys-tables/pg-cast",permalink:"/docs/next/sys-catalogs/sys-tables/pg-cast",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sys-catalogs/sys-tables/pg-cast.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1749788112,formattedLastUpdatedAt:"Jun 13, 2025",frontMatter:{title:"pg_cast"},sidebar:"docsbars",previous:{title:"pg_description",permalink:"/docs/next/sys-catalogs/sys-tables/pg-description"},next:{title:"pg_class",permalink:"/docs/next/sys-catalogs/sys-tables/pg-class"}},d={},o=[];function h(e){const t={code:"code",h1:"h1",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,c.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"pg_cast",children:"pg_cast"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"pg_cast"})," table in the ",(0,n.jsx)(t.code,{children:"pg_catalog"})," schema stores data type conversion paths, both built-in paths and those defined with ",(0,n.jsx)(t.code,{children:"CREATE CAST"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Note that ",(0,n.jsx)(t.code,{children:"pg_cast"})," does not represent every type conversion known to the system, only those that cannot be deduced from some generic rule. For example, casting between a domain and its base type is not explicitly represented in ",(0,n.jsx)(t.code,{children:"pg_cast"}),'. Another important exception is that "automatic I/O conversion casts", those performed using a data type\'s own I/O functions to convert to or from ',(0,n.jsx)(t.code,{children:"text"})," or other string types, are not explicitly represented in ",(0,n.jsx)(t.code,{children:"pg_cast"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["The cast functions listed in ",(0,n.jsx)(t.code,{children:"pg_cast"})," must always take the cast source type as their first argument type, and return the cast destination type as their result type. A cast function can have up to three arguments. The second argument, if present, must be type ",(0,n.jsx)(t.code,{children:"integer"}),"; it receives the type modifier associated with the destination type, or ",(0,n.jsx)(t.code,{children:"-1"})," if there is none. The third argument, if present, must be type ",(0,n.jsx)(t.code,{children:"boolean"}),"; it receives ",(0,n.jsx)(t.code,{children:"true"})," if the cast is an explicit cast, ",(0,n.jsx)(t.code,{children:"false"})," otherwise."]}),"\n",(0,n.jsxs)(t.p,{children:["It is legitimate to create a ",(0,n.jsx)(t.code,{children:"pg_cast"})," entry in which the source and target types are the same, if the associated function takes more than one argument. Such entries represent 'length coercion functions' that coerce values of the type to be legal for a particular type modifier value."]}),"\n",(0,n.jsxs)(t.p,{children:["When a ",(0,n.jsx)(t.code,{children:"pg_cast"})," entry has different source and target types and a function that takes more than one argument, the entry converts from one type to another and applies a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two steps, one to convert between data types and a second to apply the modifier."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"column"}),(0,n.jsx)(t.th,{children:"type"}),(0,n.jsx)(t.th,{children:"references"}),(0,n.jsx)(t.th,{children:"description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"oid"})}),(0,n.jsx)(t.td,{children:"oid"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"The object ID."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"castsource"})}),(0,n.jsx)(t.td,{children:"oid"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"pg_type.oid"})}),(0,n.jsx)(t.td,{children:"OID of the source data type."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"casttarget"})}),(0,n.jsx)(t.td,{children:"oid"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"pg_type.oid"})}),(0,n.jsx)(t.td,{children:"OID of the target data type."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"castfunc"})}),(0,n.jsx)(t.td,{children:"oid"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"pg_proc.oid"})}),(0,n.jsx)(t.td,{children:"The OID of the function to use to perform this cast. Zero is stored if the cast method does not require a function."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"castcontext"})}),(0,n.jsx)(t.td,{children:"char"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["Indicates what contexts the cast may be invoked in. ",(0,n.jsx)(t.code,{children:"e"})," means only as an explicit cast (using ",(0,n.jsx)(t.code,{children:"CAST"})," or ",(0,n.jsx)(t.code,{children:"::"})," syntax). ",(0,n.jsx)(t.code,{children:"a"})," means implicitly in assignment to a target column, as well as explicitly. ",(0,n.jsx)(t.code,{children:"i"})," means implicitly in expressions, as well as the other cases*.*"]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"castmethod"})}),(0,n.jsx)(t.td,{children:"char"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["Indicates how the cast is performed:",(0,n.jsx)("br",{}),(0,n.jsx)("br",{}),(0,n.jsx)(t.code,{children:"f"})," - The function identified in the ",(0,n.jsx)(t.code,{children:"castfunc"})," field is used.",(0,n.jsx)("br",{}),(0,n.jsx)("br",{}),(0,n.jsx)(t.code,{children:"i"})," - The input/output functions are used.",(0,n.jsx)("br",{}),(0,n.jsx)("br",{}),(0,n.jsx)(t.code,{children:"b"})," - The types are binary-coercible, and no conversion is required."]})]})]})]})]})}function l(e={}){const{wrapper:t}={...(0,c.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>a,a:()=>r});var n=s(67294);const c={},i=n.createContext(c);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);