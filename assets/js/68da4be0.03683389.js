"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[41873],{89649:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>c,toc:()=>a});var n=r(85893),i=r(11151);const t={title:"Monitor Long-Running Operations"},d="Monitor Long-Running Operations",c={id:"sys-admin/monitor-long-running-operations",title:"Monitor Long-Running Operations",description:"Apache Cloudberry can report the progress of ANALYZE, CLUSTER, COPY, CREATE INDEX, REINDEX, and VACUUM commands during command execution. Cloudberry can also report the progress of a running base backup (initiated during gprecoverseg -F) command invocation, allowing you to monitor the progress of these possibly long-running operations.",source:"@site/docs/sys-admin/monitor-long-running-operations.md",sourceDirName:"sys-admin",slug:"/sys-admin/monitor-long-running-operations",permalink:"/docs/next/sys-admin/monitor-long-running-operations",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sys-admin/monitor-long-running-operations.md",tags:[],version:"current",lastUpdatedBy:"TomShawn",lastUpdatedAt:1767860953,formattedLastUpdatedAt:"Jan 8, 2026",frontMatter:{title:"Monitor Long-Running Operations"},sidebar:"docsbars",previous:{title:"Routine System Maintenance Tasks",permalink:"/docs/next/sys-admin/routine-maintain-tasks"},next:{title:"Develop a Background Worker Process",permalink:"/docs/next/developer/develop-background-process-worker"}},o={},a=[{value:"Analyze progress reporting",id:"analyze-progress-reporting",level:2},{value:"Cluster and VACUUM FULL progress reporting",id:"cluster-and-vacuum-full-progress-reporting",level:2},{value:"Heap table cluster phases",id:"heap-table-cluster-phases",level:3},{value:"Ao/co table cluster phases",id:"aoco-table-cluster-phases",level:3},{value:"Copy progress reporting",id:"copy-progress-reporting",level:2},{value:"Create INDEX progress reporting",id:"create-index-progress-reporting",level:2},{value:"Vacuum progress reporting",id:"vacuum-progress-reporting",level:2},{value:"Heap table vacuum phases",id:"heap-table-vacuum-phases",level:3},{value:"Ao/co table vacuum phases",id:"aoco-table-vacuum-phases",level:3},{value:"Base backup progress reporting",id:"base-backup-progress-reporting",level:2},{value:"Example: viewing real-time command progress",id:"example-viewing-real-time-command-progress",level:2},{value:"Additional considerations",id:"additional-considerations",level:2}];function l(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"monitor-long-running-operations",children:"Monitor Long-Running Operations"}),"\n",(0,n.jsxs)(s.p,{children:["Apache Cloudberry can report the progress of ",(0,n.jsx)(s.code,{children:"ANALYZE"}),", ",(0,n.jsx)(s.code,{children:"CLUSTER"}),", ",(0,n.jsx)(s.code,{children:"COPY"}),", ",(0,n.jsx)(s.code,{children:"CREATE INDEX"}),", ",(0,n.jsx)(s.code,{children:"REINDEX"}),", and ",(0,n.jsx)(s.code,{children:"VACUUM"})," commands during command execution. Cloudberry can also report the progress of a running base backup (initiated during ",(0,n.jsx)(s.a,{href:"/docs/next/sys-utilities/gprecoverseg",children:(0,n.jsx)(s.code,{children:"gprecoverseg -F"})}),") command invocation, allowing you to monitor the progress of these possibly long-running operations."]}),"\n",(0,n.jsx)(s.p,{children:"Cloudberry reports the command progress via ephemeral system views, which return data only while the operations are running. Two sets of progress reporting views are provided:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"gp_stat_progress_<command>"})," - displays the progress of running ",(0,n.jsx)(s.code,{children:"<command>"})," invocations on the coordinator and all segments, with a row per segment instance"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"gp_stat_progress_<command>_summary"})," - aggregates ",(0,n.jsx)(s.code,{children:"<command>"})," progress on the coordinator and all segments, and displays one row per running ",(0,n.jsx)(s.code,{children:"<command>"})," invocation"]}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["Cloudberry reports progress in phases, where the phases are specific to the command. For example, ",(0,n.jsx)(s.code,{children:"acquiring sample rows"})," is an analyze progress phase, while ",(0,n.jsx)(s.code,{children:"building index"})," is an index creation progress phase. Cloudberry reports the progress for both heap and AO/CO tables. For most commands, heap and AO/CO table share the same phases. For vacuum and cluster operations, Cloudberry reports heap and AO/CO table progress in separate phases."]}),"\n",(0,n.jsx)(s.h2,{id:"analyze-progress-reporting",children:"Analyze progress reporting"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.a,{href:"/docs/next/sys-catalogs/sys-views/pg-stat-progress-analyze",children:(0,n.jsx)(s.code,{children:"pg_stat_progress_analyze"})})," system view reports the progress of running ",(0,n.jsx)(s.code,{children:"ANALYZE"})," and ",(0,n.jsx)(s.code,{children:"analyzedb"})," operations. The view displays a row per segment instance that is currently servicing an analyze operation."]}),"\n",(0,n.jsxs)(s.p,{children:["For each active analyze operation, the ",(0,n.jsx)(s.code,{children:"gp_stat_progress_analyze_summary"})," view aggregates across the Apache Cloudberry cluster the metrics reported by ",(0,n.jsx)(s.code,{children:"gp_stat_progress_analyze"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"The table below describes how to interpret the phase-specific information reported in the views:"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Phase"}),(0,n.jsx)(s.th,{children:"Description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"initializing"})}),(0,n.jsx)(s.td,{children:"The command is preparing to begin scanning the heap. This phase is expected to be very brief."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"acquiring sample rows"})}),(0,n.jsxs)(s.td,{children:["The command is currently scanning the table given by ",(0,n.jsx)(s.code,{children:"relid"})," to obtain sample rows."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"acquiring inherited sample rows"})}),(0,n.jsxs)(s.td,{children:["The command is currently scanning child tables to obtain sample rows. Columns ",(0,n.jsx)(s.code,{children:"child_tables_total"}),", ",(0,n.jsx)(s.code,{children:"child_tables_done"}),", and ",(0,n.jsx)(s.code,{children:"current_child_table_relid"})," contain the progress information for this phase."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"computing statistics"})}),(0,n.jsx)(s.td,{children:"The command is computing statistics from the sample rows obtained during the table scan."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"computing extended statistics"})}),(0,n.jsx)(s.td,{children:"The command is computing extended statistics from the sample rows obtained during the table scan."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"finalizing analyze"})}),(0,n.jsxs)(s.td,{children:["The command is updating ",(0,n.jsx)(s.code,{children:"pg_class"}),". When this phase is completed, ",(0,n.jsx)(s.code,{children:"ANALYZE"})," ends."]})]})]})]}),"\n",(0,n.jsx)(s.h2,{id:"cluster-and-vacuum-full-progress-reporting",children:"Cluster and VACUUM FULL progress reporting"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.a,{href:"/docs/next/sys-catalogs/sys-views/pg-stat-progress-cluster",children:(0,n.jsx)(s.code,{children:"pg_stat_progress_cluster"})})," system view reports the progress of running ",(0,n.jsx)(s.code,{children:"CLUSTER"}),", ",(0,n.jsx)(s.code,{children:"clusterdb"}),", and ",(0,n.jsx)(s.code,{children:"VACUUM FULL"})," (on a heap table) operations. (",(0,n.jsx)(s.code,{children:"VACUUM FULL"})," on a heap table is similar to ",(0,n.jsx)(s.code,{children:"CLUSTER"})," in that Cloudberry performs a re-write of the table.) The view displays a row per segment instance that is currently servicing any of the mentioned commands."]}),"\n",(0,n.jsxs)(s.p,{children:["For each active cluster or vacuum full operation, the ",(0,n.jsx)(s.code,{children:"gp_stat_progress_cluster_summary"})," view aggregates across the Apache Cloudberry cluster the metrics reported by ",(0,n.jsx)(s.code,{children:"gp_stat_progress_cluster"}),"."]}),"\n",(0,n.jsx)(s.h3,{id:"heap-table-cluster-phases",children:"Heap table cluster phases"}),"\n",(0,n.jsxs)(s.p,{children:["The table below describes how to interpret the ",(0,n.jsx)(s.em,{children:"heap table"})," phase-specific information reported in the views:"]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Phase"}),(0,n.jsx)(s.th,{children:"Description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"initializing"})}),(0,n.jsx)(s.td,{children:"The command is preparing to begin scanning the heap. This phase is expected to be very brief."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"seq scanning heap"})}),(0,n.jsx)(s.td,{children:"The command is currently scanning the table using a sequential scan."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"index scanning heap"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"CLUSTER"})," is currently scanning the table using an index scan."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"sorting tuples"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"CLUSTER"})," is currently sorting tuples."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"writing new heap"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"CLUSTER"})," is currently writing the new heap."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"swapping relation files"})}),(0,n.jsx)(s.td,{children:"The command is currently swapping newly-built files into place."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"rebuilding index"})}),(0,n.jsx)(s.td,{children:"The command is currently rebuilding an index."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"performing final cleanup"})}),(0,n.jsxs)(s.td,{children:["The command is performing final cleanup. When this phase is completed, ",(0,n.jsx)(s.code,{children:"CLUSTER"})," or ",(0,n.jsx)(s.code,{children:"VACUUM FULL"})," ends."]})]})]})]}),"\n",(0,n.jsx)(s.h3,{id:"aoco-table-cluster-phases",children:"Ao/co table cluster phases"}),"\n",(0,n.jsxs)(s.p,{children:["The table below describes how to interpret the ",(0,n.jsx)(s.em,{children:"AO/CO table"})," phase-specific information reported in the views:"]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Phase"}),(0,n.jsx)(s.th,{children:"Description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"initializing"})}),(0,n.jsx)(s.td,{children:"The command is preparing to begin scanning. This phase is expected to be very brief."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"seq scanning append-optimized"})}),(0,n.jsx)(s.td,{children:"The command is currently scanning the AO/CO table using a sequential scan."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"index scanning heap"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"CLUSTER"})," is currently scanning the table using an index scan."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"sorting tuples"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"CLUSTER"})," is currently sorting tuples."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"writing new append-optimized"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"CLUSTER"})," is currently writing the new AO/CO table."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"swapping relation files"})}),(0,n.jsx)(s.td,{children:"The command is currently swapping newly-built files into place."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"performing final cleanup"})}),(0,n.jsxs)(s.td,{children:["The command is performing final cleanup. When this phase is completed, ",(0,n.jsx)(s.code,{children:"CLUSTER"})," or ",(0,n.jsx)(s.code,{children:"VACUUM FULL"})," ends."]})]})]})]}),"\n",(0,n.jsx)(s.h2,{id:"copy-progress-reporting",children:"Copy progress reporting"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.a,{href:"/docs/next/sys-catalogs/sys-views/pg-stat-progress-copy",children:(0,n.jsx)(s.code,{children:"gp_stat_progress_copy"})})," system view reports the progress of running ",(0,n.jsx)(s.code,{children:"COPY"})," operations. The view displays a row per segment instance that is currently servicing a copy operation."]}),"\n",(0,n.jsxs)(s.p,{children:["For each active copy operation, the ",(0,n.jsx)(s.code,{children:"gp_stat_progress_copy_summary"})," aggregates across the Apache Cloudberry cluster the metrics reported by ",(0,n.jsx)(s.code,{children:"gp_stat_progress_copy"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["You can also use these views to monitor the data movement progress of utilities that use ",(0,n.jsx)(s.code,{children:"COPY"})," under the hood, such as ",(0,n.jsx)(s.code,{children:"gpbackup/gprestore"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["Apache Cloudberry calculates the ",(0,n.jsx)(s.code,{children:"bytes_processed"}),", ",(0,n.jsx)(s.code,{children:"bytes_total"}),", ",(0,n.jsx)(s.code,{children:"tuples_processed"}),", and ",(0,n.jsx)(s.code,{children:"tuples_excluded"})," column values differently for the ",(0,n.jsx)(s.code,{children:"gp_stat_progress_copy_summary"})," view depending on the type of table and type of ",(0,n.jsx)(s.code,{children:"COPY"})," operation. The table below identifies the table types, the types of ",(0,n.jsx)(s.code,{children:"COPY"})," operations, and which of ",(0,n.jsx)(s.code,{children:"sum()"})," or ",(0,n.jsx)(s.code,{children:"average()"})," Apache Cloudberry uses to calculate the final value:"]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Table type"}),(0,n.jsx)(s.th,{children:"COPY TO"}),(0,n.jsx)(s.th,{children:"COPY FROM"}),(0,n.jsx)(s.th,{children:"COPY TO/FROM ON SEGMENT"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Distributed table"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"sum()"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"sum()"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"sum()"})})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Replicated table"}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"sum()"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"average()"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"sum()"})})]})]})]}),"\n",(0,n.jsxs)(s.p,{children:["Cloudberry uses ",(0,n.jsx)(s.code,{children:"sum()"})," for ",(0,n.jsx)(s.code,{children:"COPY ... ON SEGMENT"})," as the command explicitly operates on each segment irrespective of the table type."]}),"\n",(0,n.jsxs)(s.p,{children:["Cloudberry uses ",(0,n.jsx)(s.code,{children:"sum()"})," for ",(0,n.jsx)(s.code,{children:"COPY TO"})," with replicated tables, as the actual copy originates from only a single segment."]}),"\n",(0,n.jsx)(s.h2,{id:"create-index-progress-reporting",children:"Create INDEX progress reporting"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.a,{href:"/docs/next/sys-catalogs/sys-views/pg-stat-progress-create-index",children:(0,n.jsx)(s.code,{children:"pg_stat_progress_create_index"})})," system view reports the progress of running ",(0,n.jsx)(s.code,{children:"CREATE INDEX"})," and ",(0,n.jsx)(s.code,{children:"REINDEX"})," operations. The view displays a row per segment instance that is currently servicing either command."]}),"\n",(0,n.jsxs)(s.p,{children:["For each active index operation, the ",(0,n.jsx)(s.code,{children:"gp_stat_progress_create_index_summary"})," view aggregates across the Apache Cloudberry cluster the metrics reported by ",(0,n.jsx)(s.code,{children:"gp_stat_progress_create_index"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"The table below describes how to interpret the phase-specific information reported in the views:"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Phase"}),(0,n.jsx)(s.th,{children:"Description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"initializing"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"CREATE INDEX"})," or ",(0,n.jsx)(s.code,{children:"REINDEX"})," is preparing to create the index. This phase is expected to be very brief."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"waiting for writers before build"})}),(0,n.jsxs)(s.td,{children:["This phase is not applicable, Apache Cloudberry does not support ",(0,n.jsx)(s.code,{children:"CREATE INDEX CONCURRENTLY"})," or ",(0,n.jsx)(s.code,{children:"REINDEX CONCURRENTLY"}),"."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"building index"})}),(0,n.jsxs)(s.td,{children:["The index is being built by the access method-specific code. In this phase, access methods that support progress reporting fill in their own progress data, and the subphase is indicated in this column. Typically, ",(0,n.jsx)(s.code,{children:"blocks_total"})," and ",(0,n.jsx)(s.code,{children:"blocks_done"})," will contain progress data, as well as potentially ",(0,n.jsx)(s.code,{children:"tuples_total"})," and ",(0,n.jsx)(s.code,{children:"tuples_done"}),"."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"waiting for writers before validation"})}),(0,n.jsxs)(s.td,{children:["This phase is not applicable, Apache Cloudberry does not support ",(0,n.jsx)(s.code,{children:"CREATE INDEX CONCURRENTLY"})," or ",(0,n.jsx)(s.code,{children:"REINDEX CONCURRENTLY"}),"."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"index validation: scanning index"})}),(0,n.jsxs)(s.td,{children:["This phase is not applicable, Apache Cloudberry does not support ",(0,n.jsx)(s.code,{children:"CREATE INDEX CONCURRENTLY"})," or ",(0,n.jsx)(s.code,{children:"REINDEX CONCURRENTLY"}),"."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"index validation: sorting tuples"})}),(0,n.jsxs)(s.td,{children:["This phase is not applicable, Apache Cloudberry does not support ",(0,n.jsx)(s.code,{children:"CREATE INDEX CONCURRENTLY"})," or ",(0,n.jsx)(s.code,{children:"REINDEX CONCURRENTLY"}),"."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"index validation: scanning table"})}),(0,n.jsxs)(s.td,{children:["This phase is not applicable, Apache Cloudberry does not support ",(0,n.jsx)(s.code,{children:"CREATE INDEX CONCURRENTLY"})," or ",(0,n.jsx)(s.code,{children:"REINDEX CONCURRENTLY"}),"."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"waiting for old snapshots"})}),(0,n.jsxs)(s.td,{children:["This phase is not applicable, Apache Cloudberry does not support ",(0,n.jsx)(s.code,{children:"CREATE INDEX CONCURRENTLY"})," or ",(0,n.jsx)(s.code,{children:"REINDEX CONCURRENTLY"}),"."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"waiting for readers before marking dead"})}),(0,n.jsxs)(s.td,{children:["This phase is not applicable, Apache Cloudberry does not support ",(0,n.jsx)(s.code,{children:"REINDEX CONCURRENTLY"}),"."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"waiting for readers before dropping"})}),(0,n.jsxs)(s.td,{children:["This phase is not applicable, Apache Cloudberry does not support ",(0,n.jsx)(s.code,{children:"REINDEX CONCURRENTLY"}),"."]})]})]})]}),"\n",(0,n.jsx)(s.p,{children:"Apache Cloudberry skips several phases because it does not support concurrent index creation or concurrent reindexing."}),"\n",(0,n.jsx)(s.h2,{id:"vacuum-progress-reporting",children:"Vacuum progress reporting"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"pg_stat_progress_vacuum"})," system view reports the progress of running ",(0,n.jsx)(s.code,{children:"VACUUM"})," and ",(0,n.jsx)(s.code,{children:"vacuumdb"})," operations on AO/CO and heap tables, and ",(0,n.jsx)(s.code,{children:"VACUUM FULL"})," operations on AO/CO tables. The view displays a row per segment instance that is currently servicing a vacuum operation."]}),"\n",(0,n.jsxs)(s.p,{children:["For each active vacuum operation, the ",(0,n.jsx)(s.code,{children:"gp_stat_progress_vacuum_summary"})," view aggregates across the Apache Cloudberry cluster the metrics reported by ",(0,n.jsx)(s.code,{children:"gp_stat_progress_vacuum"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["Regular ",(0,n.jsx)(s.code,{children:"VACUUM"})," modifies a heap table in place. ",(0,n.jsx)(s.code,{children:"VACUUM FULL"})," on a heap table rewrites the table as does a ",(0,n.jsx)(s.code,{children:"CLUSTER"})," operation. For information about progress reporting for ",(0,n.jsx)(s.code,{children:"VACUUM FULL"})," on a heap table, see ",(0,n.jsx)(s.a,{href:"#copy-progress-reporting",children:"CLUSTER and VACUUM FULL Progress Reporting"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["In Apache Cloudberry, an AO/CO table vacuum behaves differently than a heap table vacuum. Because Cloudberry stores the logical EOF for each segment file, it does not need to scan physical blocks after the logical EOF, so Cloudberry can truncate them. Cloudberry always rewrites data into new segment files to get rid of dead tuples for AO/CO tables, and performs the same operations for both ",(0,n.jsx)(s.code,{children:"VACUUM FULL"})," and ",(0,n.jsx)(s.code,{children:"VACUUM"}),". Due to these difference, Cloudberry reports vacuum progress on heap and AO/CO tables using different phases."]}),"\n",(0,n.jsx)(s.h3,{id:"heap-table-vacuum-phases",children:"Heap table vacuum phases"}),"\n",(0,n.jsxs)(s.p,{children:["The table below describes how to interpret the ",(0,n.jsx)(s.em,{children:"heap table"})," phase-specific information reported in the views:"]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Heap Table Phase"}),(0,n.jsx)(s.th,{children:"Description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"initializing"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"VACUUM"})," is preparing to begin scanning the heap. This phase is expected to be very brief."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"scanning heap"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"VACUUM"})," is currently scanning the heap. It prunes and defragment seach page if required, and possibly performs freezing activity. Use the ",(0,n.jsx)(s.code,{children:"heap_blks_scanned"})," column to monitor the progress of the scan."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"vacuuming indexes"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"VACUUM"})," is currently vacuuming the indexes. If a table has any indexes, this will happen at least once per vacuum, after the heap has been completely scanned. It may happen multiple times per vacuum if ",(0,n.jsx)(s.code,{children:"maintenance_work_mem"})," (or, in the case of autovacuum, ",(0,n.jsx)(s.code,{children:"autovacuum_work_mem"})," if set) is insufficient to store the number of dead tuples found."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"vacuuming heap"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"VACUUM"})," is currently vacuuming the heap. Vacuuming the heap is distinct from scanning the heap, and occurs after each instance of vacuuming indexes. If ",(0,n.jsx)(s.code,{children:"heap_blks_scanned"})," is less than ",(0,n.jsx)(s.code,{children:"heap_blks_total"}),", the system returns to scanning the heap after this phase is completed; otherwise, it begins cleaning up indexes after this phase is completed."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"cleaning up indexes"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"VACUUM"})," is currently cleaning up indexes. This occurs after the heap has been completely scanned and all vacuuming of the indexes and the heap has been completed."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"truncating heap"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"VACUUM"})," is currently truncating the heap so as to return empty pages at the end of the relation to the operating system. This occurs after cleaning up indexes."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"performing final cleanup"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"VACUUM"})," is performing final cleanup. During this phase, ",(0,n.jsx)(s.code,{children:"VACUUM"})," will vacuum the free space map, update statistics in ",(0,n.jsx)(s.code,{children:"pg_class"}),", and report statistics to the statistics collector. When this phase is completed, the ",(0,n.jsx)(s.code,{children:"VACUUM"})," operation ends."]})]})]})]}),"\n",(0,n.jsx)(s.h3,{id:"aoco-table-vacuum-phases",children:"Ao/co table vacuum phases"}),"\n",(0,n.jsxs)(s.p,{children:["The table below describes how to interpret the ",(0,n.jsx)(s.em,{children:"AO/CO table"})," phase-specific information reported in the views:"]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"AO/CO Table Phase"}),(0,n.jsx)(s.th,{children:"Description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"initializing"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"VACUUM"})," is preparing to begin scanning AO/CO tables. This phase is expected to be very brief."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"vacuuming indexes"})}),(0,n.jsxs)(s.td,{children:["For AO/CO tables, the ",(0,n.jsx)(s.code,{children:"vacuuming indexes"})," phase is a sub-phase that may occur during both ",(0,n.jsx)(s.code,{children:"append-optimized pre-cleanup"})," and ",(0,n.jsx)(s.code,{children:"append-optimized post-cleanup"})," phases if the relation has an index and there are invisible awaiting-drop segment files."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"append-optimized pre-cleanup"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"VACUUM"})," is performing pre-cleanup of the AO/CO table; this includes recycling ",(0,n.jsx)(s.code,{children:"AWAITING_DROP"})," segments that are no longer visible to anyone from previous ",(0,n.jsx)(s.code,{children:"VACUUM"})," operations, and truncating all live segment files to their logcial EOFs. Use ",(0,n.jsx)(s.code,{children:"heap_blks_vacuumed"})," and ",(0,n.jsx)(s.code,{children:"index_vacuum_count"})," to monitor the progress."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"append-optimized compact"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"VACUUM"}),' is vacuuming (or "compacting") the AO/CO table by scanning the segment files and rewriting only the surviving tuples into new segment files. Use ',(0,n.jsx)(s.code,{children:"heap_blks_scanned"})," and ",(0,n.jsx)(s.code,{children:"num_dead_tuples"})," to monitor the progress."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"append-optimized post-cleanup"})}),(0,n.jsxs)(s.td,{children:[(0,n.jsx)(s.code,{children:"VACUUM"}),' is performing post-cleanup of the AO/CO table; this includes recycling old segments that are no longer visible after the "compact" phase, and truncating all live segment files to their logcial EOFs. Use ',(0,n.jsx)(s.code,{children:"heap_blks_vacuumed"})," and ",(0,n.jsx)(s.code,{children:"index_vacuum_count"})," to monitor the progress."]})]})]})]}),"\n",(0,n.jsx)(s.h2,{id:"base-backup-progress-reporting",children:"Base backup progress reporting"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.a,{href:"/docs/next/sys-catalogs/sys-views/pg-stat-progress-basebackup",children:(0,n.jsx)(s.code,{children:"gp_stat_progress_basebackup"})})," system view reports the progress of running base backup operations, as is performed by ",(0,n.jsx)(s.code,{children:"gprecoverseg -F"})," (full recovery). The view displays a row per segment instance that is currently servicing replication commands."]}),"\n",(0,n.jsxs)(s.p,{children:["For each active base backup operation, the ",(0,n.jsx)(s.code,{children:"gp_stat_progress_basebackup_summary"})," view aggregates across the Apache Cloudberry cluster the metrics reported by ",(0,n.jsx)(s.code,{children:"gp_stat_progress_basebackup"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"The table below describes how to interpret the phase-specific information reported in the views:"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Phase"}),(0,n.jsx)(s.th,{children:"Description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"initializing"})}),(0,n.jsx)(s.td,{children:"The WAL sender process is preparing to begin the backup. This phase is expected to be very brief."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"waiting for checkpoint to finish"})}),(0,n.jsxs)(s.td,{children:["The WAL sender process is currently performing ",(0,n.jsx)(s.code,{children:"pg_backup_start"})," to prepare to take a base backup, and waiting for the start-of-backup checkpoint to finish."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"estimating backup size"})}),(0,n.jsx)(s.td,{children:"The WAL sender process is currently estimating the total amount of database files that will be streamed as a base backup."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"streaming database files"})}),(0,n.jsx)(s.td,{children:"The WAL sender process is currently streaming database files as a base backup."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"waiting for wal archiving to finish"})}),(0,n.jsxs)(s.td,{children:["The WAL sender process is currently performing ",(0,n.jsx)(s.code,{children:"pg_backup_stop"})," to finish the backup, and waiting for all the WAL files required for the base backup to be successfully archived. The backup ends when this phase is completed."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"transferring wal files"})}),(0,n.jsxs)(s.td,{children:["The WAL sender process is currently transferring all WAL logs generated during the backup. This phase may occur after ",(0,n.jsx)(s.code,{children:"waiting for wal archiving to finish"})," phase. The backup ends when this phase is completed."]})]})]})]}),"\n",(0,n.jsx)(s.h2,{id:"example-viewing-real-time-command-progress",children:"Example: viewing real-time command progress"}),"\n",(0,n.jsxs)(s.p,{children:["The following example commands display the real-time progress of all running ",(0,n.jsx)(s.code,{children:"VACUUM"})," commands every 0.5 seconds:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-sql",children:'host$ cat > viewer.sql << EOF\nSELECT * FROM gp_stat_progress_vacuum ORDER BY gp_segment_id;\nSELECT * FROM gp_stat_progress_vacuum_summary;\nEOF\n\nhost$ watch -n 0.5 "psql -af viewer.sql"\n'})}),"\n",(0,n.jsx)(s.h2,{id:"additional-considerations",children:"Additional considerations"}),"\n",(0,n.jsx)(s.p,{children:"Take note of these additional considerations related to progress reporting in Apache Cloudberry:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["Progress phases and their interpretation of attributes are slightly different for AO/AOCO tables and heap tables for the ",(0,n.jsx)(s.code,{children:"CREATE INDEX/REINDEX"}),", ",(0,n.jsx)(s.code,{children:"VACUUM"}),", and ",(0,n.jsx)(s.code,{children:"CLUSTER"})," operations. Refer to the individual command topics for more information."]}),"\n",(0,n.jsxs)(s.li,{children:["The progress views for an ",(0,n.jsx)(s.code,{children:"ANALYZE"})," operation on a partitioned table display the progress of each individual leaf partition. Cloudberry does not currently provide a measure of the combined progress of all partitions."]}),"\n",(0,n.jsxs)(s.li,{children:["Cloudberry does not support the ",(0,n.jsx)(s.code,{children:"CLUSTER"})," operation on a partitioned table."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},11151:(e,s,r)=>{r.d(s,{Z:()=>c,a:()=>d});var n=r(67294);const i={},t=n.createContext(i);function d(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);