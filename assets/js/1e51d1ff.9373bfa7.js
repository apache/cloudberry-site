"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[95542],{60455:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var t=r(85893),n=r(11151);const o={title:"System Configuration"},i="System Configuration Best Practices",a={id:"tutorials/best-practices/system-configuration-best-practices",title:"System Configuration",description:"Requirements and best practices for system administrators who are configuring Apache Cloudberry cluster hosts.",source:"@site/versioned_docs/version-2.x/tutorials/best-practices/system-configuration-best-practices.md",sourceDirName:"tutorials/best-practices",slug:"/tutorials/best-practices/system-configuration-best-practices",permalink:"/docs/tutorials/best-practices/system-configuration-best-practices",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/tutorials/best-practices/system-configuration-best-practices.md",tags:[],version:"2.x",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1757492265,formattedLastUpdatedAt:"Sep 10, 2025",frontMatter:{title:"System Configuration"},sidebar:"docsbars",previous:{title:"Memory and Resource Management with Resource Groups",permalink:"/docs/tutorials/best-practices/resource-group-best-practices"},next:{title:"System Monitoring and Maintenance",permalink:"/docs/tutorials/best-practices/system-monitor-and-maintain-best-practices"}},c={},l=[{value:"Configure the timezone",id:"configure-the-timezone",level:2},{value:"Configure the file system",id:"configure-the-file-system",level:2},{value:"Configure ports",id:"configure-ports",level:2},{value:"Configure I/O",id:"configure-io",level:2},{value:"Configure OS memory",id:"configure-os-memory",level:2},{value:"Configure shared memory",id:"configure-shared-memory",level:2},{value:"Determine the number of segments per host",id:"determine-the-number-of-segments-per-host",level:2},{value:"Configure resource queue segment memory",id:"configure-resource-queue-segment-memory",level:2},{value:"Configure resource queue statement memory",id:"configure-resource-queue-statement-memory",level:2},{value:"Configure resource queue spill files",id:"configure-resource-queue-spill-files",level:2}];function h(e){const s={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"system-configuration-best-practices",children:"System Configuration Best Practices"}),"\n",(0,t.jsx)(s.p,{children:"Requirements and best practices for system administrators who are configuring Apache Cloudberry cluster hosts."}),"\n",(0,t.jsx)(s.p,{children:"Configuration of the Apache Cloudberry cluster is usually performed as root."}),"\n",(0,t.jsx)(s.h2,{id:"configure-the-timezone",children:"Configure the timezone"}),"\n",(0,t.jsx)(s.p,{children:"Apache Cloudberry selects a timezone to use from a set of internally stored PostgreSQL timezones. The available PostgreSQL timezones are taken from the Internet Assigned Numbers Authority (IANA) Time Zone Database, and Apache Cloudberry updates its list of available timezones as necessary when the IANA database changes for PostgreSQL."}),"\n",(0,t.jsx)(s.p,{children:'Cloudberry selects the timezone by matching a PostgreSQL timezone with the user specified time zone, or the host system time zone if no time zone is configured. For example, when selecting a default timezone, Cloudberry uses an algorithm to select a PostgreSQL timezone based on the host system timezone files. If the system timezone includes leap second information, Apache Cloudberry cannot match the system timezone with a PostgreSQL timezone. In this case, Apache Cloudberry calculates a "best match" with a PostgreSQL timezone based on information from the host system.'}),"\n",(0,t.jsxs)(s.p,{children:['As a best practice, configure Apache Cloudberry and the host systems to use a known, supported timezone. This sets the timezone for the Apache Cloudberry coordinator and segment instances, and prevents Apache Cloudberry from recalculating a "best match" timezone each time the cluster is restarted, using the current system timezone and Cloudberry timezone files (which may have been updated from the IANA database since the last restart). Use the ',(0,t.jsx)(s.code,{children:"gpconfig"})," utility to show and set the Apache Cloudberry timezone. For example, these commands show the Apache Cloudberry timezone and set the timezone to ",(0,t.jsx)(s.code,{children:"US/Pacific"}),"."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"gpconfig -s TimeZone\ngpconfig -c TimeZone -v 'US/Pacific'\n"})}),"\n",(0,t.jsxs)(s.p,{children:["You must restart Apache Cloudberry after changing the timezone. The command ",(0,t.jsx)(s.code,{children:"gpstop -ra"})," restarts Apache Cloudberry. The catalog view ",(0,t.jsx)(s.code,{children:"pg_timezone_names"})," provides Apache Cloudberry timezone information."]}),"\n",(0,t.jsx)(s.h2,{id:"configure-the-file-system",children:"Configure the file system"}),"\n",(0,t.jsxs)(s.p,{children:["XFS is the file system used for Apache Cloudberry data directories. Use the mount options described in ",(0,t.jsx)(s.a,{href:"/docs/cbdb-op-prepare-to-deploy",children:"Configuring Your Systems"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"configure-ports",children:"Configure ports"}),"\n",(0,t.jsxs)(s.p,{children:["See the ",(0,t.jsx)(s.a,{href:"/docs/cbdb-op-prepare-to-deploy#set-system-parameters",children:"recommended OS parameter settings"})," for further details."]}),"\n",(0,t.jsxs)(s.p,{children:["Set up ",(0,t.jsx)(s.code,{children:"ip_local_port_range"})," so it does not conflict with the Apache Cloudberry port ranges. For example, setting this range in ",(0,t.jsx)(s.code,{children:"/etc/sysctl.conf"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-conf",children:"net.ipv4.ip_local_port_range = 10000  65535\n"})}),"\n",(0,t.jsx)(s.p,{children:"you could set the Apache Cloudberry base port numbers to these values."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-conf",children:"PORT_BASE = 6000\nMIRROR_PORT_BASE = 7000\n"})}),"\n",(0,t.jsxs)(s.p,{children:["See the ",(0,t.jsx)(s.a,{href:"/docs/cbdb-op-prepare-to-deploy#set-system-parameters",children:"Recommended OS Parameters Settings"})," for further details."]}),"\n",(0,t.jsx)(s.h2,{id:"configure-io",children:"Configure I/O"}),"\n",(0,t.jsxs)(s.p,{children:["Set the blockdev read-ahead size to 16384 on the devices that contain data directories. This command sets the read-ahead size for ",(0,t.jsx)(s.code,{children:"/dev/sdb"}),"."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"/sbin/blockdev --setra 16384 /dev/sdb\n"})}),"\n",(0,t.jsxs)(s.p,{children:["This command returns the read-ahead size for ",(0,t.jsx)(s.code,{children:"/dev/sdb"}),"."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"# /sbin/blockdev --getra /dev/sdb\n16384\n"})}),"\n",(0,t.jsx)(s.p,{children:"The deadline IO scheduler should be set for all data directory devices."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"# cat /sys/block/sdb/queue/scheduler\nnoop anticipatory [deadline] cfq \n"})}),"\n",(0,t.jsxs)(s.p,{children:["The maximum number of OS files and processes should be increased in the ",(0,t.jsx)(s.code,{children:"/etc/security/limits.conf"})," file."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-conf",children:"* soft  nofile 524288\n* hard  nofile 524288\n* soft  nproc 131072\n* hard  nproc 131072\n"})}),"\n",(0,t.jsx)(s.h2,{id:"configure-os-memory",children:"Configure OS memory"}),"\n",(0,t.jsxs)(s.p,{children:["The Linux sysctl ",(0,t.jsx)(s.code,{children:"vm.overcommit_memory"})," and ",(0,t.jsx)(s.code,{children:"vm.overcommit_ratio"})," variables affect how the operating system manages memory allocation."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"vm.overcommit_memory"})," determines the method the OS uses for determining how much memory can be allocated to processes. This should be always set to 2, which is the only safe setting for the database."]}),"\n",(0,t.jsxs)(s.blockquote,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Note"})," For information on configuration of overcommit memory, refer to:"]}),"\n"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"https://www.google.com/url?q=https://en.wikipedia.org/wiki/Memory_overcommitment&sa=D&ust=1499719618717000&usg=AFQjCNErcHO7vErv4pn9fIhCxrR0XRiknA",children:"https://en.wikipedia.org/wiki/Memory_overcommitment"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"https://www.google.com/url?q=https://www.kernel.org/doc/Documentation/vm/overcommit-accounting&sa=D&ust=1499719618717000&usg=AFQjCNEmu5tZutAaN1KCSlIwz4hwqihkOQ",children:"https://www.kernel.org/doc/Documentation/vm/overcommit-accounting"})}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"vm.overcommit_ratio"})," is the percent of RAM that is used for application processes. The default is 50 on Red Hat Enterprise Linux."]}),"\n",(0,t.jsx)(s.p,{children:"Do not enable huge pages in the operating system."}),"\n",(0,t.jsx)(s.h2,{id:"configure-shared-memory",children:"Configure shared memory"}),"\n",(0,t.jsxs)(s.p,{children:["Apache Cloudberry uses shared memory to communicate between ",(0,t.jsx)(s.code,{children:"postgres"})," processes that are part of the same ",(0,t.jsx)(s.code,{children:"postgres"})," instance. The following shared memory settings should be set in ",(0,t.jsx)(s.code,{children:"sysctl"})," and are rarely modified."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-conf",children:"kernel.shmmax = 810810728448\nkernel.shmmni = 4096\nkernel.shmall = 197951838\n"})}),"\n",(0,t.jsx)(s.h2,{id:"determine-the-number-of-segments-per-host",children:"Determine the number of segments per host"}),"\n",(0,t.jsx)(s.p,{children:"Determining the number of segments to run on each segment host has immense impact on overall system performance. The segments share the host's CPU cores, memory, and NICs with each other and with other processes running on the host. Over-estimating the number of segments a server can accommodate is a common cause of suboptimal performance."}),"\n",(0,t.jsx)(s.p,{children:"The factors that must be considered when choosing how many segments to run per host include the following:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Number of cores"}),"\n",(0,t.jsx)(s.li,{children:"Amount of physical RAM installed in the server"}),"\n",(0,t.jsx)(s.li,{children:"Number of NICs"}),"\n",(0,t.jsx)(s.li,{children:"Amount of storage attached to server"}),"\n",(0,t.jsx)(s.li,{children:"Mixture of primary and mirror segments"}),"\n",(0,t.jsx)(s.li,{children:"ETL processes that will run on the hosts"}),"\n",(0,t.jsx)(s.li,{children:"Non-Cloudberry processes running on the hosts"}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"configure-resource-queue-segment-memory",children:"Configure resource queue segment memory"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"gp_vmem_protect_limit"})," server configuration parameter specifies the amount of memory that all active postgres processes for a single segment can consume at any given time. Queries that exceed this amount will fail. Use the following calculations to estimate a safe value for ",(0,t.jsx)(s.code,{children:"gp_vmem_protect_limit"}),"."]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Calculate ",(0,t.jsx)(s.code,{children:"gp_vmem"}),", the host memory available to Apache Cloudberry."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"If the total system memory is less than 256 GB, use this formula:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"gp_vmem = ((SWAP + RAM) \u2013 (7.5GB + 0.05 * RAM)) / 1.7\n"})}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"If the total system memory is equal to or greater than 256 GB, use this formula:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"gp_vmem = ((SWAP + RAM) \u2013 (7.5GB + 0.05 * RAM)) / 1.17\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["where ",(0,t.jsx)(s.code,{children:"SWAP"})," is the host's swap space in GB and ",(0,t.jsx)(s.code,{children:"RAM"})," is the RAM installed on the host in GB."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Calculate ",(0,t.jsx)(s.code,{children:"max_acting_primary_segments"}),". This is the maximum number of primary segments that can be running on a host when mirror segments are activated due to a segment or host failure on another host in the cluster. With mirrors arranged in a 4-host block with 8 primary segments per host, for example, a single segment host failure would activate two or three mirror segments on each remaining host in the failed host's block. The ",(0,t.jsx)(s.code,{children:"max_acting_primary_segments"})," value for this configuration is 11 (8 primary segments plus 3 mirrors activated on failure)."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Calculate ",(0,t.jsx)(s.code,{children:"gp_vmem_protect_limit"})," by dividing the total Apache Cloudberry memory by the maximum number of acting primaries:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"gp_vmem_protect_limit = gp_vmem / max_acting_primary_segments\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Convert to megabytes to find the value to set for the ",(0,t.jsx)(s.code,{children:"gp_vmem_protect_limit"})," system configuration parameter."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["For scenarios where a large number of workfiles are generated, adjust the calculation for ",(0,t.jsx)(s.code,{children:"gp_vmem"})," to account for the workfiles."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"If the total system memory is less than 256 GB:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"gp_vmem = ((SWAP + RAM) \u2013 (7.5GB + 0.05 * RAM - (300KB * total_#_workfiles))) / 1.7\n"})}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"If the total system memory is equal to or greater than 256 GB:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"gp_vmem = ((SWAP + RAM) \u2013 (7.5GB + 0.05 * RAM - (300KB * total_#_workfiles))) / 1.17\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["You can calculate the value of the ",(0,t.jsx)(s.code,{children:"vm.overcommit_ratio"})," operating system parameter from the value of ",(0,t.jsx)(s.code,{children:"gp_vmem"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-shell",children:"vm.overcommit_ratio = (RAM - 0.026 * gp_vmem) / RAM\n"})}),"\n",(0,t.jsxs)(s.p,{children:["See ",(0,t.jsx)(s.a,{href:"#configure-os-memory",children:"OS Memory Configuration"})," for more about about ",(0,t.jsx)(s.code,{children:"vm.overcommit_ratio"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"configure-resource-queue-statement-memory",children:"Configure resource queue statement memory"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"statement_mem"})," server configuration parameter is the amount of memory to be allocated to any single query in a segment database. If a statement requires additional memory it will spill to disk. Calculate the value for ",(0,t.jsx)(s.code,{children:"statement_mem"})," with the following formula:"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(gp_vmem_protect_limit * .9) / max_expected_concurrent_queries"})}),"\n",(0,t.jsxs)(s.p,{children:["For example, for 40 concurrent queries with ",(0,t.jsx)(s.code,{children:"gp_vmem_protect_limit"})," set to 8GB (8192MB), the calculation for ",(0,t.jsx)(s.code,{children:"statement_mem"})," would be:"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(8192MB * .9) / 40 = 184MB"})}),"\n",(0,t.jsx)(s.p,{children:"Each query would be allowed 184MB of memory before it must spill to disk."}),"\n",(0,t.jsxs)(s.p,{children:["To increase ",(0,t.jsx)(s.code,{children:"statement_mem"})," safely you must either increase ",(0,t.jsx)(s.code,{children:"gp_vmem_protect_limit"})," or reduce the number of concurrent queries. To increase ",(0,t.jsx)(s.code,{children:"gp_vmem_protect_limit"}),", you must add physical RAM and/or swap space, or reduce the number of segments per host."]}),"\n",(0,t.jsx)(s.p,{children:"Note that adding segment hosts to the cluster cannot help out-of-memory errors unless you use the additional hosts to decrease the number of segments per host."}),"\n",(0,t.jsx)(s.p,{children:"Spill files are created when there is not enough memory to fit all the mapper output, usually when 80% of the buffer space is occupied."}),"\n",(0,t.jsx)(s.h2,{id:"configure-resource-queue-spill-files",children:"Configure resource queue spill files"}),"\n",(0,t.jsxs)(s.p,{children:["Apache Cloudberry creates ",(0,t.jsx)(s.em,{children:"spill files"})," (also called ",(0,t.jsx)(s.em,{children:"workfiles"}),") on disk if a query is allocated insufficient memory to run in memory. A single query can create no more than 100,000 spill files, by default, which is sufficient for the majority of queries."]}),"\n",(0,t.jsxs)(s.p,{children:["You can control the maximum number of spill files created per query and per segment with the configuration parameter ",(0,t.jsx)(s.code,{children:"gp_workfile_limit_files_per_query"}),". Set the parameter to 0 to allow queries to create an unlimited number of spill files. Limiting the number of spill files permitted prevents run-away queries from disrupting the system."]}),"\n",(0,t.jsx)(s.p,{children:"A query could generate a large number of spill files if not enough memory is allocated to it or if data skew is present in the queried data. If a query creates more than the specified number of spill files, Apache Cloudberry returns this error:"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"ERROR: number of workfiles per query limit exceeded"})}),"\n",(0,t.jsxs)(s.p,{children:["Before raising the ",(0,t.jsx)(s.code,{children:"gp_workfile_limit_files_per_query"}),", try reducing the number of spill files by changing the query, changing the data distribution, or changing the memory configuration."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"gp_toolkit"})," schema includes views that allow you to see information about all the queries that are currently using spill files. This information can be used for troubleshooting and for tuning queries:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["The ",(0,t.jsx)(s.code,{children:"gp_workfile_entries"})," view contains one row for each operator using disk space for workfiles on a segment at the current time. See ",(0,t.jsx)(s.a,{href:"tuning_queries.html",children:"How to Read Explain Plans"})," for information about operators."]}),"\n",(0,t.jsxs)(s.li,{children:["The ",(0,t.jsx)(s.code,{children:"gp_workfile_usage_per_query"})," view contains one row for each query using disk space for workfiles on a segment at the current time."]}),"\n",(0,t.jsxs)(s.li,{children:["The ",(0,t.jsx)(s.code,{children:"gp_workfile_usage_per_segment"})," view contains one row for each segment. Each row displays the total amount of disk space used for workfiles on the segment at the current time."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"gp_workfile_compression"})," configuration parameter specifies whether the spill files are compressed. It is ",(0,t.jsx)(s.code,{children:"off"})," by default. Enabling compression can improve performance when spill files are used."]})]})}function m(e={}){const{wrapper:s}={...(0,n.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},11151:(e,s,r)=>{r.d(s,{Z:()=>a,a:()=>i});var t=r(67294);const n={},o=t.createContext(n);function i(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);