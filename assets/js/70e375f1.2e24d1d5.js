"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[90191],{44464:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var t=s(85893),o=s(11151);const a={title:"Expression Evaluation Rules"},r="Expression Evaluation Rules",i={id:"operate-with-data/sql-queries/evaluation-order",title:"Expression Evaluation Rules",description:"The order of evaluation of subexpressions is undefined. The inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order.",source:"@site/docs/operate-with-data/sql-queries/evaluation-order.md",sourceDirName:"operate-with-data/sql-queries",slug:"/operate-with-data/sql-queries/evaluation-order",permalink:"/docs/next/operate-with-data/sql-queries/evaluation-order",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/operate-with-data/sql-queries/evaluation-order.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1757492265,formattedLastUpdatedAt:"Sep 10, 2025",frontMatter:{title:"Expression Evaluation Rules"},sidebar:"docsbars",previous:{title:"Table and Column Aliases",permalink:"/docs/next/operate-with-data/sql-queries/table-and-column-aliases"},next:{title:"Value Expressions",permalink:"/docs/next/operate-with-data/sql-queries/value-expressions"}},l={},c=[];function d(e){const n={code:"code",h1:"h1",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"expression-evaluation-rules",children:"Expression Evaluation Rules"}),"\n",(0,t.jsx)(n.p,{children:"The order of evaluation of subexpressions is undefined. The inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order."}),"\n",(0,t.jsx)(n.p,{children:"If you can determine the result of an expression by evaluating only some parts of the expression, then other subexpressions might not be evaluated at all. For example, in the following expression:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT true OR somefunc();\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"somefunc()"})," would probably not be called at all. The same is true in the following expression:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT somefunc() OR true;\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is not the same as the left-to-right evaluation order that Boolean operators enforce in some programming languages."}),"\n",(0,t.jsxs)(n.p,{children:["Do not use functions with side effects as part of complex expressions, especially in ",(0,t.jsx)(n.code,{children:"WHERE"})," and ",(0,t.jsx)(n.code,{children:"HAVING"})," clauses, because those clauses are extensively reprocessed when developing an execution plan. Boolean expressions (",(0,t.jsx)(n.code,{children:"AND"}),"/",(0,t.jsx)(n.code,{children:"OR"}),"/",(0,t.jsx)(n.code,{children:"NOT"})," combinations) in those clauses can be reorganized in any manner that Boolean algebra laws allow."]}),"\n",(0,t.jsxs)(n.p,{children:["Use a ",(0,t.jsx)(n.code,{children:"CASE"})," construct to force evaluation order. The following example is an untrustworthy way to avoid division by zero in a ",(0,t.jsx)(n.code,{children:"WHERE"})," clause:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT ... WHERE x <> 0 AND y/x > 1.5;\n"})}),"\n",(0,t.jsx)(n.p,{children:"The following example shows a trustworthy evaluation order:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT ... WHERE CASE WHEN x <> 0 THEN y/x > 1.5 ELSE false \nEND;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This ",(0,t.jsx)(n.code,{children:"CASE"})," construct usage defeats optimization attempts; use it only when necessary."]})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>i,a:()=>r});var t=s(67294);const o={},a=t.createContext(o);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);