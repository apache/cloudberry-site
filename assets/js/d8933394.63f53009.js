"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[96674],{80432:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});var o=s(85893),r=s(11151);const l={title:"Join Queries"},i="Join Queries",t={id:"join-queries",title:"Join Queries",description:"In Apache Cloudberry, the JOIN clause combines rows from two or more tables based on related column values. The JOIN clause is part of the FROM clause in a SELECT statement.",source:"@site/versioned_docs/version-2.x/join-queries.md",sourceDirName:".",slug:"/join-queries",permalink:"/docs/join-queries",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/join-queries.md",tags:[],version:"2.x",lastUpdatedBy:"TomShawn",lastUpdatedAt:1748250627,formattedLastUpdatedAt:"May 26, 2025",frontMatter:{title:"Join Queries"},sidebar:"docsbars",previous:{title:"Concurrency Control for Transactions",permalink:"/docs/transactional-concurrency-control"},next:{title:"Choose the Table Storage Model",permalink:"/docs/table-storage-models"}},c={},d=[{value:"Join types",id:"join-types",level:2},{value:"LEFT OUTER JOIN",id:"left-outer-join",level:3},{value:"RIGHT OUTER JOIN",id:"right-outer-join",level:3},{value:"FULL OUTER JOIN",id:"full-outer-join",level:3},{value:"CROSS JOIN",id:"cross-join",level:3},{value:"NATURAL JOIN",id:"natural-join",level:3},{value:"Join conditions",id:"join-conditions",level:2},{value:"ON clause",id:"on-clause",level:3},{value:"USING clause",id:"using-clause",level:3},{value:"LATERAL",id:"lateral",level:2},{value:"Example",id:"example",level:2},{value:"INNER JOIN example",id:"inner-join-example",level:3},{value:"LEFT OUTER JOIN example",id:"left-outer-join-example",level:3},{value:"RIGHT OUTER JOIN example",id:"right-outer-join-example",level:3},{value:"FULL OUTER JOIN example",id:"full-outer-join-example",level:3},{value:"CROSS JOIN example",id:"cross-join-example",level:3}];function a(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"join-queries",children:"Join Queries"}),"\n",(0,o.jsxs)(n.p,{children:["In Apache Cloudberry, the ",(0,o.jsx)(n.code,{children:"JOIN"})," clause combines rows from two or more tables based on related column values. The ",(0,o.jsx)(n.code,{children:"JOIN"})," clause is part of the ",(0,o.jsx)(n.code,{children:"FROM"})," clause in a ",(0,o.jsx)(n.code,{children:"SELECT"})," statement."]}),"\n",(0,o.jsxs)(n.p,{children:["The syntax for the ",(0,o.jsx)(n.code,{children:"JOIN"})," clause is as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"table1_name join_type table2_name [join_condition]\n"})}),"\n",(0,o.jsx)(n.p,{children:"Where:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"table1_name"}),", ",(0,o.jsx)(n.code,{children:"table2_name"}),": Names of the tables to be joined."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"join_type"}),": The type of join, which can be one of the following:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"[INNER] JOIN"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"LEFT [OUTER] JOIN"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"RIGHT [OUTER] JOIN"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"FULL [OUTER] JOIN"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"NATURAL JOIN"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"join_condition"}),": An optional condition that specifies how to match rows from the two tables. It can take one of the following forms:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"ON <join_condition>"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"USING ( <join_column> [, ...] )"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"LATERAL"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["For ",(0,o.jsx)(n.code,{children:"FULL JOIN"})," queries, the ORCA optimizer automatically chooses between ",(0,o.jsx)(n.code,{children:"Merge Join"})," and ",(0,o.jsx)(n.code,{children:"Hash Join"})," based on cost estimates, so users do not need to manually specify the join method."]})}),"\n",(0,o.jsx)(n.h2,{id:"join-types",children:"Join types"}),"\n",(0,o.jsx)(n.p,{children:"Apache Cloudberry supports the following types of joins:"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"INNER JOIN"})," returns the intersection of rows from both tables that satisfy the join condition. In other words, it returns only the rows with matching values in both tables. If ",(0,o.jsx)(n.code,{children:"INNER"})," is omitted before ",(0,o.jsx)(n.code,{children:"JOIN"}),", it defaults to ",(0,o.jsx)(n.code,{children:"INNER JOIN"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM table1\nINNER JOIN table2\nON table1.column_name = table2.column_name;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"left-outer-join",children:"LEFT OUTER JOIN"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"LEFT OUTER JOIN"})," (or simply ",(0,o.jsx)(n.code,{children:"LEFT JOIN"}),") returns all rows from the left table and the matching rows from the right table. If there is no match in the right table, the result includes ",(0,o.jsx)(n.code,{children:"NULL"})," values for columns from the right table."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM table1\nLEFT OUTER JOIN table2\nON table1.column_name = table2.column_name;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"right-outer-join",children:"RIGHT OUTER JOIN"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"RIGHT OUTER JOIN"})," (or simply ",(0,o.jsx)(n.code,{children:"RIGHT JOIN"}),") is the opposite of ",(0,o.jsx)(n.code,{children:"LEFT OUTER JOIN"}),". It returns all rows from the right table and the matching rows from the left table. If there is no match in the left table, the result includes ",(0,o.jsx)(n.code,{children:"NULL"})," values for columns from the left table."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM table1\nRIGHT OUTER JOIN table2\nON table1.column_name = table2.column_name;\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Starting from v2.0.0, ",(0,o.jsx)(n.code,{children:"Hash Right Join"})," queries can also trigger dynamic partition elimination (DPE) when partition pruning conditions are met, reducing partition scans and improving performance."]})}),"\n",(0,o.jsx)(n.h3,{id:"full-outer-join",children:"FULL OUTER JOIN"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"FULL OUTER JOIN"})," (or simply ",(0,o.jsx)(n.code,{children:"FULL JOIN"}),") returns all rows from both the left and right tables. For unmatched rows in the left table, the right table columns are filled with ",(0,o.jsx)(n.code,{children:"NULL"}),". For unmatched rows in the right table, the left table columns are filled with ",(0,o.jsx)(n.code,{children:"NULL"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM table1\nFULL OUTER JOIN table2\nON table1.column_name = table2.column_name;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"cross-join",children:"CROSS JOIN"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"CROSS JOIN"})," returns the Cartesian product of two tables. It combines every row from the left table with every row from the right table. If there is no ",(0,o.jsx)(n.code,{children:"WHERE"})," clause to filter the results, the output will contain the number of rows in the left table multiplied by the number of rows in the right table."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM table1\nCROSS JOIN table2;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"natural-join",children:"NATURAL JOIN"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"NATURAL"})," clause is a further shorthand for the ",(0,o.jsx)(n.code,{children:"USING"})," clause. It is used when all columns with the same names in both tables should be used for the join. If there are no columns with the same names, ",(0,o.jsx)(n.code,{children:"NATURAL JOIN"})," behaves like a ",(0,o.jsx)(n.code,{children:"CROSS JOIN"}),". Use ",(0,o.jsx)(n.code,{children:"NATURAL JOIN"})," with caution, as it relies on column names and may produce unexpected results."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM table1\nNATURAL JOIN table2;\n"})}),"\n",(0,o.jsx)(n.h2,{id:"join-conditions",children:"Join conditions"}),"\n",(0,o.jsx)(n.p,{children:"Join conditions define how to match rows between two tables. There are three types of join conditions:"}),"\n",(0,o.jsx)(n.h3,{id:"on-clause",children:"ON clause"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"ON"})," clause specifies a Boolean expression that determines which rows from the two tables should be considered a match. It works similarly to a ",(0,o.jsx)(n.code,{children:"WHERE"})," clause but is applied specifically to the ",(0,o.jsx)(n.code,{children:"JOIN"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM table1\nJOIN table2\nON table1.column_name = table2.column_name;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"using-clause",children:"USING clause"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"USING"})," clause is a shorthand for the ",(0,o.jsx)(n.code,{children:"ON"})," clause when both tables have one or more columns with the same name. It specifies the common column(s) to be used for the join. The result includes only one instance of each matched column, instead of both."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT *\nFROM table1\nJOIN table2\nUSING (column_name);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"lateral",children:"LATERAL"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"LATERAL"})," keyword can be placed before a subquery in the ",(0,o.jsx)(n.code,{children:"FROM"})," clause. It allows the subquery to reference columns from preceding items in the ",(0,o.jsx)(n.code,{children:"FROM"})," list. Without ",(0,o.jsx)(n.code,{children:"LATERAL"}),", Apache Cloudberry evaluates subqueries independently and does not allow references to other ",(0,o.jsx)(n.code,{children:"FROM"})," items."]}),"\n",(0,o.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,o.jsxs)(n.p,{children:["Assume there are two tables: ",(0,o.jsx)(n.code,{children:"customers"})," and ",(0,o.jsx)(n.code,{children:"orders"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"customers"})," table:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"customer_id | customer_name\n------------+---------------\n1           | John Doe\n2           | Jane Smith\n3           | Bob Johnson\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"orders"})," table:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"order_id | customer_id | order_date\n---------+-------------+------------\n1        | 1           | 2023-01-15\n2        | 2           | 2023-02-20\n3        | 1           | 2023-03-10\n4        | 4           | 2024-05-01\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here are some examples using different ",(0,o.jsx)(n.code,{children:"JOIN"})," types:"]}),"\n",(0,o.jsx)(n.h3,{id:"inner-join-example",children:"INNER JOIN example"}),"\n",(0,o.jsx)(n.p,{children:"This query returns all customers and their orders, including only rows where the customer ID matches in both tables."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT customers.customer_name, orders.order_id\nFROM customers\nINNER JOIN orders\nON customers.customer_id = orders.customer_id;\n"})}),"\n",(0,o.jsx)(n.p,{children:"Result:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"customer_name | order_id\n--------------+----------\nJohn Doe      | 1\nJane Smith    | 2\nJohn Doe      | 3\n"})}),"\n",(0,o.jsx)(n.h3,{id:"left-outer-join-example",children:"LEFT OUTER JOIN example"}),"\n",(0,o.jsx)(n.p,{children:"This query returns all customers along with their orders. Even if a customer has no orders, the customer information will still be included."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT customers.customer_name, orders.order_id\nFROM customers\nLEFT OUTER JOIN orders\nON customers.customer_id = orders.customer_id;\n"})}),"\n",(0,o.jsx)(n.p,{children:"Result:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"customer_name | order_id\n--------------+----------\nJohn Doe      | 1\nJane Smith    | 2\nBob Johnson   | NULL\nJohn Doe      | 3\n"})}),"\n",(0,o.jsx)(n.h3,{id:"right-outer-join-example",children:"RIGHT OUTER JOIN example"}),"\n",(0,o.jsxs)(n.p,{children:["This query returns all orders along with the customers who placed them. Even if an order has no associated customer, the order will still be included. In this example, the order with ",(0,o.jsx)(n.code,{children:"order_id"})," 4 has no matching customer."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT customers.customer_name, orders.order_id\nFROM customers\nRIGHT OUTER JOIN orders\nON customers.customer_id = orders.customer_id;\n"})}),"\n",(0,o.jsx)(n.p,{children:"Result:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"customer_name | order_id\n--------------+----------\nJohn Doe      | 1\nJane Smith    | 2\nJohn Doe      | 3\nNULL          | 4\n"})}),"\n",(0,o.jsx)(n.h3,{id:"full-outer-join-example",children:"FULL OUTER JOIN example"}),"\n",(0,o.jsx)(n.p,{children:"This query returns all customers and all orders. If a customer has no orders or an order has no customer, the result will still include that customer or order."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT customers.customer_name, orders.order_id\nFROM customers\nFULL OUTER JOIN orders\nON customers.customer_id = orders.customer_id;\n"})}),"\n",(0,o.jsx)(n.p,{children:"Result:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"customer_name | order_id\n--------------+----------\nJohn Doe      | 1\nJane Smith    | 2\nBob Johnson   | NULL\nJohn Doe      | 3\nNULL          | 4\n"})}),"\n",(0,o.jsx)(n.h3,{id:"cross-join-example",children:"CROSS JOIN example"}),"\n",(0,o.jsx)(n.p,{children:"This query returns the Cartesian product of the customers and orders tables."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT customers.customer_name, orders.order_id\nFROM customers\nCROSS JOIN orders;\n"})}),"\n",(0,o.jsx)(n.p,{children:"Result (partial output; a total of 3 \xd7 4 = 12 rows):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"customer_name | order_id\n--------------+----------\nJohn Doe      | 1\nJohn Doe      | 2\nJohn Doe      | 3\nJohn Doe      | 4\nJane Smith    | 1\nJane Smith    | 2\n...\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>t,a:()=>i});var o=s(67294);const r={},l=o.createContext(r);function i(e){const n=o.useContext(l);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);