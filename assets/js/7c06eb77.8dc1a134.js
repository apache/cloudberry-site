"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[97202],{73219:(e,s,d)=>{d.r(s),d.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>n,metadata:()=>l,toc:()=>a});var t=d(85893),i=d(11151);const n={title:"pg_class"},r="pg_class",l={id:"sys-catalogs/sys-tables/pg-class",title:"pg_class",description:'The system catalog table pgclass catalogs tables and most everything else that has columns or is otherwise similar to a table. This includes indexes (see also pgindex), sequences, views, materialized views, composite types, and TOAST tables. Below, when we mean all of these kinds of objects we speak of "relations". Not all columns are meaningful for all relation types.',source:"@site/docs/sys-catalogs/sys-tables/pg-class.md",sourceDirName:"sys-catalogs/sys-tables",slug:"/sys-catalogs/sys-tables/pg-class",permalink:"/docs/next/sys-catalogs/sys-tables/pg-class",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sys-catalogs/sys-tables/pg-class.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1749608415,formattedLastUpdatedAt:"Jun 11, 2025",frontMatter:{title:"pg_class"},sidebar:"docsbars",previous:{title:"pg_cast",permalink:"/docs/next/sys-catalogs/sys-tables/pg-cast"},next:{title:"pg_namespace",permalink:"/docs/next/sys-catalogs/sys-tables/pg-namespace"}},c={},a=[];function o(e){const s={code:"code",h1:"h1",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"pg_class",children:"pg_class"}),"\n",(0,t.jsxs)(s.p,{children:["The system catalog table ",(0,t.jsx)(s.code,{children:"pg_class"})," catalogs tables and most everything else that has columns or is otherwise similar to a table. This includes indexes (see also ",(0,t.jsx)(s.code,{children:"pg_index"}),'), sequences, views, materialized views, composite types, and TOAST tables. Below, when we mean all of these kinds of objects we speak of "relations". Not all columns are meaningful for all relation types.']}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"column"}),(0,t.jsx)(s.th,{children:"type"}),(0,t.jsx)(s.th,{children:"references"}),(0,t.jsx)(s.th,{children:"description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"oid"})}),(0,t.jsx)(s.td,{children:"oid"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsx)(s.td,{children:"Row identifier"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relname"})}),(0,t.jsx)(s.td,{children:"name"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsx)(s.td,{children:"Name of the table, index, view."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relnamespace"})}),(0,t.jsx)(s.td,{children:"oid"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pg_namespace.oid"})}),(0,t.jsx)(s.td,{children:"The object identifier of the namespace (schema) that contains this relation"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"reltype"})}),(0,t.jsx)(s.td,{children:"oid"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pg_type.oid"})}),(0,t.jsxs)(s.td,{children:["The object identifier of the data type that corresponds to this table's row type, if any (zero for indexes, which have no ",(0,t.jsx)(s.code,{children:"pg_type"})," entry)"]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"reloftype"})}),(0,t.jsx)(s.td,{children:"oid"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pg_type.oid"})}),(0,t.jsx)(s.td,{children:"For typed tables, the object identifier of the underlying composite type, zero for all other relations"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relowner"})}),(0,t.jsx)(s.td,{children:"oid"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pg_authid.oid"})}),(0,t.jsx)(s.td,{children:"Owner of the relation"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relam"})}),(0,t.jsx)(s.td,{children:"oid"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pg_am.oid"})}),(0,t.jsx)(s.td,{children:"If this is a table or an index, the access method used (heap, B-tree, hash.)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relfilenode"})}),(0,t.jsx)(s.td,{children:"bigint"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsx)(s.td,{children:'Name of the on-disk file of this relation; zero means this is a "mapped" relation whose disk file name is determined by low-level state'})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"reltablespace"})}),(0,t.jsx)(s.td,{children:"oid"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pg_tablespace.oid"})}),(0,t.jsx)(s.td,{children:"The tablespace in which this relation is stored. If zero, the database's default tablespace is implied. (Not meaningful if the relation has no on-disk file.)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relpages"})}),(0,t.jsx)(s.td,{children:"int4"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["Size of the on-disk representation of this table in pages (of size ",(0,t.jsx)(s.code,{children:"BLCKSZ"}),"). This is only an estimate used by the planner. It is updated by ",(0,t.jsx)(s.code,{children:"VACUUM"}),", ",(0,t.jsx)(s.code,{children:"ANALYZE"}),", and a few DDL commands such as ",(0,t.jsx)(s.code,{children:"CREATE INDEX"}),"."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"reltuples"})}),(0,t.jsx)(s.td,{children:"real"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["Number of rows in the table. This is only an estimate used by the planner. It is updated by ",(0,t.jsx)(s.code,{children:"VACUUM"}),", ",(0,t.jsx)(s.code,{children:"ANALYZE"}),", and a few DDL commands such as ",(0,t.jsx)(s.code,{children:"CREATE INDEX"}),"."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relallvisible"})}),(0,t.jsx)(s.td,{children:"int4"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["Number of pages that are marked all-visible in the table's visibility map. This is only an estimate used by the planner. It is updated by ",(0,t.jsx)(s.code,{children:"VACUUM"}),", ",(0,t.jsx)(s.code,{children:"ANALYZE"}),", and a few DDL commands such as ",(0,t.jsx)(s.code,{children:"CREATE INDEX"}),"."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"reltoastrelid"})}),(0,t.jsx)(s.td,{children:"oid"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pg_class.oid"})}),(0,t.jsxs)(s.td,{children:["The object identifier of the TOAST table associated with this table, ",(0,t.jsx)(s.code,{children:"0"}),' if none. The TOAST table stores large attributes "out of line" in a secondary table.']})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relhasindex"})}),(0,t.jsx)(s.td,{children:"boolean"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsx)(s.td,{children:"True if this is a table and it has (or recently had) any indexes."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relisshared"})}),(0,t.jsx)(s.td,{children:"boolean"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["True if this table is shared across all databases in the system. Only certain system catalog tables (such as ",(0,t.jsx)(s.code,{children:"pg_database"}),") are shared."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relpersistence"})}),(0,t.jsx)(s.td,{children:"char"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["The type of object persistence: ",(0,t.jsx)(s.code,{children:"p"})," = heap or append-optimized permanent table, ",(0,t.jsx)(s.code,{children:"u"})," = unlogged temporary table, ",(0,t.jsx)(s.code,{children:"t"})," = temporary table."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relkind"})}),(0,t.jsx)(s.td,{children:"char"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["The type of object",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),(0,t.jsx)(s.code,{children:"r"})," = heap or append-optimized ordinary table, ",(0,t.jsx)(s.code,{children:"i"})," = index, ",(0,t.jsx)(s.code,{children:"S"})," = sequence, ",(0,t.jsx)(s.code,{children:"t"})," = TOAST table, ",(0,t.jsx)(s.code,{children:"v"})," = view, ",(0,t.jsx)(s.code,{children:"m"})," = materialized view, ",(0,t.jsx)(s.code,{children:"c"})," = composite type, ",(0,t.jsx)(s.code,{children:"f"})," = foreign table, ",(0,t.jsx)(s.code,{children:"p"})," = partitioned table, ",(0,t.jsx)(s.code,{children:"I"})," = partitioned index, ",(0,t.jsx)(s.code,{children:"u"})," = uncatalogued temporary heap table, ",(0,t.jsx)(s.code,{children:"o"})," = internal append-optimized segment files and EOFs, ",(0,t.jsx)(s.code,{children:"b"})," = append-only block directory, ",(0,t.jsx)(s.code,{children:"M"})," = append-only visibility map."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relnatts"})}),(0,t.jsx)(s.td,{children:"int2"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["Number of user columns in the relation (system columns not counted). There must be this many corresponding entries in ",(0,t.jsx)(s.code,{children:"pg_attribute"}),". See also ",(0,t.jsx)(s.code,{children:"pg_attribute.attnum"}),"."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relchecks"})}),(0,t.jsx)(s.td,{children:"int2"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["Number of ",(0,t.jsx)(s.code,{children:"CHECK"})," constraints on the table; see ",(0,t.jsx)(s.code,{children:"pg_constraint"})," catalog."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relhasrules"})}),(0,t.jsx)(s.td,{children:"boolean"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["True if table has (or once had) rules; see ",(0,t.jsx)(s.code,{children:"pg_rewrite"})," catalog."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relhastriggers"})}),(0,t.jsx)(s.td,{children:"boolean"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsx)(s.td,{children:"True if table has (or once had) triggers."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relhassubclass"})}),(0,t.jsx)(s.td,{children:"boolean"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsx)(s.td,{children:"True if table has (or once had) any inheritance children."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relrowsecurity"})}),(0,t.jsx)(s.td,{children:"boolean"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["True if table has row level security enabled; see ",(0,t.jsx)(s.code,{children:"pg_policy"})," catalog."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relforcerowsecurity"})}),(0,t.jsx)(s.td,{children:"boolean"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["True if row level security (when enabled) will also apply to the table owner; see ",(0,t.jsx)(s.code,{children:"pg_policy"})," catalog."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relispopulated"})}),(0,t.jsx)(s.td,{children:"boolean"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsx)(s.td,{children:"True if relation is populated (this is true for all relations other than some materialized views)."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relreplident"})}),(0,t.jsx)(s.td,{children:"char"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:['Columns used to form "replica identity" for rows: ',(0,t.jsx)(s.code,{children:"d"})," = default (primary key, if any), ",(0,t.jsx)(s.code,{children:"n"})," = nothing, ",(0,t.jsx)(s.code,{children:"f"})," = all columns, ",(0,t.jsx)(s.code,{children:"i"})," = index with ",(0,t.jsx)(s.code,{children:"indisreplident"})," set (same as nothing if the index used has been dropped)."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relispartition"})}),(0,t.jsx)(s.td,{children:"boolean"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsx)(s.td,{children:"True if table or index is a partition."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relrewrite"})}),(0,t.jsx)(s.td,{children:"oid"}),(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"pg_class.oid"}),"\xa0"]}),(0,t.jsx)(s.td,{children:"For new relations being written during a DDL operation that requires a table rewrite, this contains the object identifier of the original relation; otherwise 0. That state is only visible internally; this field should never contain anything other than 0 for a user-visible relation."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relfrozenxid"})}),(0,t.jsx)(s.td,{children:"xid"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["All transaction IDs before this one have been replaced with a permanent (frozen) transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent transaction ID wraparound or to allow ",(0,t.jsx)(s.code,{children:"pg_xact"})," to be shrunk.",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"The value is ",(0,t.jsx)(s.code,{children:"0"})," (",(0,t.jsx)(s.code,{children:"InvalidTransactionId"}),") if the relation is not a table or if the table does not require vacuuming to prevent transaction ID wraparound. The table still might require vacuuming to reclaim disk space."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relminmxid"})}),(0,t.jsx)(s.td,{children:"xid"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["All multixact IDs before this one have been replaced by a transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent multixact ID wraparound or to allow ",(0,t.jsx)(s.code,{children:"pg_multixact"})," to be shrunk. Zero (",(0,t.jsx)(s.code,{children:"InvalidMultiXactId"}),") if the relation is not a table."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relacl"})}),(0,t.jsx)(s.td,{children:"aclitem[]"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["Access privileges assigned by ",(0,t.jsx)(s.code,{children:"GRANT"})," and ",(0,t.jsx)(s.code,{children:"REVOKE"}),"."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"reloptions"})}),(0,t.jsx)(s.td,{children:"text[]"}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsx)(s.td,{children:'Access-method-specific options, as "keyword=value" strings.'})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"relpartbound"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"pg_node_tree"})}),(0,t.jsx)(s.td,{children:"\xa0"}),(0,t.jsxs)(s.td,{children:["If table is a partition (see ",(0,t.jsx)(s.code,{children:"relispartition"}),"), internal representation of the partition bound."]})]})]})]}),"\n",(0,t.jsxs)(s.p,{children:["Several of the Boolean flags in ",(0,t.jsx)(s.code,{children:"pg_class"})," are maintained lazily: they are guaranteed to be true if that's the correct state, but might not be reset to false immediately when the condition is no longer true. For example, ",(0,t.jsx)(s.code,{children:"relhasindex"})," is set by ",(0,t.jsx)(s.code,{children:"CREATE INDEX"}),", but it is never cleared by ",(0,t.jsx)(s.code,{children:"DROP INDEX"}),". Instead, ",(0,t.jsx)(s.code,{children:"VACUUM"})," clears ",(0,t.jsx)(s.code,{children:"relhasindex"})," if it finds the table has no indexes. This arrangement avoids race conditions and improves concurrency."]})]})}function h(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},11151:(e,s,d)=>{d.d(s,{Z:()=>l,a:()=>r});var t=d(67294);const i={},n=t.createContext(i);function r(e){const s=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(n.Provider,{value:s},e.children)}}}]);