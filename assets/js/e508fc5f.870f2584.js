"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[69188],{26008:(e,a,o)=>{o.r(a),o.d(a,{assets:()=>d,contentTitle:()=>s,default:()=>p,frontMatter:()=>n,metadata:()=>i,toc:()=>l});var t=o(85893),r=o(11151);const n={title:"Heap and AO Table Formats"},s="Heap and AO Table Formats",i={id:"operate-with-data/heap-and-ao-table-formats",title:"Heap and AO Table Formats",description:"Apache Cloudberry supports two storage models: Heap storage and Appended-Optimized (AO) storage. The choice of storage model should be determined based on your data type and query type. This document introduces both storage models and provides recommendations for selecting the optimal one.",source:"@site/versioned_docs/version-2.x/operate-with-data/heap-and-ao-table-formats.md",sourceDirName:"operate-with-data",slug:"/operate-with-data/heap-and-ao-table-formats",permalink:"/docs/operate-with-data/heap-and-ao-table-formats",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/operate-with-data/heap-and-ao-table-formats.md",tags:[],version:"2.x",lastUpdatedBy:"GEV00",lastUpdatedAt:1754448784,formattedLastUpdatedAt:"Aug 6, 2025",frontMatter:{title:"Heap and AO Table Formats"},sidebar:"docsbars",previous:{title:"Use pgvector for Vector Similarity Search",permalink:"/docs/advanced-analytics/pgvector-search"},next:{title:"PAX Storage Format",permalink:"/docs/operate-with-data/pax-table-format"}},d={},l=[{value:"Heap storage",id:"heap-storage",level:2},{value:"Append-optimized storage",id:"append-optimized-storage",level:2},{value:"To create a heap table",id:"to-create-a-heap-table",level:3},{value:"Choose row or column-oriented storage",id:"choose-row-or-column-oriented-storage",level:2},{value:"To create a column-oriented table",id:"to-create-a-column-oriented-table",level:3}];function c(e){const a={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.h1,{id:"heap-and-ao-table-formats",children:"Heap and AO Table Formats"}),"\n",(0,t.jsx)(a.p,{children:"Apache Cloudberry supports two storage models: Heap storage and Appended-Optimized (AO) storage. The choice of storage model should be determined based on your data type and query type. This document introduces both storage models and provides recommendations for selecting the optimal one."}),"\n",(0,t.jsx)(a.h2,{id:"heap-storage",children:"Heap storage"}),"\n",(0,t.jsxs)(a.p,{children:["By default, Apache Cloudberry uses the same heap storage model as PostgreSQL. Heap table storage works best with OLTP-type workloads where the data is often modified after it is initially loaded. ",(0,t.jsx)(a.code,{children:"UPDATE"})," and ",(0,t.jsx)(a.code,{children:"DELETE"})," operations require storing row-level versioning information to ensure reliable database transaction processing. Heap tables are best suited for smaller tables, such as dimension tables, that are often updated after they are initially loaded."]}),"\n",(0,t.jsx)(a.h2,{id:"append-optimized-storage",children:"Append-optimized storage"}),"\n",(0,t.jsxs)(a.p,{children:["Append-optimized table storage works best with denormalized fact tables in a data warehouse environment. Denormalized fact tables are typically the largest tables in the system. Fact tables are usually loaded in batches and accessed by read-only queries. Moving large fact tables to an append-optimized storage model eliminates the storage overhead of the per-row update visibility information. This allows for a leaner and easier-to-optimize page structure. The storage model of append-optimized tables is optimized for bulk data loading. Single row ",(0,t.jsx)(a.code,{children:"INSERT"})," statements are not recommended."]}),"\n",(0,t.jsx)(a.h3,{id:"to-create-a-heap-table",children:"To create a heap table"}),"\n",(0,t.jsx)(a.p,{children:"Row-oriented heap tables are the default storage type."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"=> CREATE TABLE foo (a int, b text) DISTRIBUTED BY (a);\n"})}),"\n",(0,t.jsxs)(a.p,{children:["Use the ",(0,t.jsx)(a.code,{children:"WITH"})," clause of the ",(0,t.jsx)(a.code,{children:"CREATE TABLE"})," command to declare the table storage options. The default is to create the table as a regular row-oriented heap-storage table. For example, to create an append-optimized table with no compression:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"=> CREATE TABLE bar (a int, b text) \n\xa0\xa0\xa0 WITH (appendoptimized=true)\n\xa0\xa0\xa0 DISTRIBUTED BY (a);\n"})}),"\n",(0,t.jsx)(a.admonition,{type:"info",children:(0,t.jsxs)(a.p,{children:["You use the ",(0,t.jsx)(a.code,{children:"appendoptimized=value"})," syntax to specify the append-optimized table storage type. ",(0,t.jsx)(a.code,{children:"appendoptimized"})," is a thin alias for the ",(0,t.jsx)(a.code,{children:"appendonly"})," legacy storage option. Apache Cloudberry stores ",(0,t.jsx)(a.code,{children:"appendonly"})," in the catalog, and displays the same when listing storage options for append-optimized tables."]})}),"\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.code,{children:"UPDATE"})," and ",(0,t.jsx)(a.code,{children:"DELETE"})," are not allowed on append-optimized tables in a repeatable read or serizalizable transaction and will cause the transaction to end prematurely."]}),"\n",(0,t.jsx)(a.h2,{id:"choose-row-or-column-oriented-storage",children:"Choose row or column-oriented storage"}),"\n",(0,t.jsx)(a.p,{children:"Apache Cloudberry provides a choice of storage orientation models: row, column, or a combination of both. This section provides general guidelines for choosing the optimal storage orientation for a table. Evaluate performance using your own data and query workloads."}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"Row-oriented storage: good for OLTP types of workloads with many iterative transactions and many columns of a single row needed all at once, so retrieving is efficient."}),"\n",(0,t.jsx)(a.li,{children:"Column-oriented storage: good for data warehouse workloads with aggregations of data computed over a small number of columns, or for single columns that require regular updates without modifying other column data."}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"For most general purpose or mixed workloads, row-oriented storage offers the best combination of flexibility and performance. However, there are use cases where a column-oriented storage model provides more efficient I/O and storage. Consider the following requirements when deciding on the storage orientation model for a table:"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Updates of table data."})," If you load and update the table data frequently, choose a row-oriented heap table. Column-oriented table storage is only available on append-optimized tables."]}),"\n",(0,t.jsxs)(a.p,{children:["See ",(0,t.jsx)(a.a,{href:"#heap-storage",children:"Heap storage"})," for more information."]}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Frequent INSERTs."})," If rows are frequently inserted into the table, consider a row-oriented model. Column-oriented tables are not optimized for write operations, because column values for a row must be written to different places on disk."]}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Number of columns requested in queries."})," If you typically request all or the majority of columns in the ",(0,t.jsx)(a.code,{children:"SELECT"})," list or ",(0,t.jsx)(a.code,{children:"WHERE"})," clause of your queries, consider a row-oriented model. Column-oriented tables are best suited to queries that aggregate many values of a single column where the ",(0,t.jsx)(a.code,{children:"WHERE"})," or ",(0,t.jsx)(a.code,{children:"HAVING"})," predicate is also on the aggregate column. For example:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"SELECT SUM(salary)...\n"})}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"SELECT AVG(salary)... WHERE salary > 10000\n"})}),"\n",(0,t.jsxs)(a.p,{children:["Or where the ",(0,t.jsx)(a.code,{children:"WHERE"})," predicate is on a single column and returns a relatively small number of rows. For example:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"SELECT salary, dept ... WHERE state='CA'\n"})}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Number of columns in the table."})," Row-oriented storage is more efficient when many columns are required at the same time, or when the row-size of a table is relatively small. Column-oriented tables can offer better query performance on tables with many columns where you access a small subset of columns in your queries."]}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Compression."})," Column data has the same data type, so storage size optimizations are available in column-oriented data that are not available in row-oriented data. For example, many compression schemes use the similarity of adjacent data to compress. However, the greater adjacent compression achieved, the more difficult random access can become, as data must be uncompressed to be read."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(a.h3,{id:"to-create-a-column-oriented-table",children:"To create a column-oriented table"}),"\n",(0,t.jsxs)(a.p,{children:["The ",(0,t.jsx)(a.code,{children:"WITH"})," clause of the ",(0,t.jsx)(a.code,{children:"CREATE TABLE"})," command specifies the table's storage options. The default is a row-oriented heap table. Tables that use column-oriented storage must be append-optimized tables. For example, to create a column-oriented table:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"=> CREATE TABLE bar (a int, b text) WITH (appendoptimized=true, orientation=column) DISTRIBUTED BY (a);\n"})})]})}function p(e={}){const{wrapper:a}={...(0,r.a)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,a,o)=>{o.d(a,{Z:()=>i,a:()=>s});var t=o(67294);const r={},n=t.createContext(r);function s(e){const a=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(n.Provider,{value:a},e.children)}}}]);