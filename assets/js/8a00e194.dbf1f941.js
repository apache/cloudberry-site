"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[40746],{19206:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var n=s(85893),d=s(11151);const r={title:"pg_attribute"},i="pg_attribute",l={id:"sys-catalogs/sys-tables/pg-attribute",title:"pg_attribute",description:"The pgattribute table in the pgcatalog schema stores information about table columns. There will be exactly one pgattribute row for every column in every table in the database. (There will also be attribute entries for indexes, and all objects that have pgclass entries.) The term attribute is equivalent to column.",source:"@site/versioned_docs/version-2.x/sys-catalogs/sys-tables/pg-attribute.md",sourceDirName:"sys-catalogs/sys-tables",slug:"/sys-catalogs/sys-tables/pg-attribute",permalink:"/docs/sys-catalogs/sys-tables/pg-attribute",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/sys-catalogs/sys-tables/pg-attribute.md",tags:[],version:"2.x",lastUpdatedBy:"TomShawn",lastUpdatedAt:1747708951,formattedLastUpdatedAt:"May 20, 2025",frontMatter:{title:"pg_attribute"},sidebar:"docsbars",previous:{title:"pg_appendonly",permalink:"/docs/sys-catalogs/sys-tables/pg-appendonly"},next:{title:"pg_attribute_encoding",permalink:"/docs/sys-catalogs/sys-tables/pg-attribute-encoding"}},c={},o=[];function a(e){const t={code:"code",h1:"h1",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,d.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"pg_attribute",children:"pg_attribute"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"pg_attribute"})," table in the ",(0,n.jsx)(t.code,{children:"pg_catalog"})," schema stores information about table columns. There will be exactly one ",(0,n.jsx)(t.code,{children:"pg_attribute"})," row for every column in every table in the database. (There will also be attribute entries for indexes, and all objects that have ",(0,n.jsx)(t.code,{children:"pg_class"})," entries.) The term attribute is equivalent to column."]}),"\n",(0,n.jsxs)(t.p,{children:["In a dropped column's ",(0,n.jsx)(t.code,{children:"pg_attribute"})," entry, ",(0,n.jsx)(t.code,{children:"atttypid"})," is reset to zero, but ",(0,n.jsx)(t.code,{children:"attlen"})," and the other fields copied from ",(0,n.jsx)(t.code,{children:"pg_type"})," are still valid. This arrangement is needed to address the situation where the dropped column's data type was later dropped, and so there is no ",(0,n.jsx)(t.code,{children:"pg_type"})," row anymore. ",(0,n.jsx)(t.code,{children:"attlen"})," and the other fields can be used to interpret the contents of a row of the table."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Column"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{children:"References"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attrelid"})}),(0,n.jsx)(t.td,{children:"oid"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"pg_class.oid"})}),(0,n.jsx)(t.td,{children:"The table this column belongs to."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attname"})}),(0,n.jsx)(t.td,{children:"name"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{children:"The column name."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"atttypid"})}),(0,n.jsx)(t.td,{children:"oid"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"pg_type.oid"})}),(0,n.jsx)(t.td,{children:"The data type of this column."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attstattarget"})}),(0,n.jsx)(t.td,{children:"integer"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["Controls the level of detail of statistics accumulated for this column by ",(0,n.jsx)(t.code,{children:"ANALYZE"}),'. A zero value indicates that no statistics should be collected. A negative value says to use the system default statistics target. The exact meaning of positive values is data type-dependent. For scalar data types, it is both the target number of "most common values" to collect, and the target number of histogram bins to create.']})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attlen"})}),(0,n.jsx)(t.td,{children:"smallint"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["A copy of ",(0,n.jsx)(t.code,{children:"pg_type.typlen"})," of this column's type."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attnum"})}),(0,n.jsx)(t.td,{children:"smallint"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["The number of the column. Ordinary columns are numbered from 1 up. System columns, such as ",(0,n.jsx)(t.code,{children:"ctid"}),", have (arbitrary) negative numbers."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attndims"})}),(0,n.jsx)(t.td,{children:"integer"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["Number of dimensions, if the column is an array type; otherwise ",(0,n.jsx)(t.code,{children:"0"}),". (Currently, the number of dimensions of an array is not enforced, so any nonzero value effectively means it is an array.)"]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attcacheoff"})}),(0,n.jsx)(t.td,{children:"integer"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["Always ",(0,n.jsx)(t.code,{children:"-1"})," in storage, but when loaded into a row descriptor in memory this may be updated to cache the offset of the attribute within the row."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"atttypmod"})}),(0,n.jsx)(t.td,{children:"integer"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["Records type-specific data supplied at table creation time (for example, the maximum length of a ",(0,n.jsx)(t.code,{children:"varchar"})," column). It is passed to type-specific input functions and length coercion functions. The value will generally be ",(0,n.jsx)(t.code,{children:"-1"})," for types that do not need it."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attbyval"})}),(0,n.jsx)(t.td,{children:"boolean"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["A copy of ",(0,n.jsx)(t.code,{children:"pg_type.typbyval"})," of this column's type."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attstorage"})}),(0,n.jsx)(t.td,{children:"char"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["Normally a copy of ",(0,n.jsx)(t.code,{children:"pg_type.typstorage"})," of this column's type. For TOAST-able data types, this can be altered after column creation to control storage policy."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attalign"})}),(0,n.jsx)(t.td,{children:"char"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["A copy of ",(0,n.jsx)(t.code,{children:"pg_type.typalign"})," of this column's type."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attnotnull"})}),(0,n.jsx)(t.td,{children:"boolean"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{children:"This represents a not-null constraint."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attcompression"})}),(0,n.jsx)(t.td,{children:"char"}),(0,n.jsx)(t.td,{}),(0,n.jsxs)(t.td,{children:["Compression type for this column. Valid values are ",(0,n.jsx)(t.code,{children:"n"})," for none, ",(0,n.jsx)(t.code,{children:"r"})," for run-length encoding, ",(0,n.jsx)(t.code,{children:"z"})," for zlib, ",(0,n.jsx)(t.code,{children:"q"})," for quicklz, and ",(0,n.jsx)(t.code,{children:"s"})," for snappy."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"atthasdef"})}),(0,n.jsx)(t.td,{children:"boolean"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["This column has a default expression or generation expression, in which case there will be a corresponding entry in the ",(0,n.jsx)(t.code,{children:"pg_attrdef"})," catalog that actually defines the value. (Check ",(0,n.jsx)(t.code,{children:"attgenerated"})," to determine whether this is a default or a generation expression.)"]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"atthasmissing"})}),(0,n.jsx)(t.td,{children:"boolean"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["This column has a value which is used where the column is entirely missing from the row, as happens when a column is added with a non-volatile ",(0,n.jsx)(t.code,{children:"DEFAULT"})," value after the row is created. The actual value used is stored in the ",(0,n.jsx)(t.code,{children:"attmissingval"})," column."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attidentity"})}),(0,n.jsx)(t.td,{children:"char"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["If a zero byte (''), then not an identity column. Otherwise, ",(0,n.jsx)(t.code,{children:"a"})," = generated always, ",(0,n.jsx)(t.code,{children:"d"})," = generated by default."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attgenerated"})}),(0,n.jsx)(t.td,{children:"char"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["If a zero byte (''), then not a generated column. Otherwise, ",(0,n.jsx)(t.code,{children:"s"})," = stored. (Other values might be added in the future.)"]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attisdropped"})}),(0,n.jsx)(t.td,{children:"boolean"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{children:"This column has been dropped and is no longer valid. A dropped column is still physically present in the table, but is ignored by the parser and so cannot be accessed via SQL."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attislocal"})}),(0,n.jsx)(t.td,{children:"boolean"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{children:"This column is defined locally in the relation. Note that a column may be locally defined and inherited simultaneously."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attinhcount"})}),(0,n.jsx)(t.td,{children:"integer"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{children:"The number of direct ancestors this column has. A column with a nonzero number of ancestors cannot be dropped nor renamed."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attcollation"})}),(0,n.jsx)(t.td,{children:"oid"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"pg_collation.oid"})}),(0,n.jsx)(t.td,{children:"The defined collation of the column, or zero if the is not of a collatable data type."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attacl"})}),(0,n.jsx)(t.td,{children:"aclitem[]"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{children:"Column-level access privileges, if any have been granted specifically on this column."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attoptions"})}),(0,n.jsx)(t.td,{children:"text[]"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{children:'Attribute-level options, as "keyword=value" strings.'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attfdwoptions"})}),(0,n.jsx)(t.td,{children:"text[]"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsx)(t.td,{children:'Attribute-level foreign data wrapper options, as "keyword=value" strings.'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"attmissingval"})}),(0,n.jsx)(t.td,{children:"anyarray"}),(0,n.jsx)(t.td,{children:"\xa0"}),(0,n.jsxs)(t.td,{children:["This column has a one element array containing the value used when the column is entirely missing from the row, as happens when the column is added with a non-volatile ",(0,n.jsx)(t.code,{children:"DEFAULT"})," value after the row is created. The value is only used when ",(0,n.jsx)(t.code,{children:"atthasmissing"})," is ",(0,n.jsx)(t.code,{children:"true"}),". If there is no value the column is null."]})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,d.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>l,a:()=>i});var n=s(67294);const d={},r=n.createContext(d);function i(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);