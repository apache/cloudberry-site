"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[14384],{60881:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=t(85893),i=t(11151);const r={title:"Create and Manage Partitioned Tables"},s="Create and Manage Partitioned Tables",l={id:"operate-with-data/operate-with-db-objects/create-and-manage-partitioned-tables",title:"Create and Manage Partitioned Tables",description:"This document outlines how to create and maintain partitioned tables in Apache Cloudberry using the recommended syntax.",source:"@site/versioned_docs/version-2.x/operate-with-data/operate-with-db-objects/create-and-manage-partitioned-tables.md",sourceDirName:"operate-with-data/operate-with-db-objects",slug:"/operate-with-data/operate-with-db-objects/create-and-manage-partitioned-tables",permalink:"/docs/operate-with-data/operate-with-db-objects/create-and-manage-partitioned-tables",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/operate-with-data/operate-with-db-objects/create-and-manage-partitioned-tables.md",tags:[],version:"2.x",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1752118159,formattedLastUpdatedAt:"Jul 10, 2025",frontMatter:{title:"Create and Manage Partitioned Tables"},sidebar:"docsbars",previous:{title:"BRIN Indexes",permalink:"/docs/operate-with-data/operate-with-db-objects/brin-indexes"},next:{title:"About Table Partitioning",permalink:"/docs/operate-with-data/operate-with-db-objects/about-table-partitioning"}},o={},d=[{value:"Create partitioned tables",id:"create-partitioned-tables",level:2},{value:"Define a date-range partitioned table",id:"define-a-date-range-partitioned-table",level:3},{value:"Define a numeric-range partitioned table",id:"define-a-numeric-range-partitioned-table",level:3},{value:"Define a list partitioned table",id:"define-a-list-partitioned-table",level:3},{value:"Define a hash partitioned table",id:"define-a-hash-partitioned-table",level:3},{value:"Define a multi-level partitioned table",id:"define-a-multi-level-partitioned-table",level:3},{value:"Partition an existing table",id:"partition-an-existing-table",level:2},{value:"Load data into a partitioned table",id:"load-data-into-a-partitioned-table",level:2},{value:"Verify the partition strategy",id:"verify-the-partition-strategy",level:2},{value:"Troubleshoot selective partition scans",id:"troubleshoot-selective-partition-scans",level:3},{value:"View your partition design",id:"view-your-partition-design",level:2},{value:"About partition pruning",id:"about-partition-pruning",level:2},{value:"Maintain partitions",id:"maintain-partitions",level:2},{value:"Add a partition",id:"add-a-partition",level:3},{value:"Index partitioned tables",id:"index-partitioned-tables",level:3},{value:"Rename a partition",id:"rename-a-partition",level:3},{value:"Add a default partition",id:"add-a-default-partition",level:2},{value:"Drop a partition",id:"drop-a-partition",level:3},{value:"Detach a partition",id:"detach-a-partition",level:3},{value:"Truncate a partition",id:"truncate-a-partition",level:3},{value:"Exchange a partition",id:"exchange-a-partition",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"create-and-manage-partitioned-tables",children:"Create and Manage Partitioned Tables"}),"\n",(0,a.jsx)(n.p,{children:"This document outlines how to create and maintain partitioned tables in Apache Cloudberry using the recommended syntax."}),"\n",(0,a.jsxs)(n.p,{children:["For more information on partitioned tables, see ",(0,a.jsx)(n.a,{href:"/docs/operate-with-data/operate-with-db-objects/about-table-partitioning",children:"About Table Partitioning"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"create-partitioned-tables",children:"Create partitioned tables"}),"\n",(0,a.jsx)(n.p,{children:"Before creating a partitioned table, you should:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Choose the partition method: range, list, or hash."}),"\n",(0,a.jsx)(n.li,{children:"Choose the column(s) for the partition key."}),"\n",(0,a.jsx)(n.li,{children:"Determine the appropriate number of partitions and levels (if using multi-level partitioning)."}),"\n",(0,a.jsx)(n.li,{children:"Create the partitioned table."}),"\n",(0,a.jsx)(n.li,{children:"Create the individual partitions."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Apache Cloudberry automatically creates constraints describing the partition boundary conditions. Any data inserted into the root partitioned table that matches a partition's constraints will be directed to that partition."}),"\n",(0,a.jsx)(n.p,{children:"For sub-partitioning, you can use the same partition key column if necessary (for example, partition by month, then sub-partition by day). Consider partitioning by the most granular level directly (for example, 365 daily partitions instead of year then month then day) as a flat partition design typically runs faster, though a multi-level design can reduce query planning time."}),"\n",(0,a.jsx)(n.h3,{id:"define-a-date-range-partitioned-table",children:"Define a date-range partitioned table"}),"\n",(0,a.jsxs)(n.p,{children:["A date-range partitioned table uses a ",(0,a.jsx)(n.code,{children:"date"})," or ",(0,a.jsx)(n.code,{children:"timestamp"})," column as the partition key. You can specify multiple partition key columns for range partitioned tables."]}),"\n",(0,a.jsxs)(n.p,{children:["Example: Create a ",(0,a.jsx)(n.code,{children:"measurement"})," table for an ice-cream company, partitioned by month on the ",(0,a.jsx)(n.code,{children:"logdate"})," column to retain 2 years of data and remove the oldest month's data monthly."]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create the root partitioned table:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE measurement (\n    city_id         int not null,\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n)\nDISTRIBUTED BY (city_id)\nPARTITION BY RANGE (logdate);\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create the partitions (for example, for each month):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE measurement_y2021m01 PARTITION OF measurement\nFOR VALUES FROM ('2021-01-01') TO ('2021-02-01');\n\nCREATE TABLE measurement_y2021m02 PARTITION OF measurement\nFOR VALUES FROM ('2021-02-01') TO ('2021-03-01');\n-- ... and so on for other months ...\n\nCREATE TABLE measurement_y2022m12 PARTITION OF measurement\nFOR VALUES FROM ('2022-12-01') TO ('2023-01-01') -- Note: Source had '2022-01-01' likely a typo for '2023-01-01'\nTABLESPACE fasttablespace;\n\nCREATE TABLE measurement_y2023m01 PARTITION OF measurement\nFOR VALUES FROM ('2023-01-01') TO ('2023-02-01')\nWITH (parallel_workers = 4)\nTABLESPACE fasttablespace;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Range upper bounds are treated as exclusive. If data is inserted into the parent table that does not map to an existing partition, Apache Cloudberry returns an error (unless a default partition exists)."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"define-a-numeric-range-partitioned-table",children:"Define a numeric-range partitioned table"}),"\n",(0,a.jsx)(n.p,{children:"This uses a numeric-type column as the partition key. Multiple partition key columns are supported."}),"\n",(0,a.jsxs)(n.p,{children:["Example: Create ",(0,a.jsx)(n.code,{children:"numpart"})," table partitioned by ",(0,a.jsx)(n.code,{children:"year"}),"."]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create the root partitioned table:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE numpart (id int, rank int, year int, color char(1), count int)\nDISTRIBUTED BY (id)\nPARTITION BY RANGE (year);\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create the partitions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE numpart_y2019 PARTITION OF numpart FOR VALUES FROM (2019) TO (2020);\nCREATE TABLE numpart_y2020 PARTITION OF numpart FOR VALUES FROM (2020) TO (2021);\nCREATE TABLE numpart_y2021 PARTITION OF numpart FOR VALUES FROM (2021) TO (2022);\nCREATE TABLE numpart_y2022 PARTITION OF numpart FOR VALUES FROM (2022) TO (2023);\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"define-a-list-partitioned-table",children:"Define a list partitioned table"}),"\n",(0,a.jsx)(n.p,{children:"A list partitioned table can use any data type column that allows equality comparisons as its partition key. Only a single column is allowed as the partition key for list partitions. You must declare a partition specification for every list value."}),"\n",(0,a.jsxs)(n.p,{children:["Example: Create ",(0,a.jsx)(n.code,{children:"listpart"})," table partitioned by ",(0,a.jsx)(n.code,{children:"color"}),"."]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create the root partitioned table:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE listpart (id int, rank int, year int, color char(1), count int)\nDISTRIBUTED BY (id)\nPARTITION BY LIST (color);\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create the partitions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE listpart_red PARTITION OF listpart FOR VALUES IN ('r');\nCREATE TABLE listpart_green PARTITION OF listpart FOR VALUES IN ('g');\nCREATE TABLE listpart_blue PARTITION OF listpart FOR VALUES IN ('b');\nCREATE TABLE listpart_other PARTITION OF listpart DEFAULT;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"DEFAULT"})," keyword creates a default partition to catch any data not matching other partitions."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"define-a-hash-partitioned-table",children:"Define a hash partitioned table"}),"\n",(0,a.jsx)(n.p,{children:"A hash partitioned table uses a single hashable column as its partition key. You must declare a partition specification for every modulus/remainder combination."}),"\n",(0,a.jsxs)(n.p,{children:["Example: Create ",(0,a.jsx)(n.code,{children:"hpt"})," table partitioned by the hash of column ",(0,a.jsx)(n.code,{children:"c"}),"."]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create the root partitioned table:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE hpt (a int, b int, c text) PARTITION BY HASH(c);\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create the partitions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE hpt_p1 PARTITION OF hpt FOR VALUES WITH (MODULUS 3, REMAINDER 0);\nCREATE TABLE hpt_p2 PARTITION OF hpt FOR VALUES WITH (MODULUS 3, REMAINDER 1);\nCREATE TABLE hpt_p3 PARTITION OF hpt FOR VALUES WITH (MODULUS 3, REMAINDER 2);\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"define-a-multi-level-partitioned-table",children:"Define a multi-level partitioned table"}),"\n",(0,a.jsx)(n.p,{children:"You can create a multi-level partition hierarchy by sub-partitioning existing partitions."}),"\n",(0,a.jsxs)(n.p,{children:["Example: Create a two-level partition for ",(0,a.jsx)(n.code,{children:"msales"}),", partitioned by ",(0,a.jsx)(n.code,{children:"year"})," (range), then sub-partitioned by ",(0,a.jsx)(n.code,{children:"region"})," (list)."]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create the root (level 1) partitioned table:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE msales (trans_id int, year int, amount decimal(9,2), region text)\nDISTRIBUTED BY (trans_id)\nPARTITION BY RANGE (year);\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create yearly partitions (level 2), themselves partitioned by region:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE msales_2021 PARTITION OF msales FOR VALUES FROM (2021) TO (2022)\nPARTITION BY LIST (region);\nCREATE TABLE msales_2022 PARTITION OF msales FOR VALUES FROM (2022) TO (2023)\nPARTITION BY LIST (region);\nCREATE TABLE msales_2023 PARTITION OF msales FOR VALUES FROM (2023) TO (2024)\nPARTITION BY LIST (region);\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create the region sub-partitions (leaf partitions):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE msales_2021_usa PARTITION OF msales_2021 FOR VALUES IN ('usa');\nCREATE TABLE msales_2021_asia PARTITION OF msales_2021 FOR VALUES IN ('asia');\nCREATE TABLE msales_2021_europe PARTITION OF msales_2021 FOR VALUES IN ('europe');\n-- ... and similarly for msales_2022 and msales_2023 ...\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"partition-an-existing-table",children:"Partition an existing table"}),"\n",(0,a.jsx)(n.p,{children:"Tables can only be partitioned at creation time. To partition an existing table:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Create a new partitioned table with the desired structure."}),"\n",(0,a.jsx)(n.li,{children:"Load data from the original table into the new partitioned table."}),"\n",(0,a.jsx)(n.li,{children:"Drop the original table."}),"\n",(0,a.jsx)(n.li,{children:"Rename the new partitioned table to the original table's name."}),"\n",(0,a.jsx)(n.li,{children:"Re-grant any necessary permissions."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"-- Assume 'msales' is an existing non-partitioned table\n-- 1. Create new partitioned table (msales2)\nCREATE TABLE msales2 (LIKE msales) PARTITION BY RANGE (year); -- Define partitions for msales2 here\n-- (Example: CREATE TABLE msales2_y2021 PARTITION OF msales2 FOR VALUES FROM (2021) TO (2022); etc.)\n\n-- 2. Load data\nINSERT INTO msales2 SELECT * FROM msales;\n\n-- 3. Drop old table\nDROP TABLE msales;\n\n-- 4. Rename new table\nALTER TABLE msales2 RENAME TO msales;\n\n-- 5. Re-grant permissions\nGRANT ALL PRIVILEGES ON msales TO admin;\nGRANT SELECT ON msales TO guest;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note: The ",(0,a.jsx)(n.code,{children:"LIKE"})," clause does not copy over partition structures when creating a new table from a partitioned one."]}),"\n",(0,a.jsx)(n.h2,{id:"load-data-into-a-partitioned-table",children:"Load data into a partitioned table"}),"\n",(0,a.jsx)(n.p,{children:"Initially, the top-level root partitioned table is empty. When you insert data into the root table, Apache Cloudberry routes the data to the appropriate bottom-level leaf partitions. In a multi-level design, only the leaf partitions at the bottom-most levels contain data."}),"\n",(0,a.jsxs)(n.p,{children:["Apache Cloudberry rejects rows that cannot be mapped to a leaf partition, and the load fails, unless a ",(0,a.jsx)(n.code,{children:"DEFAULT"})," partition is defined to catch such rows."]}),"\n",(0,a.jsxs)(n.p,{children:["Be cautious with",(0,a.jsx)(n.code,{children:" DEFAULT"})," partitions: if they contain data, they are always scanned by the query optimizer, potentially slowing down overall scan time."]}),"\n",(0,a.jsxs)(n.p,{children:["Using ",(0,a.jsx)(n.code,{children:"COPY"})," or ",(0,a.jsx)(n.code,{children:"INSERT"})," to load data into a parent table automatically routes data to the correct leaf partition. Best practice: For loading large amounts of data, create an intermediate staging table, load data into it, and then attach it to your partition hierarchy."]}),"\n",(0,a.jsx)(n.h2,{id:"verify-the-partition-strategy",children:"Verify the partition strategy"}),"\n",(0,a.jsxs)(n.p,{children:["Use the ",(0,a.jsx)(n.code,{children:"EXPLAIN"})," command to examine the query plan and verify that the optimizer scans only relevant partitions."]}),"\n",(0,a.jsxs)(n.p,{children:["Example: For a table ",(0,a.jsx)(n.code,{children:"msales"})," partitioned by ",(0,a.jsx)(n.code,{children:"year"})," and sub-partitioned by ",(0,a.jsx)(n.code,{children:"region"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"EXPLAIN SELECT * FROM msales WHERE year='2021' AND region='usa';\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The query plan should show a scan of only ",(0,a.jsx)(n.code,{children:"msales_2021_usa"})," (the relevant leaf partition). Scans of parent tables or default partitions (if any) should return 0-1 rows. Ensure unnecessary partitions are not scanned."]}),"\n",(0,a.jsx)(n.h3,{id:"troubleshoot-selective-partition-scans",children:"Troubleshoot selective partition scans"}),"\n",(0,a.jsx)(n.p,{children:"Limitations that can prevent selective scanning:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The query optimizer can selectively scan only when the query contains a direct and simple restriction of the table using immutable operators like ",(0,a.jsx)(n.code,{children:"="}),", ",(0,a.jsx)(n.code,{children:"<"}),", ",(0,a.jsx)(n.code,{children:"<="}),", ",(0,a.jsx)(n.code,{children:">"}),", ",(0,a.jsx)(n.code,{children:">="}),", and ",(0,a.jsx)(n.code,{children:"<>"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Selective scanning recognizes ",(0,a.jsx)(n.code,{children:"STABLE"})," and ",(0,a.jsx)(n.code,{children:"IMMUTABLE"})," functions in a query, but not ",(0,a.jsx)(n.code,{children:"VOLATILE"})," functions. For example, ",(0,a.jsx)(n.code,{children:"WHERE date > CURRENT_DATE"})," allows selective scanning, but ",(0,a.jsx)(n.code,{children:"WHERE time > TIMEOFDAY()"})," does not."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"view-your-partition-design",children:"View your partition design"}),"\n",(0,a.jsxs)(n.p,{children:["Partitioning information is stored in system catalogs like ",(0,a.jsx)(n.code,{children:"pg_partitioned_table"})," and in additional fields in ",(0,a.jsx)(n.code,{children:"pg_class"})," (",(0,a.jsx)(n.code,{children:"relispartition"}),", ",(0,a.jsx)(n.code,{children:"relpartbound"}),")."]}),"\n",(0,a.jsx)(n.p,{children:"Use these functions to get information about partitioned tables:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"pg_partition_tree(regclass)"}),": Lists information about tables/indexes in a partition hierarchy for a given partitioned table/index."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"pg_partition_ancestors(regclass)"}),": Lists ancestor relations of a given partition, including itself."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"pg_partition_root(regclass)"}),": Returns the topmost parent of the hierarchy for a given relation."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Example: Display the partition structure of ",(0,a.jsx)(n.code,{children:"msales"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM pg_partition_tree('msales');\n"})}),"\n",(0,a.jsx)(n.h2,{id:"about-partition-pruning",children:"About partition pruning"}),"\n",(0,a.jsxs)(n.p,{children:["Partition pruning is a query optimization technique that improves performance for partitioned tables. It is controlled by the ",(0,a.jsx)(n.code,{children:"enable_partition_pruning"})," server configuration parameter, which is ",(0,a.jsx)(n.code,{children:"on "}),"by default."]}),"\n",(0,a.jsxs)(n.p,{children:["The planner/optimizer examines partition definitions to prove that a partition need not be scanned because it cannot contain rows meeting the query's ",(0,a.jsx)(n.code,{children:"WHERE"})," clause. If proven, the partition is excluded (pruned) from the query plan."]}),"\n",(0,a.jsx)(n.p,{children:"Pruning is driven by constraints implicitly defined by partition keys, not by the presence of indexes on key columns."}),"\n",(0,a.jsx)(n.p,{children:"Partition pruning can occur:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"During query planning: For known values."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["During query execution: Useful when clauses contain expressions whose values are not known at planning time (for example, parameters in ",(0,a.jsx)(n.code,{children:"PREPARE"}),", subquery results, parameterized nested loop join values)."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["During plan initialization: For parameter values known at execution's initialization phase. Pruned partitions will not appear in ",(0,a.jsx)(n.code,{children:"EXPLAIN"}),"/",(0,a.jsx)(n.code,{children:"EXPLAIN ANALYZE"}),'. The "Subplans Removed" property in ',(0,a.jsx)(n.code,{children:"EXPLAIN"})," output shows how many were removed here."]}),"\n",(0,a.jsxs)(n.li,{children:["During actual execution: For values known only during the run. This requires careful inspection of the loops property in ",(0,a.jsx)(n.code,{children:"EXPLAIN ANALYZE"})," output. Subplans for different partitions might have different loop counts or show as (",(0,a.jsx)(n.code,{children:"never executed"}),") if pruned every time."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"maintain-partitions",children:"Maintain partitions"}),"\n",(0,a.jsxs)(n.p,{children:["The set of partitions is often dynamic, involving removing old partitions and adding new ones. These tasks can be done nearly instantaneously by manipulating the partition structure. Use ",(0,a.jsx)(n.code,{children:"ALTER TABLE"})," against the top-level root partitioned table or the partition itself."]}),"\n",(0,a.jsx)(n.h3,{id:"add-a-partition",children:"Add a partition"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Directly add to the hierarchy:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE msales_mfeb20 PARTITION OF msales\n    FOR VALUES FROM ('2020-02-01') TO ('2020-03-01');\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create as a regular table then attach (allows pre-loading/checking data):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"-- Create table with same structure as parent\nCREATE TABLE msales_mfeb20 (LIKE msales INCLUDING DEFAULTS INCLUDING CONSTRAINTS);\n\n-- Add constraints matching intended partition bounds\nALTER TABLE msales_mfeb20 ADD CONSTRAINT y2020m02\nCHECK ( logdate >= DATE '2020-02-01' AND logdate < DATE '2020-03-01' );\n\n-- Load data or perform other prep work into msales_mfeb20\n-- ...\n\n-- Attach to the partition hierarchy\nALTER TABLE msales ATTACH PARTITION msales_mfeb20\nFOR VALUES FROM ('2020-02-01') TO ('2020-03-01');\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ATTACH PARTITION"})," requires a ",(0,a.jsx)(n.code,{children:"SHARE UPDATE EXCLUSIVE"})," lock on the partitioned table."]}),"\n",(0,a.jsxs)(n.li,{children:["Creating a ",(0,a.jsx)(n.code,{children:"CHECK"})," constraint on the table to be attached that matches the partition bounds (as shown above) allows the system to skip a validation scan. Drop the redundant ",(0,a.jsx)(n.code,{children:"CHECK"})," constraint after ",(0,a.jsx)(n.code,{children:"ATTACH PARTITION"})," completes."]}),"\n",(0,a.jsxs)(n.li,{children:["If the partitioned table has a ",(0,a.jsx)(n.code,{children:"DEFAULT"})," partition, consider creating a ",(0,a.jsx)(n.code,{children:"CHECK"})," constraint on the ",(0,a.jsx)(n.code,{children:"DEFAULT"})," partition that excludes the data of the partition being attached. This avoids scanning the ",(0,a.jsx)(n.code,{children:"DEFAULT"})," partition to verify no records belong in the new partition."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"index-partitioned-tables",children:"Index partitioned tables"}),"\n",(0,a.jsx)(n.p,{children:'Creating an index on the key column(s) of a partitioned table automatically creates a matching index on each existing partition, and any partitions created or attached later will also get such an index. The index on the partitioned table is "virtual"; actual data is in child indexes on individual partitions.'}),"\n",(0,a.jsx)(n.p,{children:"To avoid long lock times when indexing large hierarchies:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create an invalid index on the parent table only:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX measurement_usls_idx ON ONLY measurement (unitsales);\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Create indexes on individual partitions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX measurement_usls_202102_idx ON measurement_y2021m02 (unitsales);\n-- ... repeat for other partitions ...\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Attach each partition's index to the parent index:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"ALTER INDEX measurement_usls_idx ATTACH PARTITION measurement_usls_202102_idx;\n-- ... repeat for other partition indexes ...\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Once indexes for all partitions are attached, the parent index is marked valid automatically."}),"\n",(0,a.jsxs)(n.p,{children:["This technique also applies to ",(0,a.jsx)(n.code,{children:"UNIQUE"})," and ",(0,a.jsx)(n.code,{children:"PRIMARY KEY"})," constraints (indexes are created implicitly)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE ONLY measurement ADD UNIQUE (city_id, logdate);\n\nALTER TABLE measurement_y2021m02 ADD UNIQUE (city_id, logdate);\nALTER INDEX measurement_city_id_logdate_key\n    ATTACH PARTITION measurement_y2021m02_city_id_logdate_key;\n-- ...\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This technique also applies to ",(0,a.jsx)(n.code,{children:"UNIQUE"})," and ",(0,a.jsx)(n.code,{children:"PRIMARY KEY"})," constraints (indexes are created implicitly)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE ONLY measurement ADD UNIQUE (city_id, logdate);\n\nALTER TABLE measurement_y2021m02 ADD UNIQUE (city_id, logdate);\nALTER INDEX measurement_city_id_logdate_key\n    ATTACH PARTITION measurement_y2021m02_city_id_logdate_key;\n-- ...\n"})}),"\n",(0,a.jsx)(n.h3,{id:"rename-a-partition",children:"Rename a partition"}),"\n",(0,a.jsxs)(n.p,{children:["Rename a partition (which is a table) using ",(0,a.jsx)(n.code,{children:"ALTER TABLE ... RENAME TO"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE msales_mfeb17 RENAME TO msales_month_feb17;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"add-a-default-partition",children:"Add a default partition"}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"DEFAULT"})," partition catches data that does not fit into any other defined partition. Without it, such data causes an error. A partitioned table can have only one default partition."]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"During table creation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE msales_other PARTITION OF msales DEFAULT;\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"After table creation (attaching an existing table as default):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"-- Create a table with the same schema as the root\nCREATE TABLE msales_other (LIKE msales);\n\n-- Attach it as the default partition\nALTER TABLE msales ATTACH PARTITION msales_other DEFAULT;\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"drop-a-partition",children:"Drop a partition"}),"\n",(0,a.jsx)(n.p,{children:"To remove old data, you can drop the partition. This quickly deletes all records in that partition."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"DROP TABLE measurement_y2020m02;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This command requires an ",(0,a.jsx)(n.code,{children:"ACCESS EXCLUSIVE"})," lock on the parent table."]}),"\n",(0,a.jsx)(n.h3,{id:"detach-a-partition",children:"Detach a partition"}),"\n",(0,a.jsx)(n.p,{children:"Removes a partition from the hierarchy but retains it as a standalone table."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE msales DETACH PARTITION msales_2021;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Detaching a partition that itself has sub-partitions automatically detaches those sub-partitions as well. This is common for rolling old data out, allowing further operations (backup, aggregation) before dropping the data."}),"\n",(0,a.jsx)(n.h3,{id:"truncate-a-partition",children:"Truncate a partition"}),"\n",(0,a.jsx)(n.p,{children:"Removes all data from a specific partition."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"TRUNCATE ONLY msales_other; -- Truncates only the specified partition\n"})}),"\n",(0,a.jsx)(n.p,{children:"If you truncate a partition that is itself partitioned, its sub-partitions are also truncated.\nTo truncate the entire partitioned table (all partitions):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"TRUNCATE msales;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"exchange-a-partition",children:"Exchange a partition"}),"\n",(0,a.jsx)(n.p,{children:"Swaps one table in place of an existing partition. This involves detaching the original partition and then attaching the new table as a partition."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"You can exchange partitions only at the lowest level of the hierarchy (leaf partitions containing data)."}),"\n",(0,a.jsx)(n.li,{children:"Cannot exchange a partition with a replicated table, another partitioned table, or a non-leaf child partition."}),"\n",(0,a.jsx)(n.li,{children:"The data in the table being attached must be valid against the partition constraints of the target partition."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"-- Assume msales_2021_new is a table with the correct structure and data for the 2021 partition\nALTER TABLE msales DETACH PARTITION msales_2021;\nALTER TABLE msales ATTACH PARTITION msales_2021_new FOR VALUES FROM (2021) TO (2022);\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>s});var a=t(67294);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);