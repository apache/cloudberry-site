"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[42266],{49503:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=t(85893),s=t(11151);const o={title:"Basics of Defining Tables"},i="Basics of Defining Tables",r={id:"operate-with-data/operate-with-db-objects/table-definition-basics",title:"Basics of Defining Tables",description:"A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable \u2014 it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. In addition, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table.",source:"@site/versioned_docs/version-2.x/operate-with-data/operate-with-db-objects/table-definition-basics.md",sourceDirName:"operate-with-data/operate-with-db-objects",slug:"/operate-with-data/operate-with-db-objects/table-definition-basics",permalink:"/docs/operate-with-data/operate-with-db-objects/table-definition-basics",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/operate-with-data/operate-with-db-objects/table-definition-basics.md",tags:[],version:"2.x",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1756189168,formattedLastUpdatedAt:"Aug 26, 2025",frontMatter:{title:"Basics of Defining Tables"},sidebar:"docsbars",previous:{title:"Create and Manage Tables",permalink:"/docs/operate-with-data/operate-with-db-objects/create-and-manage-tables"},next:{title:"Create and Manage Schemas",permalink:"/docs/operate-with-data/operate-with-db-objects/create-and-manage-schemas"}},l={},c=[{value:"Default column values",id:"default-column-values",level:2},{value:"Generated columns",id:"generated-columns",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"basics-of-defining-tables",children:"Basics of Defining Tables"}),"\n",(0,a.jsx)(n.p,{children:"A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable \u2014 it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. In addition, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table."}),"\n",(0,a.jsx)(n.p,{children:"Each column has a data type. The data type constrains the set of possible values that can be assigned to a column and assigns semantics to the data stored in the column so that it can be used for computations. For instance, a column declared to be of a numerical type will not accept arbitrary text strings, and the data stored in such a column can be used for mathematical computations. By contrast, a column declared to be of a character string type will accept almost any kind of data but it does not lend itself to mathematical calculations, although other operations such as string concatenation are available."}),"\n",(0,a.jsxs)(n.p,{children:["Apache Cloudberry includes a sizable set of built-in data types that fit many applications. Users can also define their own data types. Most built-in data types have obvious names and semantics. Some of the frequently used data types are ",(0,a.jsx)(n.code,{children:"integer"})," for whole numbers, ",(0,a.jsx)(n.code,{children:"numeric"})," for possibly fractional numbers, ",(0,a.jsx)(n.code,{children:"text"})," for character strings, ",(0,a.jsx)(n.code,{children:"date"})," for dates, ",(0,a.jsx)(n.code,{children:"time"})," for time-of-day values, and ",(0,a.jsx)(n.code,{children:"timestamp"})," for values containing both date and time."]}),"\n",(0,a.jsxs)(n.p,{children:["To create a table, you use the aptly named ",(0,a.jsx)(n.a,{href:"/docs/sql-stmts/create-table",children:(0,a.jsx)(n.code,{children:"CREATE TABLE"})})," command. In this command, you specify at least a name for the new table, the names of the columns and the data type of each column. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE my_first_table (\n    first_column text,\n    second_column integer\n);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This command creates a table named ",(0,a.jsx)(n.code,{children:"my_first_table"})," with two columns. The first column is named ",(0,a.jsx)(n.code,{children:"first_column"})," and has a data type of ",(0,a.jsx)(n.code,{children:"text"}),"; the second column has the name ",(0,a.jsx)(n.code,{children:"second_column"})," and the type ",(0,a.jsx)(n.code,{children:"integer"}),". The table and column names follow the identifier syntax explained in ",(0,a.jsx)(n.a,{href:"https://www.postgresql.org/docs/14/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS",children:"Identifiers and Key Words"})," in the PostgreSQL documentation. The type names are usually also identifiers, but there are some exceptions. The column list is comma-separated and surrounded by parentheses."]}),"\n",(0,a.jsx)(n.p,{children:"Normally, you would specify names for your tables and columns that convey the kind of data that they store, for example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric\n);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["(The ",(0,a.jsx)(n.code,{children:"numeric"})," type can store fractional components, as would be typical of monetary amounts.)"]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"When you create many interrelated tables, it is wise to choose a consistent naming pattern for the tables and columns. For instance, you might choose using singular or plural nouns for table names."})}),"\n",(0,a.jsx)(n.p,{children:"Apache Cloudberry limits the number of columns that a table can contain. Depending on the column types, the maximum is between 250 and 1600. Defining a table with anywhere near the maximum number of columns is highly unusual and often a questionable design."}),"\n",(0,a.jsxs)(n.p,{children:["If you no longer need a table, you can remove it using the ",(0,a.jsx)(n.a,{href:"/docs/sql-stmts/drop-table",children:(0,a.jsx)(n.code,{children:"DROP TABLE"})})," command. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"DROP TABLE my_first_table;\nDROP TABLE products;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Attempting to drop a table that does not exist is an error. It is common in SQL script files to unconditionally try to drop each table before creating it, ignoring any error messages, so that the script works whether or not the table exists. You can use the ",(0,a.jsx)(n.code,{children:"DROP TABLE IF EXISTS"})," variant to avoid the error messages, but this is not standard SQL."]}),"\n",(0,a.jsx)(n.h2,{id:"default-column-values",children:"Default column values"}),"\n",(0,a.jsx)(n.p,{children:"You can assign a column a default value. When a new row is created and no values are specified for some of the columns, Apache Cloudberry assigns those columns their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is."}),"\n",(0,a.jsx)(n.p,{children:"If you do not explicitly declare a default for a column, the default value is the null value, which can be considered to represent unknown data."}),"\n",(0,a.jsx)(n.p,{children:"In a table definition, specify the default value after the column data type. For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric DEFAULT 9.99\n);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The default value can be an expression, which Apache Cloudberry evaluates whenever the default value is inserted (not when the table is created). A common example is for a timestamp column to have a default of ",(0,a.jsx)(n.code,{children:"CURRENT_TIMESTAMP"}),', so that it gets set to the time of row insertion. Another common example is generating a "serial number" for each row. In Apache Cloudberry, you can do this as follows:']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE products (\n    product_no integer DEFAULT nextval('products_product_no_seq'),\n    ...\n);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["where the ",(0,a.jsx)(n.code,{children:"nextval()"})," function supplies successive values from a sequence object. This situation is sufficiently common that there's a special shorthand for it:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE products (\n    product_no SERIAL,\n    ...\n);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"generated-columns",children:"Generated columns"}),"\n",(0,a.jsx)(n.p,{children:"A generated column is a special column that is always computed from other columns; it is for columns what a view is for tables. There are two kinds of generated columns: stored and virtual. A stored generated column is computed when it is written (inserted or updated) and occupies storage as if it were a normal column. A virtual generated column occupies no storage and is computed when it is read."}),"\n",(0,a.jsx)(n.p,{children:"A virtual generated column is similar to a view and a stored generated column is similar to a materialized view (except that it is always updated automatically). Apache Cloudberry currently implements only stored generated columns."}),"\n",(0,a.jsxs)(n.p,{children:["To create a generated column, use the ",(0,a.jsx)(n.code,{children:"GENERATED ALWAYS AS"})," clause in ",(0,a.jsx)(n.code,{children:"CREATE TABLE"}),", for example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE people (\n    ...,\n    height_cm numeric,\n    height_in numeric GENERATED ALWAYS AS (height_cm / 2.54) STORED\n);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The keyword ",(0,a.jsx)(n.code,{children:"STORED"})," must be specified to choose the stored kind of generated column. See ",(0,a.jsx)(n.a,{href:"/docs/sql-stmts/create-table",children:(0,a.jsx)(n.code,{children:"CREATE TABLE"})})," for more details."]}),"\n",(0,a.jsxs)(n.p,{children:["You cannot write directly to a generated column. While you might not specify a value for a generated column in an ",(0,a.jsx)(n.code,{children:"INSERT"})," or ",(0,a.jsx)(n.code,{children:"UPDATE"})," command, you can specify the keyword ",(0,a.jsx)(n.code,{children:"DEFAULT"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Note the following differences between a column with a default and a generated column:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The column default is evaluated once when the row is first inserted if no other value was provided; a generated column is updated whenever the row changes and cannot be overridden."}),"\n",(0,a.jsx)(n.li,{children:"A column default might not refer to other columns of the table; a generation expression would normally do so."}),"\n",(0,a.jsxs)(n.li,{children:["A column default can use volatile functions, for example ",(0,a.jsx)(n.code,{children:"random()"})," or functions referring to the current time; Apache Cloudberry does not permit this for generated columns."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Several restrictions apply to the definition of generated columns and tables involving generated columns:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"The generation expression can use only immutable functions and cannot use subqueries or reference anything other than the current row in any way."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"A generation expression cannot reference another generated column."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["A generation expression cannot reference a system column, except ",(0,a.jsx)(n.code,{children:"tableoid"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"A generated column cannot have a column default or an identity definition."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"A generated column cannot be used as a distribution key."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"A generated column cannot be part of a partition key."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"You might specify a generated column in a root partitioned table but not in a child table."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"For inheritance:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["If a parent column is a generated column, a child column must also be a generated column using the same expression. Omit the ",(0,a.jsx)(n.code,{children:"GENERATED"})," clause in the definition of the child column, it will be copied from the parent."]}),"\n",(0,a.jsx)(n.li,{children:"In the case of multiple inheritance, if one parent column is a generated column, then all parent columns must be generated columns and with the same expression."}),"\n",(0,a.jsx)(n.li,{children:"If a parent column is not a generated column, a child column might be defined to be either a generated column or not."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Additional considerations apply to the use of generated columns:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Foreign tables can have generated columns. See ",(0,a.jsx)(n.a,{href:"/docs/sql-stmts/create-foreign-table",children:(0,a.jsx)(n.code,{children:"CREATE FOREIGN TABLE"})})," for details."]}),"\n",(0,a.jsx)(n.li,{children:"Generated columns maintain access privileges separately from their underlying base columns. So, it is possible to grant privileges such that a particular role can read from a generated column but not from the underlying base columns."}),"\n",(0,a.jsxs)(n.li,{children:["Generated columns are, conceptually, updated after ",(0,a.jsx)(n.code,{children:"BEFORE"})," triggers have run. Changes made to base columns in a ",(0,a.jsx)(n.code,{children:"BEFORE"})," trigger will be reflected in generated columns. But conversely, Apache Cloudberry does not permit access to generated columns in ",(0,a.jsx)(n.code,{children:"BEFORE"})," triggers."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>i});var a=t(67294);const s={},o=a.createContext(s);function i(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);