"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[76125],{48709:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>a});var n=t(85893),r=t(11151);const i={title:"pg_stat_progress_cluster"},d="pg_stat_progress_cluster",c={id:"sys-catalogs/sys-views/pg-stat-progress-cluster",title:"pg_stat_progress_cluster",description:"The pgstatprogress_cluster view shows the progress of CLUSTER and VACUUM FULL operations. Each row represents a backend process currently executing one of these commands, providing details such as the current phase, number of heap blocks scanned and written, and indexes rebuilt. This view helps monitor and manage long-running table reorganization tasks.",source:"@site/docs/sys-catalogs/sys-views/pg-stat-progress-cluster.md",sourceDirName:"sys-catalogs/sys-views",slug:"/sys-catalogs/sys-views/pg-stat-progress-cluster",permalink:"/docs/next/sys-catalogs/sys-views/pg-stat-progress-cluster",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sys-catalogs/sys-views/pg-stat-progress-cluster.md",tags:[],version:"current",lastUpdatedBy:"TomShawn",lastUpdatedAt:1748250627,formattedLastUpdatedAt:"May 26, 2025",frontMatter:{title:"pg_stat_progress_cluster"},sidebar:"docsbars",previous:{title:"pg_stat_progress_basebackup",permalink:"/docs/next/sys-catalogs/sys-views/pg-stat-progress-basebackup"},next:{title:"pg_stat_progress_copy",permalink:"/docs/next/sys-catalogs/sys-views/pg-stat-progress-copy"}},o={},a=[];function l(e){const s={code:"code",h1:"h1",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"pg_stat_progress_cluster",children:"pg_stat_progress_cluster"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"pg_stat_progress_cluster"})," view shows the progress of ",(0,n.jsx)(s.code,{children:"CLUSTER"})," and ",(0,n.jsx)(s.code,{children:"VACUUM FULL"})," operations. Each row represents a backend process currently executing one of these commands, providing details such as the current phase, number of heap blocks scanned and written, and indexes rebuilt. This view helps monitor and manage long-running table reorganization tasks."]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Column"}),(0,n.jsx)(s.th,{children:"Type"}),(0,n.jsx)(s.th,{children:"Description"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"gp_segment_id"})}),(0,n.jsx)(s.td,{children:"integer"}),(0,n.jsxs)(s.td,{children:["Unique identifier of a segment (or coordinator) instance. (This column is not present in the ",(0,n.jsx)(s.code,{children:"gp_stat_progress_cluster_summary"})," view.)"]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"pid"})}),(0,n.jsx)(s.td,{children:"integer"}),(0,n.jsxs)(s.td,{children:["Process identifier of the backend, or the coordinator process identifier if the ",(0,n.jsx)(s.code,{children:"gp_stat_progress_cluster_summary"})," view."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"datid"})}),(0,n.jsx)(s.td,{children:"oid"}),(0,n.jsx)(s.td,{children:"The object identifier of the database to which this backend is connected."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"datname"})}),(0,n.jsx)(s.td,{children:"name"}),(0,n.jsx)(s.td,{children:"Name of the database to which this backend is connected."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"relid"})}),(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"oid"})}),(0,n.jsx)(s.td,{children:"The object identifier of the table being clustered."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"command"})}),(0,n.jsx)(s.td,{children:"text"}),(0,n.jsxs)(s.td,{children:["The name of the command that is running. Either ",(0,n.jsx)(s.code,{children:"CLUSTER"})," or ",(0,n.jsx)(s.code,{children:"VACUUM FULL"}),"."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"phase"})}),(0,n.jsx)(s.td,{children:"text"}),(0,n.jsx)(s.td,{children:"Current processing phase."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"cluster_index_relid"})}),(0,n.jsx)(s.td,{children:"oid"}),(0,n.jsx)(s.td,{children:"If the table is being scanned using an index, this is the object identifier of the index being used; otherwise, it is zero. This field is not applicable to AO/CO tables."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"heap_tuples_scanned"})}),(0,n.jsx)(s.td,{children:"bigint"}),(0,n.jsxs)(s.td,{children:["For heap tables, ",(0,n.jsx)(s.code,{children:"heap_tuples_scanned"})," records the number of tuples scanned, including both live and dead tuples. For AO tables, ",(0,n.jsx)(s.code,{children:"heap_tuples_scanned"})," records the number of live tuples scanned, excluding the dead tuples. This counter only advances when the phase is ",(0,n.jsx)(s.code,{children:"seq scanning append-optimized"}),", ",(0,n.jsx)(s.code,{children:"seq scanning heap"}),", ",(0,n.jsx)(s.code,{children:"index scanning heap"}),", or ",(0,n.jsx)(s.code,{children:"writing new heap"}),". For AO/CO tables, Apache Cloudberry converts byte size into equivalent heap blocks in size."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"heap_tuples_written"})}),(0,n.jsx)(s.td,{children:"bigint"}),(0,n.jsxs)(s.td,{children:["Number of tuples written. This counter only advances when the phase is ",(0,n.jsx)(s.code,{children:"seq scanning heap"}),", ",(0,n.jsx)(s.code,{children:"index scanning heap"}),", ",(0,n.jsx)(s.code,{children:"writing new append-optimized"}),", or ",(0,n.jsx)(s.code,{children:"writing new heap"}),"."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"heap_blks_total"})}),(0,n.jsx)(s.td,{children:"bigint"}),(0,n.jsxs)(s.td,{children:["Total number of heap blocks in the table. This number is reported as of the beginning of ",(0,n.jsx)(s.code,{children:"seq scanning heap"}),". For AO/CO tables, Apache Cloudberry converts byte size into equivalent heap blocks in size."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"heap_blks_scanned"})}),(0,n.jsx)(s.td,{children:"bigint"}),(0,n.jsxs)(s.td,{children:["Number of heap blocks scanned. This counter only advances when the phase is ",(0,n.jsx)(s.code,{children:"seq scanning heap"}),". For AO/CO tables, Apache Cloudberry converts byte size into equivalent heap blocks in size."]})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"index_rebuild_count"})}),(0,n.jsx)(s.td,{children:"bigint"}),(0,n.jsxs)(s.td,{children:["Number of indexes rebuilt. This counter only advances when the phase is ",(0,n.jsx)(s.code,{children:"rebuilding index"}),", and is not applicable to AO/CO tables."]})]})]})]})]})}function h(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},11151:(e,s,t)=>{t.d(s,{Z:()=>c,a:()=>d});var n=t(67294);const r={},i=n.createContext(r);function d(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);