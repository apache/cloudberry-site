"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[19366],{66804:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var n=s(85893),a=s(11151);const i={title:"Distribution and Skew"},o="Distribution and Skew",r={id:"performance/distribution-and-skew",title:"Distribution and Skew",description:"Apache Cloudberry relies on even distribution of data across segments.",source:"@site/versioned_docs/version-2.x/performance/distribution-and-skew.md",sourceDirName:"performance",slug:"/performance/distribution-and-skew",permalink:"/docs/performance/distribution-and-skew",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/performance/distribution-and-skew.md",tags:[],version:"2.x",lastUpdatedBy:"Leonid Borchuk",lastUpdatedAt:1756090353,formattedLastUpdatedAt:"Aug 25, 2025",frontMatter:{title:"Distribution and Skew"},sidebar:"docsbars",previous:{title:"Query Plan Hints",permalink:"/docs/performance/optimize-queries/query-hints"},next:{title:"Memory Overview",permalink:"/docs/performance/memory-overview"}},d={},c=[{value:"Local (co-located) joins",id:"local-co-located-joins",level:2},{value:"Data skew",id:"data-skew",level:2},{value:"Considerations for replicated tables",id:"considerations-for-replicated-tables",level:3},{value:"Process skew",id:"process-skew",level:2}];function l(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"distribution-and-skew",children:"Distribution and Skew"}),"\n",(0,n.jsx)(t.p,{children:"Apache Cloudberry relies on even distribution of data across segments."}),"\n",(0,n.jsx)(t.p,{children:"In an MPP shared nothing environment, overall response time for a query is measured by the completion time for all segments. The system is only as fast as the slowest segment. If the data is skewed, segments with more data will take more time to complete, so every segment must have an approximately equal number of rows and perform approximately the same amount of processing. Poor performance and out of memory conditions may result if one segment has significantly more data to process than other segments."}),"\n",(0,n.jsx)(t.p,{children:"Optimal distributions are critical when joining large tables together. To perform a join, matching rows must be located together on the same segment. If data is not distributed on the same join column, the rows needed from one of the tables are dynamically redistributed to the other segments. In some cases a broadcast motion, in which each segment sends its individual rows to all other segments, is performed rather than a redistribution motion, where each segment rehashes the data and sends the rows to the appropriate segments according to the hash key."}),"\n",(0,n.jsx)(t.h2,{id:"local-co-located-joins",children:"Local (co-located) joins"}),"\n",(0,n.jsxs)(t.p,{children:["Using a hash distribution that evenly distributes table rows across all segments and results in local joins can provide substantial performance gains. When joined rows are on the same segment, much of the processing can be accomplished within the segment instance. These are called ",(0,n.jsx)(t.em,{children:"local"})," or ",(0,n.jsx)(t.em,{children:"co-located"})," joins. Local joins minimize data movement; each segment operates independently of the other segments, without network traffic or communications between segments."]}),"\n",(0,n.jsxs)(t.p,{children:["To achieve local joins for large tables commonly joined together, distribute the tables on the same column. Local joins require that both sides of a join be distributed on the same columns (and in the same order) ",(0,n.jsx)(t.em,{children:"and"})," that all columns in the distribution clause are used when joining tables. The distribution columns must also be the same data type\u2014although some values with different data types may appear to have the same representation, they are stored differently and hash to different values, so they are stored on different segments."]}),"\n",(0,n.jsx)(t.h2,{id:"data-skew",children:"Data skew"}),"\n",(0,n.jsx)(t.p,{children:"Data skew may be caused by uneven data distribution due to the wrong choice of distribution keys or single tuple table insert or copy operations. Present at the table level, data skew, is often the root cause of poor query performance and out of memory conditions. Skewed data affects scan (read) performance, but it also affects all other query execution operations, for instance, joins and group by operations."}),"\n",(0,n.jsxs)(t.p,{children:["It is very important to ",(0,n.jsx)(t.em,{children:"validate"})," distributions to ",(0,n.jsx)(t.em,{children:"ensure"})," that data is evenly distributed after the initial load. It is equally important to ",(0,n.jsx)(t.em,{children:"continue"})," to validate distributions after incremental loads."]}),"\n",(0,n.jsx)(t.p,{children:"The following query shows the number of rows per segment as well as the variance from the minimum and maximum numbers of rows:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:'SELECT \'Example Table\' AS "Table Name", \n    max(c) AS "Max Seg Rows", min(c) AS "Min Seg Rows", \n    (max(c)-min(c))*100.0/max(c) AS "Percentage Difference Between Max & Min" \nFROM (SELECT count(*) c, gp_segment_id FROM facts GROUP BY 2) AS a;\n'})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"gp_toolkit"})," schema has two views that you can use to check for skew."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.code,{children:"gp_toolkit.gp_skew_coefficients"})," view shows data distribution skew by calculating the coefficient of variation (CV) for the data stored on each segment. The ",(0,n.jsx)(t.code,{children:"skccoeff"})," column shows the coefficient of variation (CV), which is calculated as the standard deviation divided by the average. It takes into account both the average and variability around the average of a data series. The lower the value, the better. Higher values indicate greater data skew."]}),"\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.code,{children:"gp_toolkit.gp_skew_idle_fractions"})," view shows data distribution skew by calculating the percentage of the system that is idle during a table scan, which is an indicator of computational skew. The ",(0,n.jsx)(t.code,{children:"siffraction"})," column shows the percentage of the system that is idle during a table scan. This is an indicator of uneven data distribution or query processing skew. For example, a value of 0.1 indicates 10% skew, a value of 0.5 indicates 50% skew, and so on. Tables that have more than10% skew should have their distribution policies evaluated."]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"considerations-for-replicated-tables",children:"Considerations for replicated tables"}),"\n",(0,n.jsxs)(t.p,{children:["When you create a replicated table (with the ",(0,n.jsx)(t.code,{children:"CREATE TABLE"})," clause ",(0,n.jsx)(t.code,{children:"DISTRIBUTED REPLICATED"}),"), Apache Cloudberry distributes every table row to every segment instance. Replicated table data is evenly distributed because every segment has the same rows. A query that uses the ",(0,n.jsx)(t.code,{children:"gp_segment_id"})," system column on a replicated table to verify evenly distributed data, will fail because Apache Cloudberry does not allow queries to reference replicated tables' system columns."]}),"\n",(0,n.jsx)(t.h2,{id:"process-skew",children:"Process skew"}),"\n",(0,n.jsx)(t.p,{children:"Processing skew results when a disproportionate amount of data flows to, and is processed by, one or a few segments. It is often the culprit behind Apache Cloudberry performance and stability issues. It can happen with operations such join, sort, aggregation, and various OLAP operations. Processing skew happens in flight while a query is running and is not as easy to detect as data skew."}),"\n",(0,n.jsx)(t.p,{children:"If single segments are failing, that is, not all segments on a host, it may be a processing skew issue. Identifying processing skew is currently a manual process. First look for spill files. If there is skew, but not enough to cause spill, it will not become a performance issue. If you determine skew exists, then find the query responsible for the skew."}),"\n",(0,n.jsx)(t.p,{children:"The remedy for processing skew in almost all cases is to rewrite the query. Creating temporary tables can eliminate skew. Temporary tables can be randomly distributed to force a two-stage aggregation."})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>r,a:()=>o});var n=s(67294);const a={},i=n.createContext(a);function o(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);