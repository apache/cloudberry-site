"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[93188],{71032:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var t=a(85893),s=a(11151);const i={title:"BRIN Indexes"},r="BRIN Indexes",o={id:"operate-with-data/operate-with-db-objects/brin-indexes",title:"BRIN Indexes",description:"When a table is very large and the values of certain columns are naturally correlated with their physical storage locations, you can use block range indexes (BRIN). A BRIN index summarizes values for a range of blocks (or pages), where each range includes a group of physically adjacent pages in the table. For example, in a table that stores order data, earlier orders tend to appear at the beginning of the table. Similarly, in a table of postal codes, codes from the same city may be physically clustered.",source:"@site/docs/operate-with-data/operate-with-db-objects/brin-indexes.md",sourceDirName:"operate-with-data/operate-with-db-objects",slug:"/operate-with-data/operate-with-db-objects/brin-indexes",permalink:"/docs/next/operate-with-data/operate-with-db-objects/brin-indexes",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/operate-with-data/operate-with-db-objects/brin-indexes.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1756093629,formattedLastUpdatedAt:"Aug 25, 2025",frontMatter:{title:"BRIN Indexes"},sidebar:"docsbars",previous:{title:"Create and Manage Indexes",permalink:"/docs/next/operate-with-data/operate-with-db-objects/create-and-manage-indexes"},next:{title:"Create and Manage Partitioned Tables",permalink:"/docs/next/operate-with-data/operate-with-db-objects/create-and-manage-partitioned-tables"}},d={},l=[{value:"Maintain BRIN indexes",id:"maintain-brin-indexes",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"brin-indexes",children:"BRIN Indexes"}),"\n",(0,t.jsx)(n.p,{children:"When a table is very large and the values of certain columns are naturally correlated with their physical storage locations, you can use block range indexes (BRIN). A BRIN index summarizes values for a range of blocks (or pages), where each range includes a group of physically adjacent pages in the table. For example, in a table that stores order data, earlier orders tend to appear at the beginning of the table. Similarly, in a table of postal codes, codes from the same city may be physically clustered."}),"\n",(0,t.jsx)(n.p,{children:'BRIN indexes participate in queries using bitmap index scans. When the summary information in the index matches the query condition, the query accesses all pages within that block range and returns all tuples found. The executor then verifies these tuples one by one and filters out those that do not satisfy the condition. For this reason, BRIN is a "lossy" index. Since BRIN indexes are typically very small, they introduce minimal overhead compared to sequential scans, while enabling the system to skip many unrelated blocks.'}),"\n",(0,t.jsx)(n.p,{children:"The type of data a BRIN index stores and the queries it can accelerate depend on the operator class selected for each column. For linearly ordered data types, the index records the minimum and maximum values within each range. For geometric types, it stores the bounding box that encloses all objects in the range."}),"\n",(0,t.jsxs)(n.p,{children:["The size of each block range is determined by the ",(0,t.jsx)(n.code,{children:"pages_per_range"})," parameter at index creation. The number of index entries equals the total number of pages in the table divided by ",(0,t.jsx)(n.code,{children:"pages_per_range"}),". A smaller value leads to a larger index (more entries), but the summaries become more fine-grained, allowing the scan to skip more unrelated data blocks. The default ",(0,t.jsx)(n.code,{children:"pages_per_range"})," value is ",(0,t.jsx)(n.code,{children:"32"})," for heap tables and ",(0,t.jsx)(n.code,{children:"1"})," for append-optimized tables."]}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsxs)(n.p,{children:["Starting from v2.0.0, BRIN indexes are supported on AO and CO tables. A chained revmap structure is used to optimize storage and reduce space usage. This optimization improves both storage layout and summary maintenance, and allows summaries to be generated manually using ",(0,t.jsx)(n.code,{children:"brin_summarize_range()"}),"."]}),(0,t.jsx)(n.p,{children:"Although BRIN indexes can be created and maintained on AO/CO tables, whether the query planner chooses to use them depends on query predicates, data distribution, page count, and the heuristic cost model. As such, not all BRIN use cases lead to automatic performance gains. BRIN is best suited for large datasets with strong data clustering."})]}),"\n",(0,t.jsx)(n.h2,{id:"maintain-brin-indexes",children:"Maintain BRIN indexes"}),"\n",(0,t.jsx)(n.p,{children:'When a BRIN index is created, Apache Cloudberry scans existing heap pages and generates summary tuples for each block range, including the possibly incomplete tail range. As new data fills additional pages, the system attempts to update the summary information for ranges that have already been summarized. However, for ranges that have not yet been summarized, the system does not automatically create summary tuples. These ranges remain in an "unsummarized" state and require manual intervention to generate summaries.'}),"\n",(0,t.jsx)(n.p,{children:"You can generate initial summaries using the following methods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["During a ",(0,t.jsx)(n.code,{children:"VACUUM"})," operation, the system automatically summarizes all unprocessed block ranges."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Alternatively, you can manually control summarization using the following functions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"brin_summarize_new_values(regclass)"}),": summarizes all unprocessed block ranges."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"brin_summarize_range(regclass, bigint)"}),": summarizes only the range containing the specified page, if it has not been summarized."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To remove summary information instead, you can use the ",(0,t.jsx)(n.code,{children:"brin_desummarize_range(regclass, bigint)"})," function to clear summaries for a specific range. This is especially useful when data changes make existing summaries inaccurate."]}),"\n",(0,t.jsx)(n.p,{children:"The table below lists the functions available for BRIN index maintenance. These functions cannot be executed in recovery mode and are restricted to superusers or the index owner."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Return type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"brin_summarize_new_values(index regclass)"})}),(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"Summarizes all unprocessed block ranges."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"brin_summarize_range(index regclass, blockNumber bigint)"})}),(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"Summarizes the range containing the specified block, if not already summarized."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"brin_desummarize_range(index regclass, blockNumber bigint)"})}),(0,t.jsx)(n.td,{children:"integer"}),(0,t.jsx)(n.td,{children:"Removes the summary for the range containing the specified block, if already summarized."})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"brin_summarize_new_values"})," function accepts an index name or OID and automatically finds unsummarized ranges. It scans the corresponding table pages and generates new summary index tuples. It returns the number of summary entries created. The ",(0,t.jsx)(n.code,{children:"brin_summarize_range"})," function processes only the range that contains the specified block number."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Normally, after running ",(0,t.jsx)(n.code,{children:"VACUUM"}),", the ",(0,t.jsx)(n.code,{children:"brin_summarize_new_values()"})," function does not generate new summaries because the default behavior includes summarizing all newly added block ranges during cleanup. This function is mainly used for manual summary refreshes, which is useful when auto-vacuum is disabled or the table is frequently updated."]}),"\n",(0,t.jsx)(n.li,{children:"If the table has few pages or the query predicate is not selective enough, the planner might still choose not to use a BRIN index path."}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"brin_summarize_range"})," and ",(0,t.jsx)(n.code,{children:"brin_desummarize_range"})," functions only affect ranges that actually exist. If a non-existent block number is provided, the function returns ",(0,t.jsx)(n.code,{children:"0"}),". Due to uneven data distribution, some ranges may exist only on a subset of segments. In that case, the function returns the number of segments that successfully processed the range."]}),"\n"]})})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,a)=>{a.d(n,{Z:()=>o,a:()=>r});var t=a(67294);const s={},i=t.createContext(s);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);