"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[8144],{32137:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var s=i(85893),o=i(11151);const t={title:"GPORCA Optimizer Update Notes"},r="GPORCA Optimizer Update Notes",l={id:"performance/optimize-queries/use-orca/whats-new-in-orca",title:"GPORCA Optimizer Update Notes",description:"This document describes feature enhancements and behavioral changes to the GPORCA optimizer in each version of Apache Cloudberry.",source:"@site/versioned_docs/version-2.x/performance/optimize-queries/use-orca/whats-new-in-orca.md",sourceDirName:"performance/optimize-queries/use-orca",slug:"/performance/optimize-queries/use-orca/whats-new-in-orca",permalink:"/docs/performance/optimize-queries/use-orca/whats-new-in-orca",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/performance/optimize-queries/use-orca/whats-new-in-orca.md",tags:[],version:"2.x",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1751854107,formattedLastUpdatedAt:"Jul 7, 2025",frontMatter:{title:"GPORCA Optimizer Update Notes"},sidebar:"docsbars",previous:{title:"GPORCA Features and Enhancements",permalink:"/docs/performance/optimize-queries/use-orca/orca-features"},next:{title:"Collect Root Partition Statistics",permalink:"/docs/performance/optimize-queries/use-orca/gporca-collect-root-partition-stats"}},a={},c=[{value:"v2.0.0",id:"v200",level:2},{value:"Optimization for self-joins with multiple outer joins",id:"optimization-for-self-joins-with-multiple-outer-joins",level:3}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"gporca-optimizer-update-notes",children:"GPORCA Optimizer Update Notes"}),"\n",(0,s.jsx)(n.p,{children:"This document describes feature enhancements and behavioral changes to the GPORCA optimizer in each version of Apache Cloudberry."}),"\n",(0,s.jsx)(n.h2,{id:"v200",children:"v2.0.0"}),"\n",(0,s.jsx)(n.p,{children:"Starting from v2.0.0, the GPORCA optimizer includes the following new features and improvements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"In addition to previously supported index-only scans on B-tree indexes, GPORCA now supports index-only scans on more index types. Specifically:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Index-only scans are now supported on AO tables and PAX tables."}),"\n",(0,s.jsxs)(n.li,{children:["PostgreSQL-style ",(0,s.jsx)(n.code,{children:"INCLUDE"})," columns are supported, enabling the creation of covering indexes on AO and PAX tables to improve performance in repeated-read workloads."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["GPORCA can now automatically choose backward index scans based on the sort direction of a query. This applies to both regular and index-only scans. This optimization reduces the need for ",(0,s.jsx)(n.code,{children:"Sort"})," nodes and can improve performance in certain top-N queries."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Support has been added for pushing down ",(0,s.jsx)(n.code,{children:"ScalarArrayOp"})," predicates (e.g., ",(0,s.jsx)(n.code,{children:"col IN (...)"})," or ",(0,s.jsx)(n.code,{children:"col = ANY(array)"}),") to index paths, including:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"B-tree or hash indexes;"}),"\n",(0,s.jsx)(n.li,{children:"Index Scan or Bitmap Index Scan paths."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The optimizer decides whether to use a Bitmap scan based on cost estimation. In low-selectivity cases, it may still fall back to sequential scan. Note that ",(0,s.jsx)(n.code,{children:"ScalarArrayOp"})," pushdown only applies to the leading column of an index, and not to non-leading columns in composite indexes."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX idx ON t(col1, col2);\nSELECT * FROM t WHERE col1 = ANY('{1,2,3}');  -- Pushdown supported\nSELECT * FROM t WHERE col2 = ANY('{1,2,3}');  -- No pushdown, used as filter only\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Support for ",(0,s.jsx)(n.code,{children:"FULL JOIN"})," has been added, using the ",(0,s.jsx)(n.code,{children:"Hash Full Join"})," execution strategy. This implementation does not require sorting of join keys and is well-suited for large datasets, high-cardinality join keys, or mismatched distribution keys."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Merge Full Join"})," is not currently supported, so all ",(0,s.jsx)(n.code,{children:"FULL JOIN"})," queries use ",(0,s.jsx)(n.code,{children:"Hash Full Join"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Compared to traditional ",(0,s.jsx)(n.code,{children:"Merge Join"}),", ",(0,s.jsx)(n.code,{children:"Hash Full Join"})," offers the following advantages:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"No sorting required on join keys;"}),"\n",(0,s.jsx)(n.li,{children:"Reduced data movement (Motion) overhead;"}),"\n",(0,s.jsx)(n.li,{children:"Potentially better performance when join keys are highly skewed or have high cardinality."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"EXPLAIN SELECT * FROM t1 FULL JOIN t2 ON t1.id = t2.id;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Might produce the following plan:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"Hash Full Join\nHash Cond: t1.id = t2.id\n...\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["GPORCA introduces a query rewrite rule that pushes ",(0,s.jsx)(n.code,{children:"JOIN"})," operations below each branch of a ",(0,s.jsx)(n.code,{children:"UNION ALL"}),". When enabled, the optimizer may rewrite a ",(0,s.jsx)(n.code,{children:"JOIN"})," over a ",(0,s.jsx)(n.code,{children:"UNION ALL"})," into multiple smaller joins. This can significantly improve performance by:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Converting a large join over a ",(0,s.jsx)(n.code,{children:"UNION ALL"})," into multiple smaller joins."]}),"\n",(0,s.jsxs)(n.li,{children:["Allowing each sub-join to use indexes independently, reducing Motion and ",(0,s.jsx)(n.code,{children:"Hash Join"})," overhead."]}),"\n",(0,s.jsxs)(n.li,{children:["Pushing the ",(0,s.jsx)(n.code,{children:"JOIN"})," to either the left or right side of the ",(0,s.jsx)(n.code,{children:"UNION ALL"}),", enabling more flexible query structures."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This optimization is disabled by default. You can enable it with the following GUC:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SET optimizer_enable_push_join_below_union_all = on;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The following example shows how the optimizer pushes the ",(0,s.jsx)(n.code,{children:"JOIN"})," below each ",(0,s.jsx)(n.code,{children:"UNION ALL"})," branch when the optimization is enabled:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Creates test tables\nCREATE TABLE dist_small_1(c1 int);\nINSERT INTO dist_small_1 SELECT generate_series(1, 1000);\nCREATE INDEX dist_small_1_index ON dist_small_1 USING btree (c1);\nANALYZE dist_small_1;\n\nCREATE TABLE dist_small_2(c1 int);\nINSERT INTO dist_small_2 SELECT generate_series(1, 1000);\nANALYZE dist_small_2;\n\nCREATE TABLE inner_1(cc int);\nINSERT INTO inner_1 VALUES(1);\nANALYZE inner_1;\n\n-- Creates a view\nCREATE VIEW dist_view_small AS\nSELECT c1 FROM dist_small_1\nUNION ALL\nSELECT c1 FROM dist_small_2;\n\n-- Enables the optimization and run the query\nSET optimizer_enable_push_join_below_union_all = on;\nEXPLAIN ANALYZE\nSELECT c1 FROM dist_view_small JOIN inner_1 ON c1 < cc;\n"})}),"\n",(0,s.jsx)(n.p,{children:"The optimizer might produce a plan like the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"->  Append\n    ->  Nested Loop\n            ...\n            ->  Index Scan using dist_small_1_index on dist_small_1\n    ->  Nested Loop\n            ...\n            ->  Seq Scan on dist_small_2\n"})}),"\n",(0,s.jsx)(n.p,{children:"This optimization is especially useful for the following types of queries:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"UNION ALL"})," over large tables joined with a small table."]}),"\n",(0,s.jsx)(n.li,{children:"Each branch has indexes that the optimizer can use."}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"JOIN"})," is applied to a view or subquery that contains a ",(0,s.jsx)(n.code,{children:"UNION ALL"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["This optimization does not support ",(0,s.jsx)(n.code,{children:"FULL JOIN"})," or Common Table Expressions (CTEs)."]}),"\n",(0,s.jsxs)(n.li,{children:["It also does not support ",(0,s.jsx)(n.code,{children:"JOIN of UNION ALL"})," or ",(0,s.jsx)(n.code,{children:"UNION ALL of JOIN"})," structures."]}),"\n"]})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["By default, GPORCA assigns a higher cost to broadcast paths (Broadcast Motion) using the ",(0,s.jsx)(n.code,{children:"optimizer_penalize_broadcast_threshold"})," GUC parameter, to avoid choosing expensive plans when data volumes are large."]}),"\n",(0,s.jsxs)(n.p,{children:["Starting from v2.0.0, for ",(0,s.jsx)(n.code,{children:"NOT IN"})," queries (for example, Left Anti Semi Join, LASJ), broadcast paths are no longer penalized. This prevents the optimizer from concentrating large tables on the coordinator, which can otherwise lead to severe performance issues or even out-of-memory (OOM) errors."]}),"\n",(0,s.jsxs)(n.p,{children:["Allowing broadcast paths helps preserve parallel execution and significantly improves the performance of ",(0,s.jsx)(n.code,{children:"NOT IN"})," queries on large datasets."]}),"\n",(0,s.jsx)(n.p,{children:"Feature details:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Applies only to ",(0,s.jsx)(n.code,{children:"NOT IN"})," queries (LASJ)."]}),"\n",(0,s.jsxs)(n.li,{children:["Ignores the setting of ",(0,s.jsx)(n.code,{children:"optimizer_penalize_broadcast_threshold"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The penalty strategy remains in place for other types of joins (such as ",(0,s.jsx)(n.code,{children:"IN"})," or ",(0,s.jsx)(n.code,{children:"EXISTS"}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM foo WHERE a NOT IN (SELECT a FROM bar);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Sample query plan:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"Gather Motion 2:1\n-> Hash Left Anti Semi (Not-In) Join\n    -> Seq Scan on foo\n    -> Broadcast Motion\n            -> Seq Scan on bar\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"GPORCA now supports index-only scans inside common table expressions (CTEs). In the example below, the CTE query can trigger an index-only scan:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t(a int, b int);\nCREATE INDEX i ON t(a);\nINSERT INTO t SELECT i, i+i FROM generate_series(1, 10)i;\nVACUUM ANALYZE t;\n\nEXPLAIN WITH cte AS (SELECT a FROM t WHERE a > 42) SELECT * FROM cte;\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"optimization-for-self-joins-with-multiple-outer-joins",children:"Optimization for self-joins with multiple outer joins"}),"\n",(0,s.jsx)(n.p,{children:"Starting from v2.0.0, GPORCA can identify specific patterns involving multiple outer joins and skip unnecessary Redistribute Motion operations to improve execution efficiency:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The query contains multiple LEFT OUTER JOIN or RIGHT OUTER JOIN operations."}),"\n",(0,s.jsx)(n.li,{children:"All joined tables are aliases of the same base table."}),"\n",(0,s.jsxs)(n.li,{children:["The join conditions are symmetric (e.g., ",(0,s.jsx)(n.code,{children:"t1.a = t2.a"}),")."]}),"\n",(0,s.jsx)(n.li,{children:"All tables use the same distribution key and satisfy locality constraints."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE o1 (a1 int, b1 int) DISTRIBUTED BY (a1);\n\nEXPLAIN (COSTS OFF)\nSELECT * FROM (SELECT DISTINCT a1 FROM o1) t1\n             LEFT OUTER JOIN o1 t2 ON t1.a1 = t2.a1\n             LEFT OUTER JOIN o1 t3 ON t2.a1 = t3.a1;\n"})}),"\n",(0,s.jsx)(n.p,{children:"In earlier versions, this query would insert Redistribute Motion between each join level. Starting from v2.0.0, GPORCA can detect this multi-level self-join pattern and avoid unnecessary data redistribution, improving overall query performance."})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>r});var s=i(67294);const o={},t=s.createContext(o);function r(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);