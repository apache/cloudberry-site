"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[93727],{81862:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>o});var i=s(85893),n=s(11151);const d={title:"pg_replication_slots"},r="pg_replication_slots",l={id:"sys-catalogs/sys-views/pg-replication-slots",title:"pg_replication_slots",description:"The pgreplicationslots view provides a listing of all replication slots that currently exist on the database cluster, along with their current state. It includes information such as slot name, type (physical or logical), associated database, activity status, and WAL positions. This view is essential for monitoring replication slot usage and ensuring proper replication behavior.",source:"@site/docs/sys-catalogs/sys-views/pg-replication-slots.md",sourceDirName:"sys-catalogs/sys-views",slug:"/sys-catalogs/sys-views/pg-replication-slots",permalink:"/docs/next/sys-catalogs/sys-views/pg-replication-slots",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sys-catalogs/sys-views/pg-replication-slots.md",tags:[],version:"current",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1756375262,formattedLastUpdatedAt:"Aug 28, 2025",frontMatter:{title:"pg_replication_slots"},sidebar:"docsbars",previous:{title:"pg_replication_origin_status",permalink:"/docs/next/sys-catalogs/sys-views/pg-replication-origin-status"},next:{title:"pg_stat_all_tables",permalink:"/docs/next/sys-catalogs/sys-views/pg-stat-all-tables"}},a={},o=[];function c(e){const t={code:"code",h1:"h1",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"pg_replication_slots",children:"pg_replication_slots"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"pg_replication_slots"})," view provides a listing of all replication slots that currently exist on the database cluster, along with their current state. It includes information such as slot name, type (physical or logical), associated database, activity status, and WAL positions. This view is essential for monitoring replication slot usage and ensuring proper replication behavior."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"name"}),(0,i.jsx)(t.th,{children:"type"}),(0,i.jsx)(t.th,{children:"references"}),(0,i.jsx)(t.th,{children:"description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"slot_name"})}),(0,i.jsx)(t.td,{children:"name"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"A unique, cluster-wide identifier for the replication slot."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"plugin"})}),(0,i.jsx)(t.td,{children:"name"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"The base name of the shared object containing the output plugin this logical slot is using, or null for physical slots."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"slot_type"})}),(0,i.jsx)(t.td,{children:"text"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"The slot type - physical or logical."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"datoid"})}),(0,i.jsx)(t.td,{children:"oid"}),(0,i.jsx)(t.td,{children:"pg_database.oid"}),(0,i.jsx)(t.td,{children:"The OID of the database this slot is associated with, or null. Only logical slots have an associated database."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"database"})}),(0,i.jsx)(t.td,{children:"name"}),(0,i.jsx)(t.td,{children:"pg_database.datname"}),(0,i.jsx)(t.td,{children:"The name of the database this slot is associated with, or null. Only logical slots have an associated database."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"temporary"})}),(0,i.jsx)(t.td,{children:"boolean"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"True if this is a temporary replication slot. Temporary slots are not saved to disk and are automatically dropped on error or when the session has finished."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"active"})}),(0,i.jsx)(t.td,{children:"boolean"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"True if this slot is currently actively being used."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"active_pid"})}),(0,i.jsx)(t.td,{children:"integer"}),(0,i.jsx)(t.td,{}),(0,i.jsxs)(t.td,{children:["The process ID of the session using this slot if the slot is currently actively being used. ",(0,i.jsx)(t.code,{children:"NULL"})," if inactive."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"xmin"})}),(0,i.jsx)(t.td,{children:"xid"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"The oldest transaction that this slot needs the database to retain. VACUUM cannot remove tuples deleted by any later transaction."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"catalog_xmin"})}),(0,i.jsx)(t.td,{children:"xid"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"The oldest transaction affecting the system catalogs that this slot needs the database to retain. VACUUM cannot remove catalog tuples deleted by any later transaction."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"restart_ls"}),"n"]}),(0,i.jsx)(t.td,{children:"pg_lsn"}),(0,i.jsx)(t.td,{}),(0,i.jsxs)(t.td,{children:["The address (LSN) of oldest WAL which still might be required by the consumer of this slot and thus won't be automatically removed during checkpoints. ",(0,i.jsx)(t.code,{children:"NULL"})," if the LSN of this slot has never been reserved."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"confirmed_flush_lsn"})}),(0,i.jsx)(t.td,{children:"pg_lsn"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"The address (LSN) up to which the logical slot's consumer has confirmed receiving data. Data older than this is not available anymore. NULL for physical slots."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"wal_status"})}),(0,i.jsx)(t.td,{children:"text"}),(0,i.jsx)(t.td,{}),(0,i.jsxs)(t.td,{children:["Indicates the availability of WAL files for the replication slot. Possible values include ",(0,i.jsx)(t.code,{children:"reserved"}),", ",(0,i.jsx)(t.code,{children:"extended"}),", ",(0,i.jsx)(t.code,{children:"unreserved"}),", and ",(0,i.jsx)(t.code,{children:"lost"}),", reflecting the slot's current state regarding WAL retention."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"safe_wal_size"})}),(0,i.jsx)(t.td,{children:"bigint"}),(0,i.jsx)(t.td,{}),(0,i.jsxs)(t.td,{children:["Represents the amount of WAL data (in bytes) that can be written before the slot risks entering a ",(0,i.jsx)(t.code,{children:"lost"})," state. A value of zero or null indicates imminent risk or that the slot is already lost."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"two_phase"})}),(0,i.jsx)(t.td,{children:"boolean"}),(0,i.jsx)(t.td,{}),(0,i.jsxs)(t.td,{children:["Indicates whether the replication slot supports decoding of prepared transactions (two-phase commit). This is ",(0,i.jsx)(t.code,{children:"true"})," for logical slots with two-phase decoding enabled and ",(0,i.jsx)(t.code,{children:"false"})," for physical slots."]})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>l,a:()=>r});var i=s(67294);const n={},d=i.createContext(n);function r(e){const t=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(d.Provider,{value:t},e.children)}}}]);