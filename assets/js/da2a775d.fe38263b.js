"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[98219],{62396:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>d,toc:()=>o});var s=i(85893),a=i(11151);const t={title:"Create and Manage Indexes"},r="Create and Manage indexes",d={id:"operate-with-data/operate-with-db-objects/create-and-manage-indexes",title:"Create and Manage Indexes",description:"In traditional databases, indexes are commonly used to significantly improve data access performance. However, in distributed systems like Apache Cloudberry, indexes must be used more cautiously. Apache Cloudberry provides high-speed sequential scans, while index lookups rely on random disk access. Because data is distributed across multiple segments, each segment only needs to scan its local subset of data to return results. Combined with table partitioning, the amount of data scanned during a query can be further reduced. As a result, in business intelligence (BI) workloads\u2014which typically return large result sets\u2014indexes might introduce performance overhead instead of benefits.",source:"@site/versioned_docs/version-2.x/operate-with-data/operate-with-db-objects/create-and-manage-indexes.md",sourceDirName:"operate-with-data/operate-with-db-objects",slug:"/operate-with-data/operate-with-db-objects/create-and-manage-indexes",permalink:"/docs/operate-with-data/operate-with-db-objects/create-and-manage-indexes",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/operate-with-data/operate-with-db-objects/create-and-manage-indexes.md",tags:[],version:"2.x",lastUpdatedBy:"Dianjin Wang",lastUpdatedAt:1756369829,formattedLastUpdatedAt:"Aug 28, 2025",frontMatter:{title:"Create and Manage Indexes"},sidebar:"docsbars",previous:{title:"Create and Manage Materialized Views",permalink:"/docs/operate-with-data/operate-with-db-objects/create-and-manage-materialized-views"},next:{title:"BRIN Indexes",permalink:"/docs/operate-with-data/operate-with-db-objects/brin-indexes"}},l={},o=[{value:"Index types",id:"index-types",level:2},{value:"Bitmap indexes",id:"bitmap-indexes",level:3},{value:"Manage indexes",id:"manage-indexes",level:2},{value:"Cluster a table by index",id:"cluster-a-table-by-index",level:3},{value:"Create indexes",id:"create-indexes",level:3},{value:"Rebuild all indexes on a table",id:"rebuild-all-indexes-on-a-table",level:3},{value:"Drop indexes",id:"drop-indexes",level:3},{value:"Index-only scan and covering index",id:"index-only-scan-and-covering-index",level:2},{value:"What is an index-only scan",id:"what-is-an-index-only-scan",level:3},{value:"Requirements",id:"requirements",level:3},{value:"Additional note: MVCC visibility checks",id:"additional-note-mvcc-visibility-checks",level:3},{value:"Purpose of covering indexes",id:"purpose-of-covering-indexes",level:3},{value:"Dynamic index-only scan",id:"dynamic-index-only-scan",level:3},{value:"Backward index scan",id:"backward-index-scan",level:2},{value:"Check index usage",id:"check-index-usage",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"create-and-manage-indexes",children:"Create and Manage indexes"}),"\n",(0,s.jsx)(n.p,{children:"In traditional databases, indexes are commonly used to significantly improve data access performance. However, in distributed systems like Apache Cloudberry, indexes must be used more cautiously. Apache Cloudberry provides high-speed sequential scans, while index lookups rely on random disk access. Because data is distributed across multiple segments, each segment only needs to scan its local subset of data to return results. Combined with table partitioning, the amount of data scanned during a query can be further reduced. As a result, in business intelligence (BI) workloads\u2014which typically return large result sets\u2014indexes might introduce performance overhead instead of benefits."}),"\n",(0,s.jsx)(n.p,{children:"The recommended approach is to run queries without indexes first. If necessary, add indexes based on actual performance observations. Indexes are usually more suitable for OLTP scenarios, where queries often retrieve a single row or a small data range. For queries that return specific target rows, indexes can also provide performance gains on AO tables. In suitable cases, the planner might choose to use the index instead of scanning the entire table. For compressed data, index access allows the system to decompress only the required rows, improving overall efficiency."}),"\n",(0,s.jsxs)(n.p,{children:["When a table defines a primary key, Apache Cloudberry automatically creates a ",(0,s.jsx)(n.code,{children:"PRIMARY KEY"})," constraint. For partitioned tables, indexes must be created on the root table; the system will automatically propagate the index to all child tables. Note that you cannot manually add indexes to system-created child tables."]}),"\n",(0,s.jsxs)(n.p,{children:["In addition, a ",(0,s.jsx)(n.code,{children:"UNIQUE CONSTRAINT"})," (such as a ",(0,s.jsx)(n.code,{children:"PRIMARY KEY CONSTRAINT"}),") implicitly creates a ",(0,s.jsx)(n.code,{children:"UNIQUE INDEX"}),". This index must include all columns in both the distribution key and partition key, and it must enforce uniqueness across the entire table, including all partitions."]}),"\n",(0,s.jsxs)(n.p,{children:["Indexes introduce additional overhead: they consume storage and require maintenance during data updates. Therefore, always confirm that your query workload actually uses the indexes you create, and verify that they provide measurable performance improvements. You can check this by examining the query execution plan using ",(0,s.jsx)(n.code,{children:"EXPLAIN"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"index-types",children:"Index types"}),"\n",(0,s.jsxs)(n.p,{children:["Apache Cloudberry supports multiple PostgreSQL index types, including B-tree, Hash, GiST, SP-GiST, GIN, and ",(0,s.jsx)(n.a,{href:"/docs/operate-with-data/operate-with-db-objects/brin-indexes",children:"BRIN indexes"}),". Each type is suited to different query patterns. B-tree is the default and most widely applicable index type. For detailed explanations of each index type, refer to the PostgreSQL documentation on ",(0,s.jsx)(n.a,{href:"https://www.postgresql.org/docs/14/indexes-types.html",children:"index types"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"In Apache Cloudberry, the indexed columns of a unique index must either match the distribution key or include all its columns. On partitioned tables, unique indexes enforce uniqueness only within individual child tables, not across all partitions."})}),"\n",(0,s.jsx)(n.h3,{id:"bitmap-indexes",children:"Bitmap indexes"}),"\n",(0,s.jsx)(n.p,{children:"Bitmap indexes are especially suitable for typical data warehouse scenarios with large data volumes, frequent queries, and infrequent updates. Compared to regular indexes, bitmap indexes save storage space while efficiently handling multi-condition queries."}),"\n",(0,s.jsxs)(n.p,{children:["A bitmap index maintains a bitmap for each key value. Each bit in the bitmap indicates whether the corresponding row contains that value. Bitmaps can be combined using Boolean operations (such as ",(0,s.jsx)(n.code,{children:"AND"})," and ",(0,s.jsx)(n.code,{children:"OR"}),"), allowing efficient filtering across multiple conditions. Before accessing data, bitmap operations can eliminate large numbers of irrelevant rows, significantly improving query performance."]}),"\n",(0,s.jsx)(n.p,{children:"Recommended usage:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Ideal for analytical workloads in data warehouses."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Best suited for columns with medium cardinality (around 100 to 100,000 unique values)."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Especially effective for queries with multiple ",(0,s.jsx)(n.code,{children:"AND"})," or ",(0,s.jsx)(n.code,{children:"OR"})," conditions in the ",(0,s.jsx)(n.code,{children:"WHERE"})," clause."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Starting from v2.0.0, bitmap index scans can be triggered by array predicates (such as ",(0,s.jsx)(n.code,{children:"col IN (...)"})," or ",(0,s.jsx)(n.code,{children:"col = ANY(array)"}),"):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Works with both B-tree and hash indexes."}),"\n",(0,s.jsx)(n.li,{children:"Hash indexes, which previously only supported equality matches, now support array comparison predicates."}),"\n",(0,s.jsx)(n.li,{children:"The planner uses a cost-based model to decide whether to use a bitmap path."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example: The following query triggers a bitmap index scan, allowing the hash index to efficiently handle multi-value conditions in large datasets."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE users(id int, name text) DISTRIBUTED BY (id);\nCREATE INDEX ON users USING hash (name);\n\nSELECT * FROM users WHERE name IN ('alice', 'bob', 'carol');\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Limitations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Not suitable for unique or high-cardinality columns (such as user IDs or phone numbers)."}),"\n",(0,s.jsx)(n.li,{children:"Not recommended for OLTP workloads with frequent updates."}),"\n",(0,s.jsx)(n.li,{children:"Always validate performance benefits through testing before adding bitmap indexes."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"manage-indexes",children:"Manage indexes"}),"\n",(0,s.jsx)(n.h3,{id:"cluster-a-table-by-index",children:"Cluster a table by index"}),"\n",(0,s.jsxs)(n.p,{children:["You can use the ",(0,s.jsx)(n.code,{children:"CLUSTER"})," command to physically reorder table data based on an index. However, this operation can be time-consuming for very large tables. A more efficient alternative is to manually reorder the data by creating an intermediate table and inserting data in the desired order. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE new_table (LIKE old_table) \n    AS SELECT * FROM old_table ORDER BY myixcolumn;\nDROP old_table;\nALTER TABLE new_table RENAME TO old_table;\nCREATE INDEX myixcolumn_ix ON old_table;\nVACUUM ANALYZE old_table;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"create-indexes",children:"Create indexes"}),"\n",(0,s.jsxs)(n.p,{children:["Use the ",(0,s.jsx)(n.code,{children:"CREATE INDEX"})," command to create indexes on a table. The default index type is B-tree. For example, to create a B-tree index on the ",(0,s.jsx)(n.em,{children:"gender"})," column of the ",(0,s.jsx)(n.em,{children:"employee"})," table:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX gender_idx ON employee (gender);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To create a bitmap index on the ",(0,s.jsx)(n.em,{children:"title"})," column of the ",(0,s.jsx)(n.em,{children:"films"})," table:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX title_bmp_idx ON films USING bitmap (title);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"rebuild-all-indexes-on-a-table",children:"Rebuild all indexes on a table"}),"\n",(0,s.jsxs)(n.p,{children:["You can use the ",(0,s.jsx)(n.code,{children:"REINDEX"})," command to rebuild all indexes on a table or a specific index:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"REINDEX my_table;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Rebuild a single index on a table:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"REINDEX my_index;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"drop-indexes",children:"Drop indexes"}),"\n",(0,s.jsxs)(n.p,{children:["Use the ",(0,s.jsx)(n.code,{children:"DROP INDEX"})," command to remove an index. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"DROP INDEX title_idx;\n"})}),"\n",(0,s.jsx)(n.p,{children:"During data loading, dropping all indexes beforehand and recreating them after the load is complete can often improve overall performance."}),"\n",(0,s.jsx)(n.h2,{id:"index-only-scan-and-covering-index",children:"Index-only scan and covering index"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Apache Cloudberry supports index-only scans and covering indexes only on newly created tables."})}),"\n",(0,s.jsx)(n.h3,{id:"what-is-an-index-only-scan",children:"What is an index-only scan"}),"\n",(0,s.jsx)(n.p,{children:"In Apache Cloudberry, all indexes are secondary and stored separately from the main data (heap)."}),"\n",(0,s.jsx)(n.p,{children:"In a typical index scan, the planner uses the index to locate matching tuple positions, then accesses the heap via tuple pointers to fetch the actual data. Because data in the heap is usually not stored contiguously, this approach can lead to significant random I/O, especially on traditional spinning disks. Although bitmap scans can reduce this overhead to some extent, heap access is still required."}),"\n",(0,s.jsx)(n.p,{children:"An index-only scan is a scan method that can return results entirely from the index, without accessing the heap, which significantly improves query performance."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Starting from v2.0.0, Apache Cloudberry (using the ORCA optimizer) supports index-only scans on append-optimized (AO) and PAX tables, improving performance for repeated-read query workloads on these table types."})}),"\n",(0,s.jsx)(n.h3,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsx)(n.p,{children:"Two conditions must be met to enable index-only scans:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The index type must support index-only scans:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"B-tree indexes always support it."}),"\n",(0,s.jsx)(n.li,{children:"GiST and SP-GiST indexes support it with certain operator classes."}),"\n",(0,s.jsx)(n.li,{children:"GIN indexes do not support it (they only store partial field data)."}),"\n",(0,s.jsx)(n.li,{children:"Other index types generally do not support it."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"All columns referenced in the query must be included in the index:"}),"\n",(0,s.jsx)(n.p,{children:"Example queries that can use index-only scans:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT x, y FROM tab WHERE x = 'key';\nSELECT x FROM tab WHERE x = 'key' AND y < 42;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Example queries that cannot use index-only scans:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT x, z FROM tab WHERE x = 'key';\nSELECT x FROM tab WHERE x = 'key' AND z < 42;\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"additional-note-mvcc-visibility-checks",children:"Additional note: MVCC visibility checks"}),"\n",(0,s.jsx)(n.p,{children:"Even if both conditions above are met, the system must still verify whether each record is visible to the current transaction, according to multi-version concurrency control (MVCC) rules. Because visibility information is not stored in indexes, the system usually needs to access the heap for confirmation."}),"\n",(0,s.jsx)(n.p,{children:"To reduce the performance overhead of heap access, Apache Cloudberry uses a visibility map mechanism:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'If all tuples in a heap page are visible to all transactions, the page is marked as "all-visible".'}),"\n",(0,s.jsx)(n.li,{children:"During query execution, the system checks the visibility map first."}),"\n",(0,s.jsx)(n.li,{children:'If the page is "all-visible", it skips heap access and returns results directly.'}),"\n",(0,s.jsx)(n.li,{children:"Otherwise, the heap must still be accessed for visibility checks."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'Visibility maps are lightweight and usually cached entirely in memory, significantly reducing the cost of random I/O during queries. As a result, index-only scans offer real performance benefits only when most heap pages are marked as "all-visible".'}),"\n",(0,s.jsx)(n.h3,{id:"purpose-of-covering-indexes",children:"Purpose of covering indexes"}),"\n",(0,s.jsxs)(n.p,{children:["To better support index-only scans, you can explicitly create covering indexes that include all columns referenced in the query. Apache Cloudberry supports the ",(0,s.jsx)(n.code,{children:"INCLUDE"})," clause, which allows you to add non-filter columns to the index:"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Traditional index: accelerates only the WHERE clause, does not support index-only scan\nCREATE INDEX tab_x ON tab(x);\n\n-- Covering index: includes column y in the index, supports index-only scan\nCREATE INDEX tab_x_y ON tab(x) INCLUDE (y);\n\n-- Example query\nSELECT y FROM tab WHERE x = 'key';\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Columns added using ",(0,s.jsx)(n.code,{children:"INCLUDE"})," are not used for index matching. They are included only to cover the columns returned by the query. Therefore:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"They do not need to support indexable operations."}),"\n",(0,s.jsx)(n.li,{children:"In a unique index, they are not considered in uniqueness enforcement."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE UNIQUE INDEX tab_x_y ON tab(x) INCLUDE (y);\n-- Uniqueness is enforced on column x only, not on y\n"})}),"\n",(0,s.jsx)(n.p,{children:"Limitations and considerations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Index tuple size is limited. Including wide columns might lead to large index size and insertion failures."}),"\n",(0,s.jsx)(n.li,{children:"Adding non-key columns increases index size and might affect read or update performance."}),"\n",(0,s.jsx)(n.li,{children:"Covering indexes only help trigger index-only scans if the table is rarely updated (i.e., most pages are marked as all-visible)."}),"\n",(0,s.jsxs)(n.li,{children:["Expressions are not currently supported in the ",(0,s.jsx)(n.code,{children:"INCLUDE"})," clause."]}),"\n",(0,s.jsxs)(n.li,{children:["Currently, only B-tree and GiST index types support ",(0,s.jsx)(n.code,{children:"INCLUDE"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Starting from v2.0.0, Apache Cloudberry (using the ORCA optimizer) supports PostgreSQL-style ",(0,s.jsx)(n.code,{children:"INCLUDE"})," clauses on AO and PAX tables, enabling the creation of covering indexes."]})}),"\n",(0,s.jsx)(n.p,{children:"From v2.0.0 onward, the GPORCA optimizer considers both the width and the number of included columns when selecting an index-only scan path. If multiple indexes satisfy the query predicates and output requirements, the optimizer prefers narrower indexes with fewer fields to reduce I/O costs."}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t1 (c1 int, c2 int, c3 int, c4 int, c5 int);\n\nCREATE INDEX idx_large ON t1 USING btree(c1) INCLUDE (c2, c3, c4, c5);\nCREATE INDEX idx_c1 ON t1 USING btree(c1);\n\nEXPLAIN ANALYZE SELECT c1 FROM\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dynamic-index-only-scan",children:"Dynamic index-only scan"}),"\n",(0,s.jsx)(n.p,{children:"Dynamic index-only scan is an efficient query strategy used by Apache Cloudberry (with the ORCA optimizer) when querying partitioned tables. It combines two key techniques:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Index-only scan"}),': The query accesses only the index and avoids heap access, provided all referenced columns are covered by the index and the corresponding pages are marked as "all-visible" (e.g., after a ',(0,s.jsx)(n.code,{children:"VACUUM"})," operation)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic scan"}),": During execution, only the relevant partitions are selected based on query conditions, avoiding unnecessary partition access (i.e., partition pruning)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The core idea of dynamic index-only scan is to combine index-only access with partition pruning. This allows the system to scan only the relevant partitions and skip heap access, greatly improving query efficiency."}),"\n",(0,s.jsx)(n.p,{children:"It applies in the following scenarios:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The target is a partitioned table."}),"\n",(0,s.jsx)(n.li,{children:"The query references only columns included in the index (i.e., using a covering index)."}),"\n",(0,s.jsx)(n.li,{children:"The table has been vacuumed, and related pages are marked as all-visible."}),"\n",(0,s.jsx)(n.li,{children:"The table is wide, but the index is compact and includes only necessary columns."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Dynamic index-only scan significantly improves performance, reduces I/O, adapts automatically to partition structure, and is completely transparent to users."}),"\n",(0,s.jsx)(n.p,{children:"This feature is enabled by default. If it is disabled, run the following command to enable it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SET optimizer_enable_dynamicindexonlyscan = on;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE pt(a int, b text, c text) \nPARTITION BY RANGE(a) (START (0) END (100) EVERY (20));\n\nCREATE INDEX idx ON pt(a);  -- Covering index, includes only column a\n\n-- Insert a large volume of data and clean up\nINSERT INTO pt ...\nVACUUM pt;\n\n-- Query involves only column a and supports partition pruning\nSELECT a FROM pt WHERE a < 42;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"backward-index-scan",children:"Backward index scan"}),"\n",(0,s.jsxs)(n.p,{children:["For queries that include ",(0,s.jsx)(n.code,{children:"ORDER BY ... DESC"}),", the GPORCA optimizer might choose a backward index scan path using a B-tree index to avoid additional sorting operations."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE foo (a int, b int, c int) DISTRIBUTED BY (a);\nCREATE INDEX foo_b ON foo(b);\nINSERT INTO foo SELECT i, i, i FROM generate_series(1,10000) i;\nANALYZE foo;\n\nEXPLAIN SELECT * FROM foo ORDER BY b DESC LIMIT 1;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this query, although the ",(0,s.jsx)(n.code,{children:"foo_b"})," index is ordered in ascending order by default, the query requires descending order. The optimizer automatically selects a Backward IndexScan to scan the index in descending order, eliminating the need for a ",(0,s.jsx)(n.code,{children:"Sort"})," node:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"Limit\n  ->  Gather Motion 3:1\n        Merge Key: b\n        ->  Limit\n              ->  Index Scan Backward using foo_b on foo\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This optimization applies to both regular index scans (",(0,s.jsx)(n.code,{children:"IndexScan"}),") and index-only scans (",(0,s.jsx)(n.code,{children:"IndexOnlyScan"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"The following conditions must be met for the optimization to take effect:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A B-tree index is used."}),"\n",(0,s.jsxs)(n.li,{children:["The query includes an ",(0,s.jsx)(n.code,{children:"ORDER BY"})," clause that matches the index column."]}),"\n",(0,s.jsx)(n.li,{children:"The sort direction in the query is opposite to the index\u2019s default order."}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"NULLS FIRST"})," or ",(0,s.jsx)(n.code,{children:"NULLS LAST"})," is specified, the sort behavior must also match."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Backward IndexScan can significantly reduce the overhead of sorting operations, making it particularly effective for pagination or top-N queries."}),"\n",(0,s.jsx)(n.h2,{id:"check-index-usage",children:"Check index usage"}),"\n",(0,s.jsxs)(n.p,{children:["Indexes in Apache Cloudberry require no manual tuning or maintenance. However, you can evaluate their effectiveness by inspecting the actual query execution plan. Use the ",(0,s.jsx)(n.code,{children:"EXPLAIN"})," command to see whether a query uses an index."]}),"\n",(0,s.jsxs)(n.p,{children:["The query plan reveals how the database executes a query (known as ",(0,s.jsx)(n.em,{children:"plan nodes"}),") and provides cost estimates for each step. To check if an index is used, look for the following nodes in the ",(0,s.jsx)(n.code,{children:"EXPLAIN"})," output:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Index Scan"}),": retrieves data directly using the index."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bitmap Index Scan"}),": builds a bitmap based on query conditions and performs bitmap scan."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bitmap Heap Scan"}),": fetches rows from the heap using the bitmap."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"BitmapAnd"})," / ",(0,s.jsx)(n.strong,{children:"BitmapOr"}),": merges multiple bitmaps for compound conditions."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Here are some recommendations for evaluating and optimizing index usage:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Always run ",(0,s.jsx)(n.code,{children:"ANALYZE"})," after creating or modifying an index. This updates table statistics, which the optimizer uses to estimate row counts and choose the best plan."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Test with real data. Test data reflects the test environment only and does not represent actual production data distribution or behavior."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Avoid using small datasets for testing. Their behavior often differs significantly from large-scale data, and the results might not be meaningful."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Pay attention to data distribution when generating test data. Random and skewed values can all affect the accuracy of statistics."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"You can adjust GUC parameters to force the optimizer to use specific plans and evaluate index behavior. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SET enable_seqscan = off;\nSET enable_nestloop = off;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Disabling sequential scan and nested loop join encourages the system to choose an index-based path. Use ",(0,s.jsx)(n.code,{children:"EXPLAIN ANALYZE"})," on both indexed and non-indexed queries, compare the execution times and plans, and determine whether the index improves performance."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>d,a:()=>r});var s=i(67294);const a={},t=s.createContext(a);function r(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);