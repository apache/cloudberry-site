"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[80958],{56481:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var a=s(85893),n=s(11151);const i={title:"Load Data"},o="Load Data",r={id:"tutorials/best-practices/load-data-best-practices",title:"Load Data",description:"Description of the different ways to add data to Apache Cloudberry.",source:"@site/versioned_docs/version-2.x/tutorials/best-practices/load-data-best-practices.md",sourceDirName:"tutorials/best-practices",slug:"/tutorials/best-practices/load-data-best-practices",permalink:"/docs/tutorials/best-practices/load-data-best-practices",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/tutorials/best-practices/load-data-best-practices.md",tags:[],version:"2.x",lastUpdatedBy:"TomShawn",lastUpdatedAt:1758176984,formattedLastUpdatedAt:"Sep 18, 2025",frontMatter:{title:"Load Data"},sidebar:"docsbars",previous:{title:"Schema Design Best Practices",permalink:"/docs/tutorials/best-practices/schema-design-best-practices"},next:{title:"Encrypt Data and Database Connections",permalink:"/docs/tutorials/best-practices/db-encryption-best-practices"}},d={},l=[{value:"INSERT statement with column values",id:"insert-statement-with-column-values",level:2},{value:"COPY statement",id:"copy-statement",level:2},{value:"External tables",id:"external-tables",level:2},{value:"External tables with gpfdist",id:"external-tables-with-gpfdist",level:2},{value:"gpload",id:"gpload",level:2},{value:"Best practices",id:"best-practices",level:2}];function c(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"load-data",children:"Load Data"}),"\n",(0,a.jsx)(t.p,{children:"Description of the different ways to add data to Apache Cloudberry."}),"\n",(0,a.jsx)(t.h2,{id:"insert-statement-with-column-values",children:"INSERT statement with column values"}),"\n",(0,a.jsxs)(t.p,{children:["A singleton ",(0,a.jsx)(t.code,{children:"INSERT"})," statement with values adds a single row to a table. The row flows through the coordinator and is distributed to a segment. This is the slowest method and is not suitable for loading large amounts of data."]}),"\n",(0,a.jsx)(t.h2,{id:"copy-statement",children:"COPY statement"}),"\n",(0,a.jsxs)(t.p,{children:["The PostgreSQL ",(0,a.jsx)(t.code,{children:"COPY"})," statement copies data from an external file into a database table. It can insert multiple rows more efficiently than an ",(0,a.jsx)(t.code,{children:"INSERT"})," statement, but the rows are still passed through the coordinator. All of the data is copied in one command; it is not a parallel process."]}),"\n",(0,a.jsxs)(t.p,{children:["Data input to the ",(0,a.jsx)(t.code,{children:"COPY"})," command is from a file or the standard input. For example:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"COPY table FROM '/data/mydata.csv' WITH CSV HEADER;\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Use ",(0,a.jsx)(t.code,{children:"COPY"})," to add relatively small sets of data, for example dimension tables with up to ten thousand rows, or one-time data loads."]}),"\n",(0,a.jsxs)(t.p,{children:["Use ",(0,a.jsx)(t.code,{children:"COPY"})," when scripting a process that loads small amounts of data, less than 10 thousand rows."]}),"\n",(0,a.jsx)(t.p,{children:"Because COPY is a single command, there is no need to deactivate autocommit when you use this method to populate a table."}),"\n",(0,a.jsxs)(t.p,{children:["You can run multiple concurrent ",(0,a.jsx)(t.code,{children:"COPY"})," commands to improve performance."]}),"\n",(0,a.jsx)(t.h2,{id:"external-tables",children:"External tables"}),"\n",(0,a.jsxs)(t.p,{children:["External tables provide access to data in sources outside of Apache Cloudberry. They can be accessed with ",(0,a.jsx)(t.code,{children:"SELECT"})," statements and are commonly used with the Extract, Load, Transform (ELT) pattern, a variant of the Extract, Transform, Load (ETL) pattern that takes advantage of Apache Cloudberry's fast parallel data loading capability."]}),"\n",(0,a.jsx)(t.p,{children:"With ETL, data is extracted from its source, transformed outside of the database using external transformation tools, such as Datastage, and then loaded into the database."}),"\n",(0,a.jsxs)(t.p,{children:["With ELT, Cloudberry external tables provide access to data in external sources, which could be read-only files (for example, text, CSV, or XML files), Web servers, Hadoop file systems, executable OS programs, or the Cloudberry ",(0,a.jsx)(t.code,{children:"gpfdist"})," file server, described in the next section. External tables support SQL operations such as select, sort, and join so the data can be loaded and transformed simultaneously, or loaded into a ",(0,a.jsx)(t.em,{children:"load table"})," and transformed in the database into target tables."]}),"\n",(0,a.jsxs)(t.p,{children:["The external table is defined with a ",(0,a.jsx)(t.code,{children:"CREATE EXTERNAL TABLE"})," statement, which has a ",(0,a.jsx)(t.code,{children:"LOCATION"})," clause to define the location of the data and a ",(0,a.jsx)(t.code,{children:"FORMAT"})," clause to define the formatting of the source data so that the system can parse the input data. Files use the ",(0,a.jsx)(t.code,{children:"file://"})," protocol, and must reside on a segment host in a location accessible by the Cloudberry superuser. The data can be spread out among the segment hosts with no more than one file per primary segment on each host. The number of files listed in the ",(0,a.jsx)(t.code,{children:"LOCATION"})," clause is the number of segments that will read the external table in parallel."]}),"\n",(0,a.jsx)(t.h2,{id:"external-tables-with-gpfdist",children:"External tables with gpfdist"}),"\n",(0,a.jsxs)(t.p,{children:["The fastest way to load large fact tables is to use external tables with ",(0,a.jsx)(t.code,{children:"gpfdist"}),". ",(0,a.jsx)(t.code,{children:"gpfdist"})," is a file server program using an HTTP protocol that serves external data files to Apache Cloudberry segments in parallel. A ",(0,a.jsx)(t.code,{children:"gpfdist"})," instance can serve 200 MB/second and many ",(0,a.jsx)(t.code,{children:"gpfdist"})," processes can run simultaneously, each serving up a portion of the data to be loaded. When you begin the load using a statement such as ",(0,a.jsx)(t.code,{children:"INSERT INTO <table> SELECT * FROM <external_table>"}),", the ",(0,a.jsx)(t.code,{children:"INSERT"})," statement is parsed by the coordinator and distributed to the primary segments. The segments connect to the ",(0,a.jsx)(t.code,{children:"gpfdist"})," servers and retrieve the data in parallel, parse and validate the data, calculate a hash from the distribution key data and, based on the hash key, send the row to its destination segment. By default, each ",(0,a.jsx)(t.code,{children:"gpfdist"})," instance will accept up to 64 connections from segments. With many segments and ",(0,a.jsx)(t.code,{children:"gpfdist"})," servers participating in the load, data can be loaded at very high rates."]}),"\n",(0,a.jsxs)(t.p,{children:["Primary segments access external files in parallel when using ",(0,a.jsx)(t.code,{children:"gpfdist"})," up to the value of ",(0,a.jsx)(t.code,{children:"gp_external_max_segs"}),". When optimizing ",(0,a.jsx)(t.code,{children:"gpfdist"})," performance, maximize the parallelism as the number of segments increase. Spread the data evenly across as many ETL nodes as possible. Split very large data files into equal parts and spread the data across as many file systems as possible."]}),"\n",(0,a.jsxs)(t.p,{children:["Run two ",(0,a.jsx)(t.code,{children:"gpfdist"})," instances per file system. ",(0,a.jsx)(t.code,{children:"gpfdist"})," tends to be CPU bound on the segment nodes when loading. But if, for example, there are eight racks of segment nodes, there is lot of available CPU on the segments to drive more ",(0,a.jsx)(t.code,{children:"gpfdist"})," processes. Run ",(0,a.jsx)(t.code,{children:"gpfdist"})," on as many interfaces as possible. Be aware of bonded NICs and be sure to start enough ",(0,a.jsx)(t.code,{children:"gpfdist"})," instances to work them."]}),"\n",(0,a.jsx)(t.p,{children:"It is important to keep the work even across all these resources. The load is as fast as the slowest node. Skew in the load file layout will cause the overall load to bottleneck on that resource."}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"gp_external_max_segs"})," configuration parameter controls the number of segments each ",(0,a.jsx)(t.code,{children:"gpfdist"})," process serves. The default is 64. You can set a different value in the ",(0,a.jsx)(t.code,{children:"postgresql.conf"})," configuration file on the coordinator. Always keep ",(0,a.jsx)(t.code,{children:"gp_external_max_segs"})," and the number of ",(0,a.jsx)(t.code,{children:"gpfdist"})," processes an even factor; that is, the ",(0,a.jsx)(t.code,{children:"gp_external_max_segs"})," value should be a multiple of the number of ",(0,a.jsx)(t.code,{children:"gpfdist"})," processes. For example, if there are 12 segments and 4 ",(0,a.jsx)(t.code,{children:"gpfdist"})," processes, the planner round robins the segment connections as follows:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Segment 1  - gpfdist 1 \nSegment 2  - gpfdist 2 \nSegment 3  - gpfdist 3 \nSegment 4  - gpfdist 4 \nSegment 5  - gpfdist 1 \nSegment 6  - gpfdist 2 \nSegment 7  - gpfdist 3 \nSegment 8  - gpfdist 4 \nSegment 9  - gpfdist 1 \nSegment 10 - gpfdist 2 \nSegment 11 - gpfdist 3 \nSegment 12 - gpfdist 4\n"})}),"\n",(0,a.jsx)(t.p,{children:"Drop indexes before loading into existing tables and re-create the index after loading. Creating an index on pre-existing data is faster than updating it incrementally as each row is loaded."}),"\n",(0,a.jsxs)(t.p,{children:["Run ",(0,a.jsx)(t.code,{children:"ANALYZE"})," on the table after loading. Deactivate automatic statistics collection during loading by setting ",(0,a.jsx)(t.code,{children:"gp_autostats_mode"})," to ",(0,a.jsx)(t.code,{children:"NONE"}),". Run ",(0,a.jsx)(t.code,{children:"VACUUM"})," after load errors to recover space."]}),"\n",(0,a.jsx)(t.p,{children:"Performing small, high frequency data loads into heavily partitioned column-oriented tables can have a high impact on the system because of the number of physical files accessed per time interval."}),"\n",(0,a.jsx)(t.h2,{id:"gpload",children:"gpload"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"gpload"})," is a data loading utility that acts as an interface to the Cloudberry external table parallel loading feature."]}),"\n",(0,a.jsxs)(t.p,{children:["Beware of using ",(0,a.jsx)(t.code,{children:"gpload"})," as it can cause catalog bloat by creating and dropping external tables. Use ",(0,a.jsx)(t.code,{children:"gpfdist"})," instead, because it provides the best performance."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"gpload"})," runs a load using a specification defined in a YAML-formatted control file. It performs the following operations:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Invokes ",(0,a.jsx)(t.code,{children:"gpfdist"})," processes"]}),"\n",(0,a.jsx)(t.li,{children:"Creates a temporary external table definition based on the source data defined"}),"\n",(0,a.jsxs)(t.li,{children:["Runs an ",(0,a.jsx)(t.code,{children:"INSERT"}),", ",(0,a.jsx)(t.code,{children:"UPDATE"}),", or ",(0,a.jsx)(t.code,{children:"MERGE"})," operation to load the source data into the target table in the database"]}),"\n",(0,a.jsx)(t.li,{children:"Drops the temporary external table"}),"\n",(0,a.jsxs)(t.li,{children:["Cleans up ",(0,a.jsx)(t.code,{children:"gpfdist"})," processes"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The load is accomplished in a single transaction."}),"\n",(0,a.jsx)(t.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Drop any indexes on an existing table before loading data and recreate the indexes after loading. Newly creating an index is faster than updating an index incrementally as each row is loaded."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Deactivate automatic statistics collection during loading by setting the ",(0,a.jsx)(t.code,{children:"gp_autostats_mode"})," configuration parameter to ",(0,a.jsx)(t.code,{children:"NONE"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"External tables are not intended for frequent or ad hoc access."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["When using ",(0,a.jsx)(t.code,{children:"gpfdist"}),", maximize network bandwidth by running one ",(0,a.jsx)(t.code,{children:"gpfdist"})," instance for each NIC on the ETL server. Divide the source data evenly between the ",(0,a.jsx)(t.code,{children:"gpfdist"})," instances."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["When using ",(0,a.jsx)(t.code,{children:"gpload"}),", run as many simultaneous ",(0,a.jsx)(t.code,{children:"gpload"})," instances as resources allow. Take advantage of the CPU, memory, and networking resources available to increase the amount of data that can be transferred from ETL servers to the Apache Cloudberry."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Use the ",(0,a.jsx)(t.code,{children:"SEGMENT REJECT LIMIT"})," clause of the ",(0,a.jsx)(t.code,{children:"COPY"})," statement to set a limit for the number or percentage of rows that can have errors before the ",(0,a.jsx)(t.code,{children:"COPY FROM"})," command is cancelled. The reject limit is per segment; when any one segment exceeds the limit, the command is cancelled and no rows are added. Use the ",(0,a.jsx)(t.code,{children:"LOG ERRORS"})," clause to save error rows. If a row has errors in the formatting\u2014for example missing or extra values, or incorrect data types\u2014Apache Cloudberry stores the error information and row internally. Use the ",(0,a.jsx)(t.code,{children:"gp_read_error_log()"})," built-in SQL function to access this stored information."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["If the load has errors, run ",(0,a.jsx)(t.code,{children:"VACUUM"})," on the table to recover space."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["After you load data into a table, run ",(0,a.jsx)(t.code,{children:"VACUUM"})," on heap tables, including system catalogs, and ",(0,a.jsx)(t.code,{children:"ANALYZE"})," on all tables. It is not necessary to run ",(0,a.jsx)(t.code,{children:"VACUUM"})," on append-optimized tables. If the table is partitioned, you can vacuum and analyze just the partitions affected by the data load. These steps clean up any rows from prematurely ended loads, deletes, or updates and update statistics for the table."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Recheck for segment skew in the table after loading a large amount of data. You can use a query like the following to check for skew:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"SELECT gp_segment_id, count(*) \nFROM schema.table \nGROUP BY gp_segment_id ORDER BY 2;\n"})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["By default, ",(0,a.jsx)(t.code,{children:"gpfdist"})," assumes a maximum record size of 32K. To load data records larger than 32K, you must increase the maximum row size parameter by specifying the ",(0,a.jsx)(t.code,{children:"-m <*bytes*>"})," option on the ",(0,a.jsx)(t.code,{children:"gpfdist"})," command line. If you use ",(0,a.jsx)(t.code,{children:"gpload"}),", set the ",(0,a.jsx)(t.code,{children:"MAX_LINE_LENGTH"})," parameter in the ",(0,a.jsx)(t.code,{children:"gpload"})," control file."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>r,a:()=>o});var a=s(67294);const n={},i=a.createContext(n);function o(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);