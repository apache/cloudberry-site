"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[78407],{90338:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>a});var n=s(85893),r=s(11151);const i={title:"pg_stat_progress_create_index"},d="pg_stat_progress_create_index",c={id:"sys-catalogs/sys-views/pg-stat-progress-create-index",title:"pg_stat_progress_create_index",description:"The pgstatprogresscreateindex view provides real-time information about the progress of CREATE INDEX and REINDEX operations. Each row represents a backend process currently building an index and includes details such as the command type, current phase, number of blocks and tuples processed, and partitioning information. This view is useful for monitoring and managing long-running index creation tasks.",source:"@site/docs/sys-catalogs/sys-views/pg-stat-progress-create-index.md",sourceDirName:"sys-catalogs/sys-views",slug:"/sys-catalogs/sys-views/pg-stat-progress-create-index",permalink:"/docs/next/sys-catalogs/sys-views/pg-stat-progress-create-index",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/docs/sys-catalogs/sys-views/pg-stat-progress-create-index.md",tags:[],version:"current",lastUpdatedBy:"TomShawn",lastUpdatedAt:1748246802,formattedLastUpdatedAt:"May 26, 2025",frontMatter:{title:"pg_stat_progress_create_index"},sidebar:"docsbars",previous:{title:"pg_stat_progress_copy",permalink:"/docs/next/sys-catalogs/sys-views/pg-stat-progress-copy"},next:{title:"gp_toolkit",permalink:"/docs/next/sys-catalogs/gp_toolkit"}},o={},a=[];function l(e){const t={code:"code",h1:"h1",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"pg_stat_progress_create_index",children:"pg_stat_progress_create_index"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"pg_stat_progress_create_index"})," view provides real-time information about the progress of ",(0,n.jsx)(t.code,{children:"CREATE INDEX"})," and ",(0,n.jsx)(t.code,{children:"REINDEX"})," operations. Each row represents a backend process currently building an index and includes details such as the command type, current phase, number of blocks and tuples processed, and partitioning information. This view is useful for monitoring and managing long-running index creation tasks."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Column"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"gp_segment_id"})}),(0,n.jsx)(t.td,{children:"integer"}),(0,n.jsxs)(t.td,{children:["Unique identifier of a segment (or coordinator) instance. (This column is not present in the ",(0,n.jsx)(t.code,{children:"gp_stat_progress_create_index_summary"})," view.)"]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"pid"})}),(0,n.jsx)(t.td,{children:"integer"}),(0,n.jsxs)(t.td,{children:["Process identifier of the backend, or the coordinator process identifier if the ",(0,n.jsx)(t.code,{children:"gp_stat_progress_create_index_summary"})," view."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"datid"})}),(0,n.jsx)(t.td,{children:"oid"}),(0,n.jsx)(t.td,{children:"The object identifer of the database to which this backend is connected."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"datname"})}),(0,n.jsx)(t.td,{children:"name"}),(0,n.jsx)(t.td,{children:"Name of the database to which this backend is connected."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"relid"})}),(0,n.jsx)(t.td,{children:"oid"}),(0,n.jsx)(t.td,{children:"The object identifer of the table on which the index is being created."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"index_relid"})}),(0,n.jsx)(t.td,{children:"oid"}),(0,n.jsxs)(t.td,{children:["The object identifer of the index being created or reindexed. Because Apache Cloudberry does not support concurrent (re)indexing, this value is always ",(0,n.jsx)(t.code,{children:"0"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"command"})}),(0,n.jsx)(t.td,{children:"text"}),(0,n.jsxs)(t.td,{children:["The name of the command that is running: ",(0,n.jsx)(t.code,{children:"CREATE INDEX"})," or ",(0,n.jsx)(t.code,{children:"REINDEX"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"phase"})}),(0,n.jsx)(t.td,{children:"text"}),(0,n.jsx)(t.td,{children:"Current processing phase of index creation."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"lockers_total"})}),(0,n.jsx)(t.td,{children:"bigint"}),(0,n.jsx)(t.td,{children:"Total number of lockers to wait for, when applicable."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"lockers_done"})}),(0,n.jsx)(t.td,{children:"bigint"}),(0,n.jsx)(t.td,{children:"Number of lockers already waited for."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"current_locker_pid"})}),(0,n.jsx)(t.td,{children:"bigint"}),(0,n.jsx)(t.td,{children:"The process identifier of the locker currently being waited for."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"blocks_total"})}),(0,n.jsx)(t.td,{children:"bigint"}),(0,n.jsx)(t.td,{children:"Total number of blocks to be processed in the current phase."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"blocks_done"})}),(0,n.jsx)(t.td,{children:"bigint"}),(0,n.jsx)(t.td,{children:"Number of blocks already processed in the current phase."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"tuples_total"})}),(0,n.jsx)(t.td,{children:"bigint"}),(0,n.jsx)(t.td,{children:"Total number of tuples to be processed in the current phase."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"tuples_done"})}),(0,n.jsx)(t.td,{children:"bigint"}),(0,n.jsx)(t.td,{children:"Number of tuples already processed in the current phase."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"partitions_total"})}),(0,n.jsx)(t.td,{children:"bigint"}),(0,n.jsxs)(t.td,{children:["When creating an index on a partitioned table, this column is set to the total number of partitions on which the index is to be created. This field is 0 during a ",(0,n.jsx)(t.code,{children:"REINDEX"}),"."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"partitions_done"})}),(0,n.jsx)(t.td,{children:"bigint"}),(0,n.jsxs)(t.td,{children:["When creating an index on a partitioned table, this column is set to the number of partitions on which the index has been completed. This field is 0 during a ",(0,n.jsx)(t.code,{children:"REINDEX"}),"."]})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>c,a:()=>d});var n=s(67294);const r={},i=n.createContext(r);function d(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);