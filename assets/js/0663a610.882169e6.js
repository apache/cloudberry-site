"use strict";(self.webpackChunkApache_Cloudberry_Incubating_website=self.webpackChunkApache_Cloudberry_Incubating_website||[]).push([[97001],{97982:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var n=t(85893),s=t(11151);const o={title:"Develop a Background Worker Process"},i="Develope a Background Worker Process",a={id:"developer/develop-background-process-worker",title:"Develop a Background Worker Process",description:"Apache Cloudberry can be extended to run user-supplied code in separate processes. Such processes are started, stopped, and monitored by postgres, which permits them to have a lifetime closely linked to the server's status. These processes have the option to attach to Apache Cloudberry's shared memory area and to connect to databases internally; they can also run multiple transactions serially, just like a regular client-connected server process. Also, by linking to libpq they can connect to the server and behave like a regular client application.",source:"@site/versioned_docs/version-2.x/developer/develop-background-process-worker.md",sourceDirName:"developer",slug:"/developer/develop-background-process-worker",permalink:"/docs/developer/develop-background-process-worker",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/cloudberry-site/edit/main/versioned_docs/version-2.x/developer/develop-background-process-worker.md",tags:[],version:"2.x",lastUpdatedBy:"TomShawn",lastUpdatedAt:1767860953,formattedLastUpdatedAt:"Jan 8, 2026",frontMatter:{title:"Develop a Background Worker Process"},sidebar:"docsbars",previous:{title:"Monitor Long-Running Operations",permalink:"/docs/sys-admin/monitor-long-running-operations"},next:{title:"Develop Database Extensions Using PGRX",permalink:"/docs/developer/develop-extensions-using-rust"}},c={},d=[];function l(e){const r={code:"code",h1:"h1",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h1,{id:"develope-a-background-worker-process",children:"Develope a Background Worker Process"}),"\n",(0,n.jsxs)(r.p,{children:["Apache Cloudberry can be extended to run user-supplied code in separate processes. Such processes are started, stopped, and monitored by ",(0,n.jsx)(r.code,{children:"postgres"}),", which permits them to have a lifetime closely linked to the server's status. These processes have the option to attach to Apache Cloudberry's shared memory area and to connect to databases internally; they can also run multiple transactions serially, just like a regular client-connected server process. Also, by linking to ",(0,n.jsx)(r.code,{children:"libpq"})," they can connect to the server and behave like a regular client application."]}),"\n",(0,n.jsxs)(r.p,{children:[":::caution:\nThere are considerable robustness and security risks in using background worker processes because, being written in the ",(0,n.jsx)(r.code,{children:"C"})," language, they have unrestricted access to data. Administrators wishing to enable modules that include background worker processes should exercise extreme caution. Only carefully audited modules should be permitted to run background worker processes.\n:::"]}),"\n",(0,n.jsxs)(r.p,{children:["Background workers can be initialized at the time that Apache Cloudberry is started by including the module name in the shared_preload_libraries server configuration parameter. A module wishing to run a background worker can register it by calling ",(0,n.jsx)(r.code,{children:"RegisterBackgroundWorker(BackgroundWorker *worker)"})," from its ",(0,n.jsx)(r.code,{children:"_PG_init()"}),". Background workers can also be started after the system is up and running by calling the function ",(0,n.jsx)(r.code,{children:"RegisterDynamicBackgroundWorker(BackgroundWorker *worker, BackgroundWorkerHandle **handle)"}),". Unlike ",(0,n.jsx)(r.code,{children:"RegisterBackgroundWorker"}),", which can only be called from within the ",(0,n.jsx)(r.code,{children:"postmaster"}),", ",(0,n.jsx)(r.code,{children:"RegisterDynamicBackgroundWorker"})," must be called from a regular backend."]}),"\n",(0,n.jsxs)(r.p,{children:["The structure ",(0,n.jsx)(r.code,{children:"BackgroundWorker"})," is defined thus:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-c",children:"typedef void (*bgworker_main_type)(Datum main_arg);\ntypedef struct BackgroundWorker\n{\n    char        bgw_name[BGW_MAXLEN];\n    int         bgw_flags;\n    BgWorkerStartTime bgw_start_time;\n    int         bgw_restart_time;       /* in seconds, or BGW_NEVER_RESTART */\n    bgworker_main_type bgw_main;\n    char        bgw_library_name[BGW_MAXLEN];   /* only if bgw_main is NULL */\n    char        bgw_function_name[BGW_MAXLEN];  /* only if bgw_main is NULL */\n    Datum       bgw_main_arg;\n    int         bgw_notify_pid;\n} BackgroundWorker;\n"})}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"bgw_name"})," is a string to be used in log messages, process listings and similar contexts."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"bgw_flags"})," is a bitwise-or'd bit mask indicating the capabilities that the module wants. Possible values are ",(0,n.jsx)(r.code,{children:"BGWORKER_SHMEM_ACCESS"})," (requesting shared memory access) and ",(0,n.jsx)(r.code,{children:"BGWORKER_BACKEND_DATABASE_CONNECTION"})," (requesting the ability to establish a database connection, through which it can later run transactions and queries). A background worker using ",(0,n.jsx)(r.code,{children:"BGWORKER_BACKEND_DATABASE_CONNECTION"})," to connect to a database must also attach shared memory using ",(0,n.jsx)(r.code,{children:"BGWORKER_SHMEM_ACCESS"}),", or worker start-up will fail."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"bgw_start_time"})," is the server state during which ",(0,n.jsx)(r.code,{children:"postgres"})," should start the process; it can be one of ",(0,n.jsx)(r.code,{children:"BgWorkerStart_PostmasterStart"})," (start as soon as ",(0,n.jsx)(r.code,{children:"postgres"})," itself has finished its own initialization; processes requesting this are not eligible for database connections), ",(0,n.jsx)(r.code,{children:"BgWorkerStart_ConsistentState"})," (start as soon as a consistent state has been reached in a hot standby, allowing processes to connect to databases and run read-only queries), and ",(0,n.jsx)(r.code,{children:"BgWorkerStart_RecoveryFinished"})," (start as soon as the system has entered normal read-write state). Note the last two values are equivalent in a server that's not a hot standby. Note that this setting only indicates when the processes are to be started; they do not stop when a different state is reached."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"bgw_restart_time"})," is the interval, in seconds, that ",(0,n.jsx)(r.code,{children:"postgres"})," should wait before restarting the process, in case it crashes. It can be any positive value, or ",(0,n.jsx)(r.code,{children:"BGW_NEVER_RESTART"}),", indicating not to restart the process in case of a crash."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"bgw_main"})," is a pointer to the function to run when the process is started. This function must take a single argument of type ",(0,n.jsx)(r.code,{children:"Datum"})," and return ",(0,n.jsx)(r.code,{children:"void"}),". ",(0,n.jsx)(r.code,{children:"bgw_main_arg"})," will be passed to it as its only argument. Note that the global variable ",(0,n.jsx)(r.code,{children:"MyBgworkerEntry"})," points to a copy of the ",(0,n.jsx)(r.code,{children:"BackgroundWorker"})," structure passed at registration time. ",(0,n.jsx)(r.code,{children:"bgw_main"})," may be NULL; in that case, ",(0,n.jsx)(r.code,{children:"bgw_library_name"})," and ",(0,n.jsx)(r.code,{children:"bgw_function_name"})," will be used to determine the entry point. This is useful for background workers launched after postmaster startup, where the postmaster does not have the requisite library loaded."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"bgw_library_name"})," is the name of a library in which the initial entry point for the background worker should be sought. It is ignored unless ",(0,n.jsx)(r.code,{children:"bgw_main"})," is NULL. But if ",(0,n.jsx)(r.code,{children:"bgw_main"})," is NULL, then the named library will be dynamically loaded by the worker process and ",(0,n.jsx)(r.code,{children:"bgw_function_name"})," will be used to identify the function to be called."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"bgw_function_name"})," is the name of a function in a dynamically loaded library which should be used as the initial entry point for a new background worker. It is ignored unless ",(0,n.jsx)(r.code,{children:"bgw_main"})," is NULL."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"bgw_notify_pid"})," is the PID of a Apache Cloudberry backend process to which the postmaster should send ",(0,n.jsx)(r.code,{children:"SIGUSR1"})," when the process is started or exits. It should be 0 for workers registered at postmaster startup time, or when the backend registering the worker does not wish to wait for the worker to start up. Otherwise, it should be initialized to ",(0,n.jsx)(r.code,{children:"MyProcPid"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["Once running, the process can connect to a database by calling ",(0,n.jsx)(r.code,{children:"BackgroundWorkerInitializeConnection(char *dbname, char *username)"}),". This allows the process to run transactions and queries using the ",(0,n.jsx)(r.code,{children:"SPI"})," interface. If dbname is NULL, the session is not connected to any particular database, but shared catalogs can be accessed. If username is NULL, the process will run as the superuser created during ",(0,n.jsx)(r.code,{children:"initdb"}),". BackgroundWorkerInitializeConnection can only be called once per background process, it is not possible to switch databases."]}),"\n",(0,n.jsxs)(r.p,{children:["Signals are initially blocked when control reaches the ",(0,n.jsx)(r.code,{children:"bgw_main"})," function, and must be unblocked by it; this is to allow the process to customize its signal handlers, if necessary. Signals can be unblocked in the new process by calling ",(0,n.jsx)(r.code,{children:"BackgroundWorkerUnblockSignals"})," and blocked by calling ",(0,n.jsx)(r.code,{children:"BackgroundWorkerBlockSignals"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["If ",(0,n.jsx)(r.code,{children:"bgw_restart_time"})," for a background worker is configured as ",(0,n.jsx)(r.code,{children:"BGW_NEVER_RESTART"}),", or if it exits with an exit code of 0 or is terminated by ",(0,n.jsx)(r.code,{children:"TerminateBackgroundWorker"}),", it will be automatically unregistered by the postmaster on exit. Otherwise, it will be restarted after the time period configured via ",(0,n.jsx)(r.code,{children:"bgw_restart_time"}),", or immediately if the postmaster reinitializes the cluster due to a backend failure. Backends which need to suspend execution only temporarily should use an interruptible sleep rather than exiting; this can be achieved by calling ",(0,n.jsx)(r.code,{children:"WaitLatch()"}),". Make sure the ",(0,n.jsx)(r.code,{children:"WL_POSTMASTER_DEATH"})," flag is set when calling that function, and verify the return code for a prompt exit in the emergency case that ",(0,n.jsx)(r.code,{children:"postgres"})," itself has terminated."]}),"\n",(0,n.jsxs)(r.p,{children:["When a background worker is registered using the ",(0,n.jsx)(r.code,{children:"RegisterDynamicBackgroundWorker"})," function, it is possible for the backend performing the registration to obtain information regarding the status of the worker. Backends wishing to do this should pass the address of a ",(0,n.jsx)(r.code,{children:"BackgroundWorkerHandle *"})," as the second argument to ",(0,n.jsx)(r.code,{children:"RegisterDynamicBackgroundWorker"}),". If the worker is successfully registered, this pointer will be initialized with an opaque handle that can subsequently be passed to ",(0,n.jsx)(r.code,{children:"GetBackgroundWorkerPid(BackgroundWorkerHandle *, pid_t *)"})," or ",(0,n.jsx)(r.code,{children:"TerminateBackgroundWorker(BackgroundWorkerHandle *)"}),". ",(0,n.jsx)(r.code,{children:"GetBackgroundWorkerPid"})," can be used to poll the status of the worker: a return value of ",(0,n.jsx)(r.code,{children:"BGWH_NOT_YET_STARTED"})," indicates that the worker has not yet been started by the postmaster; ",(0,n.jsx)(r.code,{children:"BGWH_STOPPED"})," indicates that it has been started but is no longer running; and ",(0,n.jsx)(r.code,{children:"BGWH_STARTED"})," indicates that it is currently running. In this last case, the PID will also be returned via the second argument. ",(0,n.jsx)(r.code,{children:"TerminateBackgroundWorker"})," causes the postmaster to send ",(0,n.jsx)(r.code,{children:"SIGTERM"})," to the worker if it is running, and to unregister it as soon as it is not."]}),"\n",(0,n.jsxs)(r.p,{children:["In some cases, a process which registers a background worker may wish to wait for the worker to start up. This can be accomplished by initializing ",(0,n.jsx)(r.code,{children:"bgw_notify_pid"})," to ",(0,n.jsx)(r.code,{children:"MyProcPid"})," and then passing the ",(0,n.jsx)(r.code,{children:"BackgroundWorkerHandle *"})," obtained at registration time to ",(0,n.jsx)(r.code,{children:"WaitForBackgroundWorkerStartup("}),"BackgroundWorkerHandle *handle",(0,n.jsx)(r.code,{children:", "}),"pid_t *",(0,n.jsx)(r.code,{children:")"})," function. This function will block until the postmaster has attempted to start the background worker, or until the postmaster dies. If the background runner is running, the return value will ",(0,n.jsx)(r.code,{children:"BGWH_STARTED"}),", and the PID will be written to the provided address. Otherwise, the return value will be ",(0,n.jsx)(r.code,{children:"BGWH_STOPPED"})," or ",(0,n.jsx)(r.code,{children:"BGWH_POSTMASTER_DIED"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.code,{children:"worker_spi"})," contrib module contains a working example, which demonstrates some useful techniques."]}),"\n",(0,n.jsxs)(r.p,{children:["The maximum number of registered background workers is limited by the ",(0,n.jsx)(r.code,{children:"max_worker_processes"})," server configuration parameter."]})]})}function h(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},11151:(e,r,t)=>{t.d(r,{Z:()=>a,a:()=>i});var n=t(67294);const s={},o=n.createContext(s);function i(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);